
AVRASM ver. 2.1.30  C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm Tue Apr 13 06:57:38 2021

C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1090): warning: Register r5 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1091): warning: Register r4 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1092): warning: Register r6 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1093): warning: Register r7 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1094): warning: Register r8 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1095): warning: Register r9 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1096): warning: Register r10 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1097): warning: Register r11 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1098): warning: Register r12 already defined by the .DEF directive
C:\Firmware\AvrIspSd\AVR_GUI_ISP_SDCARD_V1.0.42.21\AVRispSD_BootSD_m328_V04\Release\List\Self_programming.asm(1099): warning: Register r13 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Release
                 ;Chip type              : ATmega328P
                 ;Program type           : Boot Loader
                 ;Clock frequency        : 8.000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 512 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_SMALL_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega328P
                 	#pragma AVRPART MEMORY PROG_FLASH 32768
                 	#pragma AVRPART MEMORY EEPROM 1024
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU EECR=0x1F
                 	.EQU EEDR=0x20
                 	.EQU EEARL=0x21
                 	.EQU EEARH=0x22
                 	.EQU SPSR=0x2D
                 	.EQU SPDR=0x2E
                 	.EQU SMCR=0x33
                 	.EQU MCUSR=0x34
                 	.EQU MCUCR=0x35
                 	.EQU WDTCSR=0x60
                 	.EQU UCSR0A=0xC0
                 	.EQU UDR0=0xC6
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU GPIOR0=0x1E
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x08FF
                 	.EQU __DSTACK_SIZE=0x0200
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF _token=R5
                 	.DEF _SectorsPerCluster=R4
                 	.DEF _RootEntryCnt=R6
                 	.DEF _RootEntryCnt_msb=R7
                 	.DEF _appPages=R8
                 	.DEF _appPages_msb=R9
                 	.DEF _pagesCnt=R10
                 	.DEF _pagesCnt_msb=R11
                 	.DEF _bytesChecksum=R12
                 	.DEF _bytesChecksum_msb=R13
                 
                 ;GPIOR0 INITIALIZATION VALUE
                 	.EQU __GPIOR0_INIT=0x00
                 
                 	.CSEG
                 	.ORG 0x3800
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
003800 940c 384e 	JMP  __RESET
003802 940c 3800 	JMP  0x3800
003804 940c 3800 	JMP  0x3800
003806 940c 3800 	JMP  0x3800
003808 940c 3800 	JMP  0x3800
00380a 940c 3800 	JMP  0x3800
00380c 940c 3800 	JMP  0x3800
00380e 940c 3800 	JMP  0x3800
003810 940c 3800 	JMP  0x3800
003812 940c 3800 	JMP  0x3800
003814 940c 3800 	JMP  0x3800
003816 940c 3800 	JMP  0x3800
003818 940c 3800 	JMP  0x3800
00381a 940c 3800 	JMP  0x3800
00381c 940c 3800 	JMP  0x3800
00381e 940c 3800 	JMP  0x3800
003820 940c 3800 	JMP  0x3800
003822 940c 3800 	JMP  0x3800
003824 940c 3800 	JMP  0x3800
003826 940c 3800 	JMP  0x3800
003828 940c 3800 	JMP  0x3800
00382a 940c 3800 	JMP  0x3800
00382c 940c 3800 	JMP  0x3800
00382e 940c 3800 	JMP  0x3800
003830 940c 3800 	JMP  0x3800
003832 940c 3800 	JMP  0x3800
                 
                 _0x40000:
003834 2030
003835 2020
003836 2020
003837 2020      	.DB  0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20
003838 2020
003839 0020
00383a 4c46
00383b 5341      	.DB  0x20,0x20,0x20,0x0,0x46,0x4C,0x41,0x53
00383c 2048
00383d 2020
00383e 5b00
00383f 6573      	.DB  0x48,0x20,0x20,0x20,0x0,0x5B,0x73,0x65
003840 7474
003841 6e69
003842 7367
003843 005d      	.DB  0x74,0x74,0x69,0x6E,0x67,0x73,0x5D,0x0
                 
                 __GLOBAL_INI_TBL:
003844 000c      	.DW  0x0C
003845 0300      	.DW  _0x4003D
003846 7068      	.DW  _0x40000*2
                 
003847 0009      	.DW  0x09
003848 030c      	.DW  _0x4003D+12
003849 7074      	.DW  _0x40000*2+12
                 
00384a 000b      	.DW  0x0B
00384b 0315      	.DW  _0x4003D+21
00384c 707d      	.DW  _0x40000*2+21
                 
                 _0xFFFFFFFF:
00384d 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
00384e 94f8      	CLI
00384f 27ee      	CLR  R30
003850 bbef      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF THE BOOT LOADER
003851 e0f1      	LDI  R31,1
003852 bff5      	OUT  MCUCR,R31
003853 e0f2      	LDI  R31,2
003854 bff5      	OUT  MCUCR,R31
                 
                 ;CLEAR R2-R14
003855 e08d      	LDI  R24,(14-2)+1
003856 e0a2      	LDI  R26,2
003857 27bb      	CLR  R27
                 __CLEAR_REG:
003858 93ed      	ST   X+,R30
003859 958a      	DEC  R24
00385a f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
00385b e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
00385c e098      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
00385d e0a0      	LDI  R26,LOW(__SRAM_START)
00385e e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
00385f 93ed      	ST   X+,R30
003860 9701      	SBIW R24,1
003861 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
003862 e8e8      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
003863 e7f0      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
003864 9185      	LPM  R24,Z+
003865 9195      	LPM  R25,Z+
003866 9700      	SBIW R24,0
003867 f061      	BREQ __GLOBAL_INI_END
003868 91a5      	LPM  R26,Z+
003869 91b5      	LPM  R27,Z+
00386a 9005      	LPM  R0,Z+
00386b 9015      	LPM  R1,Z+
00386c 01bf      	MOVW R22,R30
00386d 01f0      	MOVW R30,R0
                 __GLOBAL_INI_LOOP:
00386e 9005      	LPM  R0,Z+
00386f 920d      	ST   X+,R0
003870 9701      	SBIW R24,1
003871 f7e1      	BRNE __GLOBAL_INI_LOOP
003872 01fb      	MOVW R30,R22
003873 cff0      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;GPIOR0 INITIALIZATION
003874 e0e0      	LDI  R30,__GPIOR0_INIT
003875 bbee      	OUT  GPIOR0,R30
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
003876 efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
003877 bfed      	OUT  SPL,R30
003878 e0e8      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
003879 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00387a e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00387b e0d3      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00387c 940c 3966 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x300
                 
                 	.CSEG
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : All devices with bootloaders support.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains functions for easy reading and writing
                 ;*                       of Flash memory on parts having the "Self-programming"
                 ;*                       feature. The user functions are as follows:
                 ;*
                 ;*                       ReadFlashByte()
                 ;*                       ReadFlashPage()
                 ;*                       WriteFlashByte()
                 ;*                       WriteFlashPage()
                 ;*                       RecoverFlash()
                 ;*
                 ;*                       The remaining functions contained in this file are used
                 ;*                       by the functions listet above.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x01
                 	.EQU __sm_mask=0x0E
                 	.EQU __sm_adc_noise_red=0x02
                 	.EQU __sm_powerdown=0x04
                 	.EQU __sm_powersave=0x06
                 	.EQU __sm_standby=0x0C
                 	.EQU __sm_ext_standby=0x0E
                 	.SET power_ctrl_reg=smcr
                 	#endif
                 ;//#include <inavr.h>
                 ;#include "Self_programming.h"
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 out 0x37,r22
                 ;#include <delay.h>
                 ;
                 ;
                 ;//void (*__AddrToZ24ByteToSPMCR_SPM_W_Test)(void flash *addr)= (void(*)(void flash *)) 0x0F9E0;
                 ;//void (*__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test)(void flash *addr, unsigned int data)= (void(*)(void flash *, unsig ...
                 ;
                 ;
                 ;/*!
                 ;* Declare global struct variable in EEPROM if Flash recovery enabled.
                 ;* FlashBackup pageNumber holds Flash pageaddress (/PAGESIZE) the data in Flash
                 ;* recovery buffer should be written to if data need to be recovered.
                 ;* FlashBackup.status tells if data need to be recovered.
                 ;**/
                 ;#ifdef __FLASH_RECOVER
                 ;__eeprom struct {
                 ;  unsigned int  pageNumber;
                 ;  unsigned char status;
                 ;}FlashBackup = {0};
                 ;#endif
                 ;
                 ;
                 ;/*!
                 ;* The function Returns one byte located on Flash address given by ucFlashStartAdr.
                 ;**/
                 ;unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0000 003D unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 
                 	.CSEG
                 ; 0000 003E //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 003F   return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
                 ;	flashStartAdr -> Y+0
                 ; 0000 0040 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0041 } // Returns data from Flash
                 ;
                 ;/*!
                 ;* The function reads one Flash page from address flashStartAdr and stores data
                 ;* in array dataPage[]. The number of bytes stored is depending upon the
                 ;* Flash page size. The function returns FALSE if input address is not a Flash
                 ;* page address, else TRUE.
                 ;**/
                 ;unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 0049 unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 004A   unsigned int index;
                 ; 0000 004B   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
                 ; 0000 004C     for(index = 0; index < PAGESIZE; index++){
                 ; 0000 004D       dataPage[index] = ReadFlashByte(flashStartAdr + index);
                 ; 0000 004E     }
                 ; 0000 004F     return TRUE;                            // Return TRUE if valid page address
                 ; 0000 0050   }
                 ; 0000 0051   else{
                 ; 0000 0052     return FALSE;                           // Return FALSE if not valid page address
                 ; 0000 0053   }
                 ; 0000 0054 }
                 ;
                 ;/*!
                 ;* The function writes byte data to Flash address flashAddr. Returns FALSE if
                 ;* input address is not valid Flash byte address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 005A unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 005B   MyAddressType  pageAdr;
                 ; 0000 005C   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 005D   if( AddressCheck( flashAddr & ~(PAGESIZE-1) )){
                 ;	flashAddr -> Y+5
                 ;	data -> Y+4
                 ;	pageAdr -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	sregSettings -> R18
                 ; 0000 005E 
                 ; 0000 005F     eepromInterruptSettings= EECR & (1<<EERIE); // Stores EEPROM interrupt mask
                 ; 0000 0060     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
                 ; 0000 0061     _WAIT_FOR_EEWE();//while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 ; 0000 0062 
                 ; 0000 0063     sregSettings= SREG;
                 ; 0000 0064     #asm("cli");
                 ; 0000 0065     pageAdr=flashAddr & ~(PAGESIZE-1);      // Gets Flash page address from byte address
                 ; 0000 0066 
                 ; 0000 0067     #ifdef __FLASH_RECOVER
                 ; 0000 0068     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 0069                                             // not contain data for writing
                 ; 0000 006A     _WAIT_FOR_EEWE();//while(EECR & (1<<EEWE));
                 ; 0000 006B     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 006C     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 006D     FlashBackup.pageNumber = (unsigned int) (pageAdr/PAGESIZE); // Stores page address
                 ; 0000 006E                                                        // data should be written to
                 ; 0000 006F     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 0070                                                // contains unwritten data
                 ; 0000 0071     _WAIT_FOR_EEWE();//while(EECR & (1<<EEWE));
                 ; 0000 0072     #endif
                 ; 0000 0073 
                 ; 0000 0074     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0075 
                 ; 0000 0076 
                 ; 0000 0077     WriteBufToFlash(pageAdr);               // Writes to Flash
                 ; 0000 0078 
                 ; 0000 0079     #ifdef __FLASH_RECOVER
                 ; 0000 007A     FlashBackup.status = 0;                 // Indicates that Flash recovery buffer
                 ; 0000 007B                                             // does not contain unwritten data
                 ; 0000 007C     _WAIT_FOR_EEWE();//while(EECR & (1<<EEWE));
                 ; 0000 007D     #endif
                 ; 0000 007E 
                 ; 0000 007F     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 ; 0000 0080     SREG = sregSettings;
                 ; 0000 0081     return TRUE;                            // Return TRUE if address
                 ; 0000 0082                                             // valid for writing
                 ; 0000 0083   }
                 ; 0000 0084   else
                 ; 0000 0085     return FALSE;                           // Return FALSE if address not
                 ; 0000 0086                                             // valid for writing
                 ; 0000 0087 }
                 ;
                 ;/*!
                 ;* The function writes data from array dataPage[] to Flash page address
                 ;* flashStartAdr. The Number of bytes written is depending upon the Flash page
                 ;* size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
                 ;* page address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage)
                 ; 0000 0090 {
                 _WriteFlashPage:
                 ; .FSTART _WriteFlashPage
                 ; 0000 0091   unsigned int index=0;
                 ; 0000 0092   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 0093   if( AddressCheck(flashStartAdr) ){
00387e 93ba      	ST   -Y,R27
00387f 93aa      	ST   -Y,R26
003880 940e 3fe9 	CALL __SAVELOCR4
                 ;	flashStartAdr -> Y+6
                 ;	*dataPage -> Y+4
                 ;	index -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	sregSettings -> R18
                +
003882 e000     +LDI R16 , LOW ( 0 )
003883 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
003884 81ae      	LDD  R26,Y+6
003885 81bf      	LDD  R27,Y+6+1
003886 d050      	RCALL _AddressCheck
003887 30e0      	CPI  R30,0
003888 f409      	BRNE PC+2
003889 c048      	RJMP _0xD
                 ; 0000 0094     eepromInterruptSettings = EECR & (1<<EERIE); // Stoes EEPROM interrupt mask
00388a b3ef      	IN   R30,0x1F
00388b 70e8      	ANDI R30,LOW(0x8)
00388c 2f3e      	MOV  R19,R30
                 ; 0000 0095     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
00388d 98fb      	CBI  0x1F,3
                 ; 0000 0096     _WAIT_FOR_EEWE();//while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 _0xE:
00388e 99f9      	SBIC 0x1F,1
00388f cffe      	RJMP _0xE
                 ; 0000 0097 
                 ; 0000 0098     sregSettings= SREG;
003890 b72f      	IN   R18,63
                 ; 0000 0099     #asm("cli");
003891 94f8      	cli
                 ; 0000 009A 
                 ; 0000 009B     #ifdef __FLASH_RECOVER
                 ; 0000 009C     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 009D                                             // not contain data for writing
                 ; 0000 009E     while(EECR & (1<<EEWE));
                 ; 0000 009F 
                 ; 0000 00A0     //_ENABLE_RWW_SECTION();
                 ; 0000 00A1 
                 ; 0000 00A2     _WAIT_FOR_SPM();
                 ; 0000 00A3     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00A4 
                 ; 0000 00A5     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                 ; 0000 00A6       //_WAIT_FOR_SPM();
                 ; 0000 00A7       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00A8       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00A9     }
                 ; 0000 00AA 
                 ; 0000 00AB     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 00AC     FlashBackup.pageNumber=(unsigned int)(flashStartAdr/PAGESIZE);
                 ; 0000 00AD     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 00AE                                            // contains unwritten data
                 ; 0000 00AF     _WAIT_FOR_EEWE();//vwhile(EECR & (1<<EEWE));
                 ; 0000 00B0     #endif
                 ; 0000 00B1 
                 ; 0000 00B2     if(index==0xFFF1)
003892 efe1      	LDI  R30,LOW(65521)
003893 efff      	LDI  R31,HIGH(65521)
003894 17e0      	CP   R30,R16
003895 07f1      	CPC  R31,R17
003896 f461      	BRNE _0x11
                 ; 0000 00B3     {
                 ; 0000 00B4         #ifdef _ATMEGA128
                 ; 0000 00B5         __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
                 ; 0000 00B6         __AddrToZ24ByteToSPMCR_SPM_EW((void flash *)0x1EF00);
                 ; 0000 00B7         #endif
                 ; 0000 00B8         #ifdef _ATMEGA328
                 ; 0000 00B9         __AddrToZWordToR1R0ByteToSPMCR_SPM_F(0,0);
003897 e0e0      	LDI  R30,LOW(0)
003898 e0f0      	LDI  R31,HIGH(0)
003899 93fa      	ST   -Y,R31
00389a 93ea      	ST   -Y,R30
00389b e0a0      	LDI  R26,LOW(0)
00389c e0b0      	LDI  R27,0
00389d 940e 3906 	CALL ___AddrToZWordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00BA         __AddrToZByteToSPMCR_SPM_EW((void flash *)0x1EF00);
00389f e0a0      	LDI  R26,LOW(61184)
0038a0 eebf      	LDI  R27,HIGH(61184)
0038a1 940e 3940 	CALL ___AddrToZByteToSPMCR_SPM_EW
                 ; 0000 00BB         #endif
                 ; 0000 00BC     }
                 ; 0000 00BD     _WAIT_FOR_SPM();
                 _0x11:
                 _0x12:
0038a3 b7e7      	IN   R30,0x37
0038a4 fde0      	SBRC R30,0
0038a5 cffd      	RJMP _0x12
                 ; 0000 00BE     _PAGE_ERASE( flashStartAdr );
0038a6 81ae      	LDD  R26,Y+6
0038a7 81bf      	LDD  R27,Y+6+1
0038a8 940e 3913 	CALL ___AddrToZByteToSPMCR_SPM_E
                 ; 0000 00BF     //_ENABLE_RWW_SECTION();
                 ; 0000 00C0 
                 ; 0000 00C1     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                +
0038aa e000     +LDI R16 , LOW ( 0 )
0038ab e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x16:
                +
0038ac 3800     +CPI R16 , LOW ( 128 )
0038ad e0e0     +LDI R30 , HIGH ( 128 )
0038ae 071e     +CPC R17 , R30
                 	__CPWRN 16,17,128
0038af f4c8      	BRSH _0x17
                 ; 0000 00C2       //_WAIT_FOR_SPM();
                 ; 0000 00C3       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00C4       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
0038b0 931a      	ST   -Y,R17
0038b1 930a      	ST   -Y,R16
0038b2 01f8      	MOVW R30,R16
0038b3 81ae      	LDD  R26,Y+6
0038b4 81bf      	LDD  R27,Y+6+1
0038b5 0fae      	ADD  R26,R30
0038b6 1fbf      	ADC  R27,R31
0038b7 900c      	LD   R0,X
0038b8 2411      	CLR  R1
0038b9 9631      	ADIW R30,1
0038ba 81ae      	LDD  R26,Y+6
0038bb 81bf      	LDD  R27,Y+6+1
0038bc 0fae      	ADD  R26,R30
0038bd 1fbf      	ADC  R27,R31
0038be 91ec      	LD   R30,X
0038bf 2ffe      	MOV  R31,R30
0038c0 e0e0      	LDI  R30,0
0038c1 01d0      	MOVW R26,R0
0038c2 0fae      	ADD  R26,R30
0038c3 1fbf      	ADC  R27,R31
0038c4 940e 3906 	CALL ___AddrToZWordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00C5     }
                +
0038c6 5f0e     +SUBI R16 , LOW ( - 2 )
0038c7 4f1f     +SBCI R17 , HIGH ( - 2 )
                 	__ADDWRN 16,17,2
0038c8 cfe3      	RJMP _0x16
                 _0x17:
                 ; 0000 00C6     //_PAGE_WRITE( flashStartAdr );
                 ; 0000 00C7     WriteBufToFlash(flashStartAdr);         // Writes to Flash
0038c9 81ae      	LDD  R26,Y+6
0038ca 81bf      	LDD  R27,Y+6+1
0038cb d023      	RCALL _WriteBufToFlash
                 ; 0000 00C8     #ifdef __FLASH_RECOVER
                 ; 0000 00C9       FlashBackup.status=0;                 // Inicate that Flash buffer does
                 ; 0000 00CA                                             // not contain data for writing
                 ; 0000 00CB       while(EECR & (1<<EEWE));
                 ; 0000 00CC     #endif
                 ; 0000 00CD 
                 ; 0000 00CE     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
0038cc b3ef      	IN   R30,0x1F
0038cd 2be3      	OR   R30,R19
0038ce bbef      	OUT  0x1F,R30
                 ; 0000 00CF     SREG = sregSettings;
0038cf bf2f      	OUT  0x3F,R18
                 ; 0000 00D0     return TRUE;                            // Return TRUE if address
0038d0 e0e1      	LDI  R30,LOW(1)
0038d1 c001      	RJMP _0x200000B
                 ; 0000 00D1                                             // valid for writing
                 ; 0000 00D2   }
                 ; 0000 00D3   else
                 _0xD:
                 ; 0000 00D4     return FALSE;                           // Return FALSE if not address not
0038d2 e0e0      	LDI  R30,LOW(0)
                 ; 0000 00D5                                             // valid for writing
                 ; 0000 00D6 }
                 _0x200000B:
0038d3 940e 3ff0 	CALL __LOADLOCR4
0038d5 9628      	ADIW R28,8
0038d6 9508      	RET
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function checks if global variable FlashBackup.status indicates that Flash recovery
                 ;* buffer contains data that needs to be written to Flash. Writes data from
                 ;* Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
                 ;* This function should be called at program startup if FLASH recovery option
                 ;* is enabeled.
                 ;**/
                 ;unsigned char RecoverFlash(){
                 ; 0000 00DF unsigned char RecoverFlash(){
                 ; 0000 00E0 #ifdef __FLASH_RECOVER
                 ; 0000 00E1   unsigned int index;
                 ; 0000 00E2   unsigned long flashStartAdr = (MyAddressType)FlashBackup.pageNumber * PAGESIZE;
                 ; 0000 00E3   if(FlashBackup.status == FLASH_BUFFER_FULL_ID){ // Checks if Flash recovery
                 ; 0000 00E4                                                   //  buffer contains data
                 ; 0000 00E5 
                 ; 0000 00E6     for(index=0; index < PAGESIZE; index+=2){     // Writes to Flash write buffer
                 ; 0000 00E7         _WAIT_FOR_SPM();
                 ; 0000 00E8         MY_FILL_TEMP_WORD( index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER+index)) );
                 ; 0000 00E9     }
                 ; 0000 00EA 
                 ; 0000 00EB 
                 ; 0000 00EC     //WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
                 ; 0000 00ED     _WAIT_FOR_SPM();
                 ; 0000 00EE     MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 00EF     _WAIT_FOR_SPM();
                 ; 0000 00F0     MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 00F1     _WAIT_FOR_SPM();
                 ; 0000 00F2     _ENABLE_RWW_SECTION();
                 ; 0000 00F3     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00F4                                             // not contain data for writing
                 ; 0000 00F5     while(EECR & (1<<EEWE));
                 ; 0000 00F6     return TRUE;                            // Returns TRUE if recovery has
                 ; 0000 00F7                                             // taken place
                 ; 0000 00F8   }
                 ; 0000 00F9 #endif
                 ; 0000 00FA   return FALSE;
                 ; 0000 00FB }
                 ;
                 ;
                 ;/*!
                 ;* The function checks if input argument is a valid Flash page address for
                 ;* writing. Returns TRUE only if:
                 ;* - Address points to the beginning of a Flash page
                 ;* - Address is within the limits defined in Self_programming.h
                 ;* - Address is not equal to page address used for buffring by the Flash recovery
                 ;*   functions (if enabled).
                 ;* Returns FALSE else.
                 ;**/
                 ;unsigned char AddressCheck(MyAddressType flashAdr){
                 ; 0000 0107 unsigned char AddressCheck(MyAddressType flashAdr){
                 _AddressCheck:
                 ; .FSTART _AddressCheck
                 ; 0000 0108   #ifdef __FLASH_RECOVER
                 ; 0000 0109   // The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
                 ; 0000 010A   if( (flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
                 ; 0000 010B       (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE-1)) )
                 ; 0000 010C     return TRUE;                            // Address is a valid page address
                 ; 0000 010D   else
                 ; 0000 010E     return FALSE;                           // Address is not a valid page address
                 ; 0000 010F   #else
                 ; 0000 0110   if((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE-1) ) )
0038d7 940e 3e1c 	CALL SUBOPT_0x0
                 ;	flashAdr -> Y+0
0038d9 2788      	CLR  R24
0038da 2799      	CLR  R25
0038db 2399      	TST  R25
0038dc f05a      	BRMI _0x1A
0038dd 81a8      	LD   R26,Y
0038de 81b9      	LDD  R27,Y+1
0038df 30a0      	CPI  R26,LOW(0x7000)
0038e0 e7e0      	LDI  R30,HIGH(0x7000)
0038e1 07be      	CPC  R27,R30
0038e2 f428      	BRSH _0x1A
0038e3 81e8      	LD   R30,Y
0038e4 81f9      	LDD  R31,Y+1
0038e5 77ef      	ANDI R30,0x7F
0038e6 30e0      	CPI  R30,0
0038e7 f009      	BREQ _0x1B
                 _0x1A:
0038e8 c003      	RJMP _0x19
                 _0x1B:
                 ; 0000 0111     return TRUE;                            // Address is a valid page address
0038e9 e0e1      	LDI  R30,LOW(1)
0038ea 940c 3d67 	JMP  _0x2000007
                 ; 0000 0112   else
                 _0x19:
                 ; 0000 0113   {
                 ; 0000 0114     /*
                 ; 0000 0115     while(1)
                 ; 0000 0116     {
                 ; 0000 0117       PORTC.5=0;
                 ; 0000 0118       delay_ms(500);
                 ; 0000 0119       PORTC.5=1;
                 ; 0000 011A       delay_ms(500);
                 ; 0000 011B     }
                 ; 0000 011C     */
                 ; 0000 011D     return FALSE;                           // Address is not a valid page address
0038ec e0e0      	LDI  R30,LOW(0)
0038ed 940c 3d67 	JMP  _0x2000007
                 ; 0000 011E   }
                 ; 0000 011F   #endif
                 ; 0000 0120 }
                 ; .FEND
                 ;
                 ;
                 ;/*!
                 ;* The function writes Flash temporary buffer to Flash page address given by
                 ;* input argument.
                 ;**/
                 ;
                 ;void WriteBufToFlash(MyAddressType flashStartAdr) {
                 ; 0000 0128 void WriteBufToFlash(MyAddressType flashStartAdr) {
                 _WriteBufToFlash:
                 ; .FSTART _WriteBufToFlash
                 ; 0000 0129     //_WAIT_FOR_SPM();
                 ; 0000 012A     //MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 012B     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 012C     //_WAIT_FOR_SPM();
                 ; 0000 012D     //_ENABLE_RWW_SECTION();
                 ; 0000 012E     //MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 012F     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 0130     _PAGE_WRITE( flashStartAdr );
0038ef 940e 3e1c 	CALL SUBOPT_0x0
                 ;	flashStartAdr -> Y+0
0038f1 940e 3928 	CALL ___AddrToZByteToSPMCR_SPM_W
                 ; 0000 0131     //_WAIT_FOR_SPM();
                 ; 0000 0132     //_ENABLE_RWW_SECTION();
                 ; 0000 0133 /*
                 ; 0000 0134 #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 0135   #ifdef __HAS_RAMPZ__
                 ; 0000 0136   RAMPZ = (unsigned char)(flashStartAdr >> 16);
                 ; 0000 0137   #endif
                 ; 0000 0138   _PAGE_ERASE(flashStartAdr);
                 ; 0000 0139   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 013A   _PAGE_WRITE(flashStartAdr);
                 ; 0000 013B   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 013C   #ifdef RWWSRE
                 ; 0000 013D   __DataToR0ByteToSPMCR_SPM( 0, (unsigned char)(1<<RWWSRE)|(1<<SPMEN)); // Enable RWW
                 ; 0000 013E   #endif
                 ; 0000 013F #pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0140 */
                 ; 0000 0141 }
0038f3 940c 3d67 	JMP  _0x2000007
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads Flash page given by flashAddr, replaces one byte given by
                 ;* flashAddr with data, and stores entire page in Flash temporary buffer.
                 ;**/
                 ;void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0147 void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0148 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 0149     unsigned int index, oddByte, pcWord;
                 ; 0000 014A 
                 ; 0000 014B     MyAddressType  pageAdr;
                 ; 0000 014C     oddByte=(unsigned char)flashAddr & 1;
                 ;	flashAddr -> Y+9
                 ;	data -> Y+8
                 ;	index -> R16,R17
                 ;	oddByte -> R18,R19
                 ;	pcWord -> R20,R21
                 ;	pageAdr -> Y+6
                 ; 0000 014D     pcWord=(unsigned int)flashAddr & (PAGESIZE-2); // Used when writing FLASH temp buffer
                 ; 0000 014E     pageAdr=flashAddr & ~(PAGESIZE-1);        // Get FLASH page address from byte address
                 ; 0000 014F     //while( SPMCR_REG & (1<<SPMEN) );
                 ; 0000 0150     //_ENABLE_RWW_SECTION();
                 ; 0000 0151 
                 ; 0000 0152     for(index=0; index < PAGESIZE; index+=2){
                 ; 0000 0153         if(index==pcWord){
                 ; 0000 0154           if(oddByte){
                 ; 0000 0155             //MY_FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 0156             _FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 0157           }                                     // Write odd byte in temporary buffer
                 ; 0000 0158           else{
                 ; 0000 0159             //MY_FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 015A             _FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 015B           }                                     // Write even byte in temporary buffer
                 ; 0000 015C         }
                 ; 0000 015D         else{
                 ; 0000 015E           //MY_FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 015F           _FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0160         }                                       // Write Flash word directly to temporary buffer
                 ; 0000 0161     }
                 ; 0000 0162 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0163 }
                 ;/*****************************************************************************
                 ;*
                 ;* (C) 2010, HP InfoTech srl, www.hpinfotech.com
                 ;*
                 ;* File              : flash.c
                 ;* Compiler          : CodeVisionAVR V2.xx
                 ;* Revision          : $Revision: 1.0 $
                 ;* Date              : $Date: December 9, 2010 $
                 ;* Updated by        : $Author: HP InfoTech $
                 ;*
                 ;* Target platform   : All AVRs with bootloader support
                 ;*
                 ;* AppNote           : AVR109 - Self-programming
                 ;*
                 ;* Description       : Flash operations for AVR109 Self-programming
                 ;****************************************************************************/
                 ;
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 out 0x37,r22
                 ;
                 ;//#define	SPMCR_REG	SPMCSR
                 ;
                 ;void dospmew(void)
                 ; 0001 0018 {
                 
                 	.CSEG
                 ; 0001 0019     #asm
                 ; 0001 001A          ldi   r22,$03
                 ; 0001 001B          WR_SPMCR_REG_R22
                 ; 0001 001C          spm
                 ; 0001 001D     #endasm
                 ; 0001 001E     _WAIT_FOR_SPM();
                 ; 0001 001F     #asm
                 ; 0001 0020         ldi   r22,$11
                 ; 0001 0021         WR_SPMCR_REG_R22
                 ; 0001 0022         spm
                 ; 0001 0023     #endasm
                 ; 0001 0024     _WAIT_FOR_SPM();
                 ; 0001 0025     #asm
                 ; 0001 0026         ldi   r22,$05
                 ; 0001 0027         WR_SPMCR_REG_R22
                 ; 0001 0028         spm
                 ; 0001 0029     #endasm
                 ; 0001 002A     _WAIT_FOR_SPM();
                 ; 0001 002B     do
                 ; 0001 002C     {
                 ; 0001 002D     #asm
                 ; 0001 002E         ldi   r22,$11
                 ; 0001 002F         WR_SPMCR_REG_R22
                 ; 0001 0030         spm
                 ; 0001 0031     #endasm
                 ; 0001 0032         _WAIT_FOR_SPM();
                 ; 0001 0033     }
                 ; 0001 0034     while( SPMCR_REG & (1<<RWWSB) );
                 ; 0001 0035 }
                 ;
                 ;void dospmw(void)
                 ; 0001 0038 {
                 ; 0001 0039     #asm
                 ; 0001 003A         ldi   r22,$05
                 ; 0001 003B         WR_SPMCR_REG_R22
                 ; 0001 003C         spm
                 ; 0001 003D     #endasm
                 ; 0001 003E     _WAIT_FOR_SPM();
                 ; 0001 003F     do
                 ; 0001 0040     {
                 ; 0001 0041     #asm
                 ; 0001 0042         ldi   r22,$11
                 ; 0001 0043         WR_SPMCR_REG_R22
                 ; 0001 0044         spm
                 ; 0001 0045     #endasm
                 ; 0001 0046         _WAIT_FOR_SPM();
                 ; 0001 0047     }
                 ; 0001 0048     while( SPMCR_REG & (1<<RWWSB) );
                 ; 0001 0049 }
                 ;
                 ;void dospme(void)
                 ; 0001 004C {
                 ; 0001 004D     #asm
                 ; 0001 004E         ldi   r22,$03
                 ; 0001 004F         WR_SPMCR_REG_R22
                 ; 0001 0050         spm
                 ; 0001 0051     #endasm
                 ; 0001 0052     _WAIT_FOR_SPM();
                 ; 0001 0053     //while( SPMCR_REG & (1<<RWWSB) )
                 ; 0001 0054     {
                 ; 0001 0055     #asm
                 ; 0001 0056         ldi   r22,$11
                 ; 0001 0057         WR_SPMCR_REG_R22
                 ; 0001 0058         spm
                 ; 0001 0059     #endasm
                 ; 0001 005A         _WAIT_FOR_SPM();
                 ; 0001 005B     }
                 ; 0001 005C }
                 ;
                 ;void dospm(void)
                 ; 0001 005F {
                 _dospm:
                 ; .FSTART _dospm
                 ; 0001 0060     #asm
                 ; 0001 0061          ldi   r22,$01
0038f5 e061               ldi   r22,$01
                 ; 0001 0062          WR_SPMCR_REG_R22
0038f6 bf67               WR_SPMCR_REG_R22
                 ; 0001 0063          spm
0038f7 95e8               spm
                 ; 0001 0064     #endasm
                 ; 0001 0065     _WAIT_FOR_SPM();
                 _0x20021:
0038f8 b7e7      	IN   R30,0x37
0038f9 fde0      	SBRC R30,0
0038fa cffd      	RJMP _0x20021
                 ; 0001 0066     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20024:
0038fb b7e7      	IN   R30,0x37
0038fc ffe6      	SBRS R30,6
0038fd c007      	RJMP _0x20026
                 ; 0001 0067     {
                 ; 0001 0068     #asm
                 ; 0001 0069         ldi   r22,$11
0038fe e161              ldi   r22,$11
                 ; 0001 006A         WR_SPMCR_REG_R22
0038ff bf67              WR_SPMCR_REG_R22
                 ; 0001 006B         spm
003900 95e8              spm
                 ; 0001 006C     #endasm
                 ; 0001 006D         _WAIT_FOR_SPM();
                 _0x20027:
003901 b7e7      	IN   R30,0x37
003902 fde0      	SBRC R30,0
003903 cffd      	RJMP _0x20027
                 ; 0001 006E     }
003904 cff6      	RJMP _0x20024
                 _0x20026:
                 ; 0001 006F }
003905 9508      	RET
                 ; .FEND
                 ;
                 ;#pragma warn-
                 ;
                 ;unsigned char __AddrToZByteToSPMCR_LPM(void flash *addr, unsigned char ctrl)
                 ; 0001 0074 {
                 ; 0001 0075 #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 0076      ldd  r30,y+1
                 ; 0001 0077      ldd  r31,y+2
                 ; 0001 0078      ld   r22,y
                 ; 0001 0079      WR_SPMCR_REG_R22
                 ; 0001 007A      lpm
                 ; 0001 007B      mov  r30,r0
                 ; 0001 007C #endasm
                 ; 0001 007D }
                 ;
                 ;void __DataToR0ByteToSPMCR_SPM(unsigned char data, unsigned char ctrl)
                 ; 0001 0080 {
                 ; 0001 0081 #asm
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 0082      ldd  r0,y+1
                 ; 0001 0083      ld   r22,y
                 ; 0001 0084      WR_SPMCR_REG_R22
                 ; 0001 0085      spm
                 ; 0001 0086 #endasm
                 ; 0001 0087 }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 008A {
                 ; 0001 008B     #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 008C          ldd  r30,y+3
                 ; 0001 008D          ldd  r31,y+4
                 ; 0001 008E          ldd  r0,y+1
                 ; 0001 008F          ldd  r1,y+2
                 ; 0001 0090          ld   r22,y
                 ; 0001 0091          WR_SPMCR_REG_R22
                 ; 0001 0092          spm
                 ; 0001 0093     #endasm
                 ; 0001 0094 }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 0097 {
                 ___AddrToZWordToR1R0ByteToSPMCR_SPM_F:
                 ; .FSTART ___AddrToZWordToR1R0ByteToSPMCR_SPM_F
                 ; 0001 0098 _WAIT_FOR_SPM();
003906 93ba      	ST   -Y,R27
003907 93aa      	ST   -Y,R26
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 _0x2002A:
003908 b7e7      	IN   R30,0x37
003909 fde0      	SBRC R30,0
00390a cffd      	RJMP _0x2002A
                 ; 0001 0099     #asm
                 ; 0001 009A          ldd  r30,y+2
00390b 81ea               ldd  r30,y+2
                 ; 0001 009B          ldd  r31,y+3
00390c 81fb               ldd  r31,y+3
                 ; 0001 009C          ldd  r0,y+0
00390d 8008               ldd  r0,y+0
                 ; 0001 009D          ldd  r1,y+1
00390e 8019               ldd  r1,y+1
                 ; 0001 009E          //ldi   r22,LOW(1)
                          //ldi   r22,LOW(1)
                 ; 0001 009F          //WR_SPMCR_REG_R22
                          //WR_SPMCR_REG_R22
                 ; 0001 00A0          //spm
                          //spm
                 ; 0001 00A1     #endasm
                 ; 0001 00A2 dospm();
00390f 940e 38f5 	CALL _dospm
                 ; 0001 00A3 }
003911 940c 3d2c 	JMP  _0x2000008
                 ; .FEND
                 ;
                 ;void __AddrToZByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 00A6 {
                 ; 0001 00A7 #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00A8      ldd  r30,y+1
                 ; 0001 00A9      ldd  r31,y+2
                 ; 0001 00AA      ld   r22,y
                 ; 0001 00AB      WR_SPMCR_REG_R22
                 ; 0001 00AC      spm
                 ; 0001 00AD #endasm
                 ; 0001 00AE }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_E(void flash *addr)
                 ; 0001 00B1 {
                 ___AddrToZByteToSPMCR_SPM_E:
                 ; .FSTART ___AddrToZByteToSPMCR_SPM_E
                 ; 0001 00B2     _WAIT_FOR_SPM();
003913 93ba      	ST   -Y,R27
003914 93aa      	ST   -Y,R26
                 ;	*addr -> Y+0
                 _0x2002D:
003915 b7e7      	IN   R30,0x37
003916 fde0      	SBRC R30,0
003917 cffd      	RJMP _0x2002D
                 ; 0001 00B3     #asm
                 ; 0001 00B4          ldd  r30,y+0
003918 81e8               ldd  r30,y+0
                 ; 0001 00B5          ldd  r31,y+1
003919 81f9               ldd  r31,y+1
                 ; 0001 00B6          //ld   r22,y
                          //ld   r22,y
                 ; 0001 00B7          //WR_SPMCR_REG_R22
                          //WR_SPMCR_REG_R22
                 ; 0001 00B8          //spm
                          //spm
                 ; 0001 00B9     #endasm
                 ; 0001 00BA     #asm
                 ; 0001 00BB         ldi   r22,$03
00391a e063              ldi   r22,$03
                 ; 0001 00BC         WR_SPMCR_REG_R22
00391b bf67              WR_SPMCR_REG_R22
                 ; 0001 00BD         spm
00391c 95e8              spm
                 ; 0001 00BE     #endasm
                 ; 0001 00BF     _WAIT_FOR_SPM();
                 _0x20030:
00391d b7e7      	IN   R30,0x37
00391e fde0      	SBRC R30,0
00391f cffd      	RJMP _0x20030
                 ; 0001 00C0     //while( SPMCR_REG & (1<<RWWSB) )
                 ; 0001 00C1     {
                 ; 0001 00C2     #asm
                 ; 0001 00C3         ldi   r22,$11
003920 e161              ldi   r22,$11
                 ; 0001 00C4         WR_SPMCR_REG_R22
003921 bf67              WR_SPMCR_REG_R22
                 ; 0001 00C5         spm
003922 95e8              spm
                 ; 0001 00C6     #endasm
                 ; 0001 00C7         _WAIT_FOR_SPM();
                 _0x20033:
003923 b7e7      	IN   R30,0x37
003924 fde0      	SBRC R30,0
003925 cffd      	RJMP _0x20033
                 ; 0001 00C8     }
                 ; 0001 00C9 //dospme();
                 ; 0001 00CA }
003926 940c 3d67 	JMP  _0x2000007
                 ; .FEND
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00CD {
                 ___AddrToZByteToSPMCR_SPM_W:
                 ; .FSTART ___AddrToZByteToSPMCR_SPM_W
                 ; 0001 00CE     _WAIT_FOR_SPM();
003928 93ba      	ST   -Y,R27
003929 93aa      	ST   -Y,R26
                 ;	*addr -> Y+0
                 _0x20036:
00392a b7e7      	IN   R30,0x37
00392b fde0      	SBRC R30,0
00392c cffd      	RJMP _0x20036
                 ; 0001 00CF     #asm
                 ; 0001 00D0          ldd  r30,y+0
00392d 81e8               ldd  r30,y+0
                 ; 0001 00D1          ldd  r31,y+1
00392e 81f9               ldd  r31,y+1
                 ; 0001 00D2          //ld   r22,y
                          //ld   r22,y
                 ; 0001 00D3          //WR_SPMCR_REG_R22
                          //WR_SPMCR_REG_R22
                 ; 0001 00D4          //spm
                          //spm
                 ; 0001 00D5     #endasm
                 ; 0001 00D6     #asm
                 ; 0001 00D7         ldi   r22,$05
00392f e065              ldi   r22,$05
                 ; 0001 00D8         WR_SPMCR_REG_R22
003930 bf67              WR_SPMCR_REG_R22
                 ; 0001 00D9         spm
003931 95e8              spm
                 ; 0001 00DA     #endasm
                 ; 0001 00DB     _WAIT_FOR_SPM();
                 _0x20039:
003932 b7e7      	IN   R30,0x37
003933 fde0      	SBRC R30,0
003934 cffd      	RJMP _0x20039
                 ; 0001 00DC     do
                 _0x2003D:
                 ; 0001 00DD     {
                 ; 0001 00DE     #asm
                 ; 0001 00DF         ldi   r22,$11
003935 e161              ldi   r22,$11
                 ; 0001 00E0         WR_SPMCR_REG_R22
003936 bf67              WR_SPMCR_REG_R22
                 ; 0001 00E1         spm
003937 95e8              spm
                 ; 0001 00E2     #endasm
                 ; 0001 00E3         _WAIT_FOR_SPM();
                 _0x2003F:
003938 b7e7      	IN   R30,0x37
003939 fde0      	SBRC R30,0
00393a cffd      	RJMP _0x2003F
                 ; 0001 00E4     }
                 ; 0001 00E5     while( SPMCR_REG & (1<<RWWSB) );
00393b b7e7      	IN   R30,0x37
00393c fde6      	SBRC R30,6
00393d cff7      	RJMP _0x2003D
                 ; 0001 00E6 //dospmw();
                 ; 0001 00E7 }
00393e 940c 3d67 	JMP  _0x2000007
                 ; .FEND
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_EW(void flash *addr)
                 ; 0001 00EA {
                 ___AddrToZByteToSPMCR_SPM_EW:
                 ; .FSTART ___AddrToZByteToSPMCR_SPM_EW
                 ; 0001 00EB     _WAIT_FOR_SPM();
003940 93ba      	ST   -Y,R27
003941 93aa      	ST   -Y,R26
                 ;	*addr -> Y+0
                 _0x20042:
003942 b7e7      	IN   R30,0x37
003943 fde0      	SBRC R30,0
003944 cffd      	RJMP _0x20042
                 ; 0001 00EC     #asm
                 ; 0001 00ED          ldd  r30,y+0
003945 81e8               ldd  r30,y+0
                 ; 0001 00EE          ldd  r31,y+1
003946 81f9               ldd  r31,y+1
                 ; 0001 00EF          //ld   r22,y
                          //ld   r22,y
                 ; 0001 00F0          //WR_SPMCR_REG_R22
                          //WR_SPMCR_REG_R22
                 ; 0001 00F1          //spm
                          //spm
                 ; 0001 00F2     #endasm
                 ; 0001 00F3     #asm
                 ; 0001 00F4         ldi   r22,$03
003947 e063              ldi   r22,$03
                 ; 0001 00F5         WR_SPMCR_REG_R22
003948 bf67              WR_SPMCR_REG_R22
                 ; 0001 00F6         spm
003949 95e8              spm
                 ; 0001 00F7     #endasm
                 ; 0001 00F8     _WAIT_FOR_SPM();
                 _0x20045:
00394a b7e7      	IN   R30,0x37
00394b fde0      	SBRC R30,0
00394c cffd      	RJMP _0x20045
                 ; 0001 00F9     //while( SPMCR_REG & (1<<RWWSB) )
                 ; 0001 00FA     {
                 ; 0001 00FB     #asm
                 ; 0001 00FC         ldi   r22,$11
00394d e161              ldi   r22,$11
                 ; 0001 00FD         WR_SPMCR_REG_R22
00394e bf67              WR_SPMCR_REG_R22
                 ; 0001 00FE         spm
00394f 95e8              spm
                 ; 0001 00FF     #endasm
                 ; 0001 0100         _WAIT_FOR_SPM();
                 _0x20048:
003950 b7e7      	IN   R30,0x37
003951 fde0      	SBRC R30,0
003952 cffd      	RJMP _0x20048
                 ; 0001 0101     }
                 ; 0001 0102 //dospme();
                 ; 0001 0103     #asm
                 ; 0001 0104          ldd  r30,y+0
003953 81e8               ldd  r30,y+0
                 ; 0001 0105          ldd  r31,y+1
003954 81f9               ldd  r31,y+1
                 ; 0001 0106          //ld   r22,y
                          //ld   r22,y
                 ; 0001 0107          //WR_SPMCR_REG_R22
                          //WR_SPMCR_REG_R22
                 ; 0001 0108          //spm
                          //spm
                 ; 0001 0109     #endasm
                 ; 0001 010A     #asm
                 ; 0001 010B         ldi   r22,$05
003955 e065              ldi   r22,$05
                 ; 0001 010C         WR_SPMCR_REG_R22
003956 bf67              WR_SPMCR_REG_R22
                 ; 0001 010D         spm
003957 95e8              spm
                 ; 0001 010E     #endasm
                 ; 0001 010F     _WAIT_FOR_SPM();
                 _0x2004B:
003958 b7e7      	IN   R30,0x37
003959 fde0      	SBRC R30,0
00395a cffd      	RJMP _0x2004B
                 ; 0001 0110     do
                 _0x2004F:
                 ; 0001 0111     {
                 ; 0001 0112     #asm
                 ; 0001 0113         ldi   r22,$11
00395b e161              ldi   r22,$11
                 ; 0001 0114         WR_SPMCR_REG_R22
00395c bf67              WR_SPMCR_REG_R22
                 ; 0001 0115         spm
00395d 95e8              spm
                 ; 0001 0116     #endasm
                 ; 0001 0117         _WAIT_FOR_SPM();
                 _0x20051:
00395e b7e7      	IN   R30,0x37
00395f fde0      	SBRC R30,0
003960 cffd      	RJMP _0x20051
                 ; 0001 0118     }
                 ; 0001 0119     while( SPMCR_REG & (1<<RWWSB) );
003961 b7e7      	IN   R30,0x37
003962 fde6      	SBRC R30,6
003963 cff7      	RJMP _0x2004F
                 ; 0001 011A //dospmw();
                 ; 0001 011B //dospmew();
                 ; 0001 011C }
003964 940c 3d67 	JMP  _0x2000007
                 ; .FEND
                 ;
                 ;
                 ;#ifdef _ATMEGA128
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ;{
                 ;#asm
                 ;     ldd  r30,y+3
                 ;     ldd  r31,y+4
                 ;     ldd  r22,y+5
                 ;     out  rampz,r22
                 ;     ldd  r0,y+1
                 ;     ldd  r1,y+2
                 ;     ld   r22,y
                 ;     WR_SPMCR_REG_R22
                 ;     spm
                 ;#endasm
                 ;}
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ;{
                 ;_WAIT_FOR_SPM();
                 ;#asm
                 ;     ldd  r30,y+2
                 ;     ldd  r31,y+3
                 ;     ldd  r22,y+4
                 ;     out  rampz,r22
                 ;     ldd  r0,y+0
                 ;     ldd  r1,y+1
                 ;     //ld   r22,y
                 ;     //WR_SPMCR_REG_R22
                 ;     //spm
                 ;#endasm
                 ;dospm();
                 ;}
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ;{
                 ;#asm
                 ;     ldd  r30,y+1
                 ;     ldd  r31,y+2
                 ;     ldd  r22,y+3
                 ;     out  rampz,r22
                 ;     ld   r22,y
                 ;     WR_SPMCR_REG_R22
                 ;     spm
                 ;#endasm
                 ;}
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_W(void flash *addr)
                 ;{
                 ;_WAIT_FOR_SPM();
                 ;#asm
                 ;     ldd  r30,y+0
                 ;     ldd  r31,y+1
                 ;     ldd  r22,y+2
                 ;     out  rampz,r22
                 ;     //ld   r22,y
                 ;     //WR_SPMCR_REG_R22
                 ;     //spm
                 ;#endasm
                 ;dospmw();
                 ;}
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_E(void flash *addr)
                 ;{
                 ;_WAIT_FOR_SPM();
                 ;#asm
                 ;     ldd  r30,y+0
                 ;     ldd  r31,y+1
                 ;     ldd  r22,y+2
                 ;     out  rampz,r22
                 ;     //ld   r22,y
                 ;     //WR_SPMCR_REG_R22
                 ;     //spm
                 ;#endasm
                 ;dospme();
                 ;}
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_EW(void flash *addr)
                 ;{
                 ;_WAIT_FOR_SPM();
                 ;#asm
                 ;     ldd  r30,y+0
                 ;     ldd  r31,y+1
                 ;     ldd  r22,y+2
                 ;     out  rampz,r22
                 ;     //ld   r22,y
                 ;     //WR_SPMCR_REG_R22
                 ;     //spm
                 ;#endasm
                 ;dospmew();
                 ;}
                 ;#endif
                 ;
                 ;#ifdef _WARNINGS_ON_
                 ;#pragma warn+
                 ;#endif
                 ;
                 ;/*
                 ;
                 ;Bootloader from SD card for AVR ISD SD project
                 ;Version history:
                 ;0.1: Initial
                 ;0.2: Add Support only FAT32
                 ;0.3: Add Support FAT16 DOS
                 ;0.4: Removed debug points
                 ;
                 ;*/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 out 0x37,r22
                 ;#include "Self_programming.h"
                 ;
                 ;#include "spi_sdcard.h"
                 ;
                 ;#define SDBUF_SIZE  512
                 ;#define PAGES_PER_SDBUF (SDBUF_SIZE/PAGESIZE)
                 ;
                 ;
                 ;
                 ;unsigned char result[5], sdBuf[SDBUF_SIZE], testBuf[PAGESIZE], token, SectorsPerCluster;
                 ;unsigned long appStartAdr,adr,SectorsPerFat,fat_begin_lba;
                 ;unsigned long cluster_begin_lba,fat_file_adr,fat_file_next_adr,filesize,readbytes;
                 ;unsigned int RootEntryCnt, appPages, pagesCnt, bytesChecksum, checksumCnt;
                 ;//(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ;//(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FA ...
                 ;//(unsigned char)sectors_per_cluster = BPB_SecPerClus;
                 ;//(unsigned long)root_dir_first_cluster = BPB_RootClus;
                 ;//void testWrite();
                 ;void errorSD(unsigned char error_step);
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len);
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest);
                 ;void (*app_pointer)(void) = (void(*)(void))0x0000;
                 ;
                 ;enum partition_types{DOS=0,FAT16,FAT32} partition_type;
                 ;
                 ;void main( void ){
                 ; 0002 0027 void main( void ){
                 
                 	.CSEG
                 _main:
                 ; .FSTART _main
                 ; 0002 0028 
                 ; 0002 0029   unsigned int i,j;
                 ; 0002 002A   unsigned char rollNum;
                 ; 0002 002B   //partition_types ;
                 ; 0002 002C 
                 ; 0002 002D   /* initialize the USART control register
                 ; 0002 002E    TX and RX enabled, no interrupts, 8 data bits */
                 ; 0002 002F 
                 ; 0002 0030 #ifdef PRINT_DEBUG
                 ; 0002 0031 UCSR0A=0x00;
                 ; 0002 0032 UCSR0B=0x18;
                 ; 0002 0033 UCSR0C=0x06;
                 ; 0002 0034 
                 ; 0002 0035 //UBRR0H=UBRR >> 8;
                 ; 0002 0036 UBRR0L=UBRR & 0xFF;
                 ; 0002 0037 #else
                 ; 0002 0038 
                 ; 0002 0039 // Analog Comparator: Off
                 ; 0002 003A //ACSR=0x80;
                 ; 0002 003B //setup ADC buttons
                 ; 0002 003C //DIDR0=0x00;
                 ; 0002 003D ADMUX=ADC_VREF_TYPE & 0xff;  //0x20 AREF=reference, Left align=only MSB resd., ch=0
                 ;	i -> R16,R17
                 ;	j -> R18,R19
                 ;	rollNum -> R21
003966 e2e0      	LDI  R30,LOW(32)
003967 93e0 007c 	STS  124,R30
                 ; 0002 003E ADCSRA=0x83;    //  Prescaler=8 (1Mhz), Freerun.
003969 e8e3      	LDI  R30,LOW(131)
00396a 93e0 007a 	STS  122,R30
                 ; 0002 003F //ADCSRB=0x00;    //
                 ; 0002 0040 #endif
                 ; 0002 0041 
                 ; 0002 0042 
                 ; 0002 0043 LED_OK_DDR.PIN_LED_OK=1;
00396c 9a21      	SBI  0x4,1
                 ; 0002 0044 LED_OK_ON();
00396d 9829      	CBI  0x5,1
                 ; 0002 0045 LED_ERR_DDR.PIN_LED_ERR=1;
00396e 9a20      	SBI  0x4,0
                 ; 0002 0046 LED_ERR_OFF();
00396f 9a28      	SBI  0x5,0
                 ; 0002 0047 
                 ; 0002 0048 delay_ms(250);
003970 efaa      	LDI  R26,LOW(250)
003971 e0b0      	LDI  R27,0
003972 940e 3f57 	CALL _delay_ms
                 ; 0002 0049 
                 ; 0002 004A i=0;j=0;
                +
003974 e000     +LDI R16 , LOW ( 0 )
003975 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                +
003976 e020     +LDI R18 , LOW ( 0 )
003977 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 ; 0002 004B 
                 ; 0002 004C //putstr("Start\r");
                 ; 0002 004D #ifndef PRINT_DEBUG
                 ; 0002 004E while(1)
                 _0x4000B:
                 ; 0002 004F {
                 ; 0002 0050     if((TestADCs()==((1<<BUTTON_DOWN)))&&(j>10))
003978 d335      	RCALL _TestADCs
003979 31e0      	CPI  R30,LOW(0x10)
00397a f421      	BRNE _0x4000F
                +
00397b 302b     +CPI R18 , LOW ( 11 )
00397c e0e0     +LDI R30 , HIGH ( 11 )
00397d 073e     +CPC R19 , R30
                 	__CPWRN 18,19,11
00397e f408      	BRSH _0x40010
                 _0x4000F:
00397f c010      	RJMP _0x4000E
                 _0x40010:
                 ; 0002 0051     {
                 ; 0002 0052         LED_OK_OFF();LED_ERR_OFF();
003980 9a29      	SBI  0x5,1
003981 9a28      	SBI  0x5,0
                 ; 0002 0053         if(++j>20 && i==0){
003982 01f9      	MOVW R30,R18
003983 9631      	ADIW R30,1
003984 019f      	MOVW R18,R30
003985 9775      	SBIW R30,21
003986 f020      	BRLO _0x40016
003987 2400      	CLR  R0
003988 1600      	CP   R0,R16
003989 0601      	CPC  R0,R17
00398a f009      	BREQ _0x40017
                 _0x40016:
00398b c001      	RJMP _0x40015
                 _0x40017:
                 ; 0002 0054             break;
00398c c025      	RJMP _0x4000D
                 ; 0002 0055         }
                 ; 0002 0056         i=0;
                 _0x40015:
                +
00398d e000     +LDI R16 , LOW ( 0 )
00398e e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 ; 0002 0057     }
                 ; 0002 0058     else
00398f c01d      	RJMP _0x40018
                 _0x4000E:
                 ; 0002 0059     {
                 ; 0002 005A         if(TestADCs()==((1<<BUTTON_STOP))){
003990 d31d      	RCALL _TestADCs
003991 30e4      	CPI  R30,LOW(0x4)
003992 f461      	BRNE _0x40019
                 ; 0002 005B             LED_OK_TGL(); //toggle OK LED to show initiated STOP button press. Wait for DOWN press
003993 9b29      	SBIS 0x5,1
003994 c002      	RJMP _0x4001A
003995 9829      	CBI  0x5,1
003996 c001      	RJMP _0x4001B
                 _0x4001A:
003997 9a29      	SBI  0x5,1
                 _0x4001B:
                 ; 0002 005C             if(j<11){
                +
003998 302b     +CPI R18 , LOW ( 11 )
003999 e0e0     +LDI R30 , HIGH ( 11 )
00399a 073e     +CPC R19 , R30
                 	__CPWRN 18,19,11
00399b f410      	BRSH _0x4001C
                 ; 0002 005D                 j++;
                +
00399c 5f2f     +SUBI R18 , LOW ( - 1 )
00399d 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                 ; 0002 005E             }
                 ; 0002 005F         }
                 _0x4001C:
                 ; 0002 0060         else{
00399e c00e      	RJMP _0x4001D
                 _0x40019:
                 ; 0002 0061             j=0;
                +
00399f e020     +LDI R18 , LOW ( 0 )
0039a0 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 ; 0002 0062             LED_ERR_TGL();
0039a1 9b28      	SBIS 0x5,0
0039a2 c002      	RJMP _0x4001E
0039a3 9828      	CBI  0x5,0
0039a4 c001      	RJMP _0x4001F
                 _0x4001E:
0039a5 9a28      	SBI  0x5,0
                 _0x4001F:
                 ; 0002 0063             //go to app after 1 sec
                 ; 0002 0064             if(++i>10){
0039a6 01f8      	MOVW R30,R16
0039a7 9631      	ADIW R30,1
0039a8 018f      	MOVW R16,R30
0039a9 973b      	SBIW R30,11
0039aa f010      	BRLO _0x40020
                 ; 0002 0065                 LED_OK_OFF();LED_ERR_OFF();
0039ab 940e 3e21 	CALL SUBOPT_0x1
                 ; 0002 0066                 app_pointer();
                 ; 0002 0067 
                 ; 0002 0068             }
                 ; 0002 0069         }
                 _0x40020:
                 _0x4001D:
                 ; 0002 006A     }
                 _0x40018:
                 ; 0002 006B     delay_ms(100);
0039ad e6a4      	LDI  R26,LOW(100)
0039ae e0b0      	LDI  R27,0
0039af 940e 3f57 	CALL _delay_ms
                 ; 0002 006C     //i++;j++;
                 ; 0002 006D }
0039b1 cfc6      	RJMP _0x4000B
                 _0x4000D:
                 ; 0002 006E #endif
                 ; 0002 006F 
                 ; 0002 0070   if((result[0]=SD_init())!=SD_SUCCESS)
0039b2 940e 3d81 	CALL _SD_init
0039b4 93e0 0320 	STS  _result,R30
0039b6 30e0      	CPI  R30,0
0039b7 f011      	BREQ _0x40025
                 ; 0002 0071   {
                 ; 0002 0072     errorSD(1);
0039b8 e0a1      	LDI  R26,LOW(1)
0039b9 d2b6      	RCALL _errorSD
                 ; 0002 0073   }
                 ; 0002 0074   LED_OK_TGL();
                 _0x40025:
0039ba 9b29      	SBIS 0x5,1
0039bb c002      	RJMP _0x40026
0039bc 9829      	CBI  0x5,1
0039bd c001      	RJMP _0x40027
                 _0x40026:
0039be 9a29      	SBI  0x5,1
                 _0x40027:
                 ; 0002 0075   //putchar('i');
                 ; 0002 0076   // read MBR get FAT start sector
                 ; 0002 0077   if((result[0]=SD_readSingleBlock(0, sdBuf, &token))!=SD_SUCCESS)
0039bf 940e 3e29 	CALL SUBOPT_0x2
0039c1 940e 3e30 	CALL SUBOPT_0x3
0039c3 f011      	BREQ _0x40028
                 ; 0002 0078   {
                 ; 0002 0079     errorSD(2);
0039c4 e0a2      	LDI  R26,LOW(2)
0039c5 d2aa      	RCALL _errorSD
                 ; 0002 007A   }
                 ; 0002 007B   LED_OK_TGL();
                 _0x40028:
0039c6 9b29      	SBIS 0x5,1
0039c7 c002      	RJMP _0x40029
0039c8 9829      	CBI  0x5,1
0039c9 c001      	RJMP _0x4002A
                 _0x40029:
0039ca 9a29      	SBI  0x5,1
                 _0x4002A:
                 ; 0002 007C   //putchar('1');
                 ; 0002 007D   partition_type=FAT32;
0039cb e0e2      	LDI  R30,LOW(2)
0039cc 93e0 05cd 	STS  _partition_type,R30
                 ; 0002 007E   if(sdBuf[0x1C2]<6){
                +
0039ce 91a0 04e7+LDS R26 , _sdBuf + ( 450 )
                 	__GETB2MN _sdBuf,450
0039d0 30a6      	CPI  R26,LOW(0x6)
0039d1 f410      	BRSH _0x4002B
                 ; 0002 007F     partition_type=DOS;
0039d2 e0e0      	LDI  R30,LOW(0)
0039d3 c005      	RJMP _0x400A5
                 ; 0002 0080   }
                 ; 0002 0081   else if(sdBuf[0x1C2]<8){
                 _0x4002B:
                +
0039d4 91a0 04e7+LDS R26 , _sdBuf + ( 450 )
                 	__GETB2MN _sdBuf,450
0039d6 30a8      	CPI  R26,LOW(0x8)
0039d7 f418      	BRSH _0x4002D
                 ; 0002 0082     partition_type=FAT16;
0039d8 e0e1      	LDI  R30,LOW(1)
                 _0x400A5:
0039d9 93e0 05cd 	STS  _partition_type,R30
                 ; 0002 0083   }
                 ; 0002 0084 
                 ; 0002 0085 #ifdef PRINT_DEBUG
                 ; 0002 0086   //printhex("2",partition_type,1);
                 ; 0002 0087 #endif
                 ; 0002 0088   //select algoritm for FAT parse
                 ; 0002 0089   //if((compbuf("MSDOS",&sdBuf[3])==0)||(partition_type==7)||(partition_type==6)||(partition_type==0xE)||(partition_type ...
                 ; 0002 008A   if(partition_type != DOS)
                 _0x4002D:
0039db 91e0 05cd 	LDS  R30,_partition_type
0039dd 30e0      	CPI  R30,0
0039de f0f1      	BREQ _0x4002E
                 ; 0002 008B   {
                 ; 0002 008C     adr=buf2num(&sdBuf[445+9],4);//FAT start sector. 1 sector = 512 bytes
                +
0039df eeeb     +LDI R30 , LOW ( _sdBuf + ( 454 ) )
0039e0 e0f4     +LDI R31 , HIGH ( _sdBuf + ( 454 ) )
                 	__POINTW1MN _sdBuf,454
0039e1 93fa      	ST   -Y,R31
0039e2 93ea      	ST   -Y,R30
0039e3 e0a4      	LDI  R26,LOW(4)
0039e4 d2a0      	RCALL _buf2num
0039e5 940e 3e3b 	CALL SUBOPT_0x4
                 ; 0002 008D 
                 ; 0002 008E     //load and read FAT ID (1st) sector. Get FAT info. Secors per Cluster and etc..
                 ; 0002 008F     if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
0039e7 940e 3e44 	CALL SUBOPT_0x5
0039e9 940e 3e4d 	CALL SUBOPT_0x6
0039eb f011      	BREQ _0x4002F
                 ; 0002 0090     {
                 ; 0002 0091     //putchar('e');//putchar('r');//putchar(result[0]);//putchar(token);
                 ; 0002 0092         errorSD(3);
0039ec e0a3      	LDI  R26,LOW(3)
0039ed d282      	RCALL _errorSD
                 ; 0002 0093     }
                 ; 0002 0094     fat_begin_lba=buf2num(&sdBuf[0x0E],2);//reserved sectors
                 _0x4002F:
0039ee 940e 3e50 	CALL SUBOPT_0x7
0039f0 93e0 05b1 	STS  _fat_begin_lba,R30
0039f2 93f0 05b2 	STS  _fat_begin_lba+1,R31
0039f4 9360 05b3 	STS  _fat_begin_lba+2,R22
0039f6 9370 05b4 	STS  _fat_begin_lba+3,R23
                 ; 0002 0095     fat_begin_lba+=adr;//first sector of FAT data
0039f8 940e 3e44 	CALL SUBOPT_0x5
0039fa 940e 3e56 	CALL SUBOPT_0x8
0039fc c002      	RJMP _0x400A6
                 ; 0002 0096     //printhex("3a",fat_begin_lba,4);
                 ; 0002 0097   }
                 ; 0002 0098   else//DOS parsing
                 _0x4002E:
                 ; 0002 0099   {
                 ; 0002 009A     fat_begin_lba=buf2num(&sdBuf[0x0E],2);//(reserved sectors)first sector of FAT data
0039fd 940e 3e50 	CALL SUBOPT_0x7
                 _0x400A6:
0039ff 93e0 05b1 	STS  _fat_begin_lba,R30
003a01 93f0 05b2 	STS  _fat_begin_lba+1,R31
003a03 9360 05b3 	STS  _fat_begin_lba+2,R22
003a05 9370 05b4 	STS  _fat_begin_lba+3,R23
                 ; 0002 009B     //putchar('2');//putchar('b');
                 ; 0002 009C   }
                 ; 0002 009D 
                 ; 0002 009E   //printhex("3",fat_begin_lba,4);
                 ; 0002 009F 
                 ; 0002 00A0   SectorsPerCluster=sdBuf[0x0D];// 8 sectors per cluster
                +
003a07 9040 0332+LDS R4 , _sdBuf + ( 13 )
                 	__GETBRMN 4,_sdBuf,13
                 ; 0002 00A1   //printhex("SpC",SectorsPerCluster,1);
                 ; 0002 00A2 
                 ; 0002 00A3   //if((partition_type==4)||(partition_type==6)||(partition_type==0xE)) //FAT/12/16
                 ; 0002 00A4   if(partition_type != FAT32)
003a09 91a0 05cd 	LDS  R26,_partition_type
003a0b 30a2      	CPI  R26,LOW(0x2)
003a0c f089      	BREQ _0x40031
                 ; 0002 00A5   {
                 ; 0002 00A6       SectorsPerFat=buf2num(&sdBuf[22],2); // 0xF10 for test sdcard
                +
003a0d e3eb     +LDI R30 , LOW ( _sdBuf + ( 22 ) )
003a0e e0f3     +LDI R31 , HIGH ( _sdBuf + ( 22 ) )
                 	__POINTW1MN _sdBuf,22
003a0f 940e 3e61 	CALL SUBOPT_0x9
003a11 940e 3e65 	CALL SUBOPT_0xA
                 ; 0002 00A7       RootEntryCnt= buf2num(&sdBuf[11],2)>>4;
                +
003a13 e3e0     +LDI R30 , LOW ( _sdBuf + ( 11 ) )
003a14 e0f3     +LDI R31 , HIGH ( _sdBuf + ( 11 ) )
                 	__POINTW1MN _sdBuf,11
003a15 940e 3e61 	CALL SUBOPT_0x9
003a17 01df      	MOVW R26,R30
003a18 01cb      	MOVW R24,R22
003a19 e0e4      	LDI  R30,LOW(4)
003a1a 940e 3f77 	CALL __LSRD12
003a1c 013f      	MOVW R6,R30
                 ; 0002 00A8   }
                 ; 0002 00A9   else{//FAT32
003a1d c00a      	RJMP _0x40032
                 _0x40031:
                 ; 0002 00AA       SectorsPerFat=buf2num(&sdBuf[0x24],4); // 0xF10 for test sdcard
                +
003a1e e4e9     +LDI R30 , LOW ( _sdBuf + ( 36 ) )
003a1f e0f3     +LDI R31 , HIGH ( _sdBuf + ( 36 ) )
                 	__POINTW1MN _sdBuf,36
003a20 93fa      	ST   -Y,R31
003a21 93ea      	ST   -Y,R30
003a22 e0a4      	LDI  R26,LOW(4)
003a23 d261      	RCALL _buf2num
003a24 940e 3e65 	CALL SUBOPT_0xA
                 ; 0002 00AB       RootEntryCnt=0;
003a26 2466      	CLR  R6
003a27 2477      	CLR  R7
                 ; 0002 00AC   }
                 _0x40032:
                 ; 0002 00AD   //printhex("SpF",SectorsPerFat,4);
                 ; 0002 00AE 
                 ; 0002 00AF   //read the FAT fils/directories info from Root Directory cluster (usually 2),Number_of_Reserved_Sectors (usually 0x20) ...
                 ; 0002 00B0   //(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ; 0002 00B1   //fat_begin_lba=adr+0x20;//first sector of FAT data
                 ; 0002 00B2   //(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_ ...
                 ; 0002 00B3   //Number_of_FATs always 2. Offset 0x10 8bit
                 ; 0002 00B4   cluster_begin_lba=fat_begin_lba+(2*SectorsPerFat);//number of sector where data begin
003a28 91e0 05ad 	LDS  R30,_SectorsPerFat
003a2a 91f0 05ae 	LDS  R31,_SectorsPerFat+1
003a2c 9160 05af 	LDS  R22,_SectorsPerFat+2
003a2e 9170 05b0 	LDS  R23,_SectorsPerFat+3
003a30 940e 3f8c 	CALL __LSLD1
003a32 940e 3e56 	CALL SUBOPT_0x8
003a34 93e0 05b5 	STS  _cluster_begin_lba,R30
003a36 93f0 05b6 	STS  _cluster_begin_lba+1,R31
003a38 9360 05b7 	STS  _cluster_begin_lba+2,R22
003a3a 9370 05b8 	STS  _cluster_begin_lba+3,R23
                 ; 0002 00B5   //printhex("cbl",cluster_begin_lba,4);
                 ; 0002 00B6   //read root dir (sector 2 but always offset 2 too then 0) to find folder 0 FAT reference. and find Flash.dat sector
                 ; 0002 00B7   //lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
                 ; 0002 00B8   adr=cluster_begin_lba +(2-2)*SectorsPerCluster;
003a3c 940e 3e3b 	CALL SUBOPT_0x4
                 ; 0002 00B9   //adr*=512UL;
                 ; 0002 00BA   result[1]=0;
003a3e e0e0      	LDI  R30,LOW(0)
                +
003a3f 93e0 0321+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
                 ; 0002 00BB   LED_OK_TGL();
003a41 9b29      	SBIS 0x5,1
003a42 c002      	RJMP _0x40033
003a43 9829      	CBI  0x5,1
003a44 c001      	RJMP _0x40034
                 _0x40033:
003a45 9a29      	SBI  0x5,1
                 _0x40034:
                 ; 0002 00BC   for(i=0;i<SectorsPerCluster;i++)
                +
003a46 e000     +LDI R16 , LOW ( 0 )
003a47 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x40036:
003a48 940e 3e6e 	CALL SUBOPT_0xB
003a4a f580      	BRSH _0x40037
                 ; 0002 00BD   {
                 ; 0002 00BE       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
003a4b 940e 3e74 	CALL SUBOPT_0xC
003a4d f011      	BREQ _0x40038
                 ; 0002 00BF         errorSD(4);
003a4e e0a4      	LDI  R26,LOW(4)
003a4f d220      	RCALL _errorSD
                 ; 0002 00C0       }
                 ; 0002 00C1 #ifdef PRINT_DEBUG
                 ; 0002 00C2       printhex("4",adr,4);
                 ; 0002 00C3 #endif
                 ; 0002 00C4       for(j=0;j<(16);j++)
                 _0x40038:
                +
003a50 e020     +LDI R18 , LOW ( 0 )
003a51 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x4003A:
                +
003a52 3120     +CPI R18 , LOW ( 16 )
003a53 e0e0     +LDI R30 , HIGH ( 16 )
003a54 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
003a55 f440      	BRSH _0x4003B
                 ; 0002 00C5       {
                 ; 0002 00C6            //putchar('5');
                 ; 0002 00C7            if((result[1]=compbuf("0          ",&sdBuf[j*32]))!=0)
                +
003a56 e0e0     +LDI R30 , LOW ( _0x4003D + ( 0 ) )
003a57 e0f3     +LDI R31 , HIGH ( _0x4003D + ( 0 ) )
                 	__POINTW1MN _0x4003D,0
003a58 940e 3e76 	CALL SUBOPT_0xD
003a5a f419      	BRNE _0x4003B
                 ; 0002 00C8            {
                 ; 0002 00C9                 break;
                 ; 0002 00CA            }
                 ; 0002 00CB       }
                +
003a5b 5f2f     +SUBI R18 , LOW ( - 1 )
003a5c 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
003a5d cff4      	RJMP _0x4003A
                 _0x4003B:
                 ; 0002 00CC       //putchar('6');
                 ; 0002 00CD       if(result[1]!=0)
                +
003a5e 91e0 0321+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
003a60 30e0      	CPI  R30,0
003a61 f079      	BREQ _0x4003E
                 ; 0002 00CE       {
                 ; 0002 00CF         //putchar('7');
                 ; 0002 00D0         fat_file_adr =buf2num(&sdBuf[j*32+0x14],2)<<16;
003a62 940e 3e85 	CALL SUBOPT_0xE
                +
003a64 5ce7     +SUBI R30 , LOW ( - _sdBuf - ( 20 ) )
003a65 4ffc     +SBCI R31 , HIGH ( - _sdBuf - ( 20 ) )
                 	__ADDW1MN _sdBuf,20
003a66 940e 3e61 	CALL SUBOPT_0x9
003a68 940e 3e8b 	CALL SUBOPT_0xF
                 ; 0002 00D1         fat_file_adr|=buf2num(&sdBuf[j*32+0x1A],2);
                +
003a6a 5ce1     +SUBI R30 , LOW ( - _sdBuf - ( 26 ) )
003a6b 4ffc     +SBCI R31 , HIGH ( - _sdBuf - ( 26 ) )
                 	__ADDW1MN _sdBuf,26
003a6c 940e 3e61 	CALL SUBOPT_0x9
003a6e 940e 3e96 	CALL SUBOPT_0x10
                 ; 0002 00D2         break;
003a70 c00a      	RJMP _0x40037
                 ; 0002 00D3       }
                 ; 0002 00D4       else
                 _0x4003E:
                 ; 0002 00D5       {
                 ; 0002 00D6         adr++;
003a71 940e 3ea9 	CALL SUBOPT_0x11
                 ; 0002 00D7       }
                 ; 0002 00D8       LED_OK_TGL();
003a73 9b29      	SBIS 0x5,1
003a74 c002      	RJMP _0x40040
003a75 9829      	CBI  0x5,1
003a76 c001      	RJMP _0x40041
                 _0x40040:
003a77 9a29      	SBI  0x5,1
                 _0x40041:
                 ; 0002 00D9   }
                +
003a78 5f0f     +SUBI R16 , LOW ( - 1 )
003a79 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
003a7a cfcd      	RJMP _0x40036
                 _0x40037:
                 ; 0002 00DA   if(result[1]==0)
                +
003a7b 91e0 0321+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
003a7d 30e0      	CPI  R30,0
003a7e f411      	BRNE _0x40042
                 ; 0002 00DB   {
                 ; 0002 00DC       //putchar('f');//putchar('0');
                 ; 0002 00DD       errorSD(5);//folder '0' not found
003a7f e0a5      	LDI  R26,LOW(5)
003a80 d1ef      	RCALL _errorSD
                 ; 0002 00DE   }
                 ; 0002 00DF 
                 ; 0002 00E0   adr=cluster_begin_lba+ RootEntryCnt +(fat_file_adr-2)*SectorsPerCluster;
                 _0x40042:
003a81 940e 3eb4 	CALL SUBOPT_0x12
003a83 937f      	PUSH R23
003a84 936f      	PUSH R22
003a85 93ff      	PUSH R31
003a86 93ef      	PUSH R30
003a87 940e 3ec2 	CALL SUBOPT_0x13
003a89 91af      	POP  R26
003a8a 91bf      	POP  R27
003a8b 918f      	POP  R24
003a8c 919f      	POP  R25
003a8d 940e 3f61 	CALL __ADDD12
003a8f 940e 3e3b 	CALL SUBOPT_0x4
                 ; 0002 00E1   /*
                 ; 0002 00E2   printhex("7",cluster_begin_lba,4);
                 ; 0002 00E3   printhex("7",RootEntryCnt,4);
                 ; 0002 00E4   printhex("7",fat_file_adr,4);
                 ; 0002 00E5   printhex("7",SectorsPerCluster,4);
                 ; 0002 00E6   printhex("7",adr,4);
                 ; 0002 00E7   */
                 ; 0002 00E8 
                 ; 0002 00E9   LED_OK_TGL();
003a91 9b29      	SBIS 0x5,1
003a92 c002      	RJMP _0x40043
003a93 9829      	CBI  0x5,1
003a94 c001      	RJMP _0x40044
                 _0x40043:
003a95 9a29      	SBI  0x5,1
                 _0x40044:
                 ; 0002 00EA   for(i=0;i<SectorsPerCluster;i++)
                +
003a96 e000     +LDI R16 , LOW ( 0 )
003a97 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x40046:
003a98 940e 3e6e 	CALL SUBOPT_0xB
003a9a f008      	BRLO PC+2
003a9b c040      	RJMP _0x40047
                 ; 0002 00EB   {
                 ; 0002 00EC       //putchar('9');
                 ; 0002 00ED #ifdef PRINT_DEBUG
                 ; 0002 00EE       //printhex("8",adr,4);
                 ; 0002 00EF #endif
                 ; 0002 00F0       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
003a9c 940e 3e74 	CALL SUBOPT_0xC
003a9e f011      	BREQ _0x40048
                 ; 0002 00F1       {
                 ; 0002 00F2         errorSD(6);
003a9f e0a6      	LDI  R26,LOW(6)
003aa0 d1cf      	RCALL _errorSD
                 ; 0002 00F3       }
                 ; 0002 00F4       //putchar('A');
                 ; 0002 00F5       for(j=0;j<(16);j++)
                 _0x40048:
                +
003aa1 e020     +LDI R18 , LOW ( 0 )
003aa2 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x4004A:
                +
003aa3 3120     +CPI R18 , LOW ( 16 )
003aa4 e0e0     +LDI R30 , HIGH ( 16 )
003aa5 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
003aa6 f440      	BRSH _0x4004B
                 ; 0002 00F6       {
                 ; 0002 00F7            //putchar('B');
                 ; 0002 00F8            if((result[1]=compbuf("FLASH   ",&sdBuf[j*32]))!=0)
                +
003aa7 e0ec     +LDI R30 , LOW ( _0x4003D + ( 12 ) )
003aa8 e0f3     +LDI R31 , HIGH ( _0x4003D + ( 12 ) )
                 	__POINTW1MN _0x4003D,12
003aa9 940e 3e76 	CALL SUBOPT_0xD
003aab f419      	BRNE _0x4004B
                 ; 0002 00F9            {
                 ; 0002 00FA                 //putchar('C');
                 ; 0002 00FB                 break;
                 ; 0002 00FC            }
                 ; 0002 00FD       }
                +
003aac 5f2f     +SUBI R18 , LOW ( - 1 )
003aad 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
003aae cff4      	RJMP _0x4004A
                 _0x4004B:
                 ; 0002 00FE       if(result[1]!=0)
                +
003aaf 91e0 0321+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
003ab1 30e0      	CPI  R30,0
003ab2 f0f9      	BREQ _0x4004D
                 ; 0002 00FF       {
                 ; 0002 0100         //putchar('D');
                 ; 0002 0101         //read 1st number of cluster where data placed
                 ; 0002 0102         fat_file_adr =buf2num(&sdBuf[j*32+0x14],2)<<16;
003ab3 940e 3e85 	CALL SUBOPT_0xE
                +
003ab5 5ce7     +SUBI R30 , LOW ( - _sdBuf - ( 20 ) )
003ab6 4ffc     +SBCI R31 , HIGH ( - _sdBuf - ( 20 ) )
                 	__ADDW1MN _sdBuf,20
003ab7 940e 3e61 	CALL SUBOPT_0x9
003ab9 940e 3e8b 	CALL SUBOPT_0xF
                 ; 0002 0103         fat_file_adr|=buf2num(&sdBuf[j*32+0x1A],2);
                +
003abb 5ce1     +SUBI R30 , LOW ( - _sdBuf - ( 26 ) )
003abc 4ffc     +SBCI R31 , HIGH ( - _sdBuf - ( 26 ) )
                 	__ADDW1MN _sdBuf,26
003abd 940e 3e61 	CALL SUBOPT_0x9
003abf 940e 3e96 	CALL SUBOPT_0x10
                 ; 0002 0104         filesize = buf2num(&sdBuf[j*32+0x1C],8);
003ac1 940e 3e85 	CALL SUBOPT_0xE
                +
003ac3 5bef     +SUBI R30 , LOW ( - _sdBuf - ( 28 ) )
003ac4 4ffc     +SBCI R31 , HIGH ( - _sdBuf - ( 28 ) )
                 	__ADDW1MN _sdBuf,28
003ac5 93fa      	ST   -Y,R31
003ac6 93ea      	ST   -Y,R30
003ac7 e0a8      	LDI  R26,LOW(8)
003ac8 d1bc      	RCALL _buf2num
003ac9 93e0 05c1 	STS  _filesize,R30
003acb 93f0 05c2 	STS  _filesize+1,R31
003acd 9360 05c3 	STS  _filesize+2,R22
003acf 9370 05c4 	STS  _filesize+3,R23
                 ; 0002 0105         break;
003ad1 c00a      	RJMP _0x40047
                 ; 0002 0106       }
                 ; 0002 0107       else
                 _0x4004D:
                 ; 0002 0108       {
                 ; 0002 0109         adr++;
003ad2 940e 3ea9 	CALL SUBOPT_0x11
                 ; 0002 010A       }
                 ; 0002 010B       LED_OK_TGL();
003ad4 9b29      	SBIS 0x5,1
003ad5 c002      	RJMP _0x4004F
003ad6 9829      	CBI  0x5,1
003ad7 c001      	RJMP _0x40050
                 _0x4004F:
003ad8 9a29      	SBI  0x5,1
                 _0x40050:
                 ; 0002 010C   }
                +
003ad9 5f0f     +SUBI R16 , LOW ( - 1 )
003ada 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
003adb cfbc      	RJMP _0x40046
                 _0x40047:
                 ; 0002 010D 
                 ; 0002 010E   if(result[1]==0)
                +
003adc 91e0 0321+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
003ade 30e0      	CPI  R30,0
003adf f411      	BRNE _0x40051
                 ; 0002 010F   {
                 ; 0002 0110       //putchar('f');//putchar('0');
                 ; 0002 0111       errorSD(16);//folder '0' not found
003ae0 e1a0      	LDI  R26,LOW(16)
003ae1 d18e      	RCALL _errorSD
                 ; 0002 0112   }
                 ; 0002 0113 
                 ; 0002 0114   //check FAT for chain of clusters to read
                 ; 0002 0115   readbytes=0;
                 _0x40051:
003ae2 e0e0      	LDI  R30,LOW(0)
003ae3 93e0 05c5 	STS  _readbytes,R30
003ae5 93e0 05c6 	STS  _readbytes+1,R30
003ae7 93e0 05c7 	STS  _readbytes+2,R30
003ae9 93e0 05c8 	STS  _readbytes+3,R30
                 ; 0002 0116   while((fat_file_adr != 0x0FFFFFFFUL) && (fat_file_adr != 0xFFFF))
                 _0x40052:
003aeb 940e 3ed7 	CALL SUBOPT_0x14
003aed 940e 3ee0 	CALL SUBOPT_0x15
003aef f029      	BREQ _0x40055
003af0 940e 3ed7 	CALL SUBOPT_0x14
003af2 940e 3ee8 	CALL SUBOPT_0x16
003af4 f409      	BRNE _0x40056
                 _0x40055:
003af5 c162      	RJMP _0x40054
                 _0x40056:
                 ; 0002 0117   {
                 ; 0002 0118     //read where next cluster from FAT, check that not EOF
                 ; 0002 0119 #ifdef PRINT_DEBUG
                 ; 0002 011A     //printhex("7a",fat_file_adr,4);
                 ; 0002 011B     //printhex("7b",fat_begin_lba,4);
                 ; 0002 011C #endif
                 ; 0002 011D     if((result[0]=SD_readSingleBlock(fat_begin_lba+(fat_file_adr>>8), sdBuf, &token))!=SD_SUCCESS){
003af6 940e 3ed7 	CALL SUBOPT_0x14
003af8 e0e8      	LDI  R30,LOW(8)
003af9 940e 3f77 	CALL __LSRD12
003afb 940e 3e56 	CALL SUBOPT_0x8
003afd 940e 3e4d 	CALL SUBOPT_0x6
003aff f011      	BREQ _0x40057
                 ; 0002 011E         errorSD(7);
003b00 e0a7      	LDI  R26,LOW(7)
003b01 d16e      	RCALL _errorSD
                 ; 0002 011F     }
                 ; 0002 0120     if(partition_type!=FAT32){ //FAT/12/16
                 _0x40057:
003b02 91a0 05cd 	LDS  R26,_partition_type
003b04 30a2      	CPI  R26,LOW(0x2)
003b05 f069      	BREQ _0x40058
                 ; 0002 0121         fat_file_next_adr=buf2num(&sdBuf[(fat_file_adr<<1)%0x200],2);
003b06 91e0 05b9 	LDS  R30,_fat_file_adr
003b08 91f0 05ba 	LDS  R31,_fat_file_adr+1
003b0a 0fee      	LSL  R30
003b0b 1fff      	ROL  R31
003b0c 70f1      	ANDI R31,HIGH(0x1FF)
003b0d 5deb      	SUBI R30,LOW(-_sdBuf)
003b0e 4ffc      	SBCI R31,HIGH(-_sdBuf)
003b0f 93fa      	ST   -Y,R31
003b10 93ea      	ST   -Y,R30
003b11 e0a2      	LDI  R26,LOW(2)
003b12 c00c      	RJMP _0x400A7
                 ; 0002 0122     }
                 ; 0002 0123     else{//FAT32
                 _0x40058:
                 ; 0002 0124         fat_file_next_adr=buf2num(&sdBuf[(fat_file_adr<<2)%0x200],4);
003b13 91e0 05b9 	LDS  R30,_fat_file_adr
003b15 91f0 05ba 	LDS  R31,_fat_file_adr+1
003b17 940e 3f87 	CALL __LSLW2
003b19 70f1      	ANDI R31,HIGH(0x1FF)
003b1a 5deb      	SUBI R30,LOW(-_sdBuf)
003b1b 4ffc      	SBCI R31,HIGH(-_sdBuf)
003b1c 93fa      	ST   -Y,R31
003b1d 93ea      	ST   -Y,R30
003b1e e0a4      	LDI  R26,LOW(4)
                 _0x400A7:
003b1f d165      	RCALL _buf2num
003b20 93e0 05bd 	STS  _fat_file_next_adr,R30
003b22 93f0 05be 	STS  _fat_file_next_adr+1,R31
003b24 9360 05bf 	STS  _fat_file_next_adr+2,R22
003b26 9370 05c0 	STS  _fat_file_next_adr+3,R23
                 ; 0002 0125     }
                 ; 0002 0126 #ifdef PRINT_DEBUG
                 ; 0002 0127     //printhex("7c",fat_file_next_adr,4);
                 ; 0002 0128 #endif
                 ; 0002 0129     //putchar('E');
                 ; 0002 012A     adr=cluster_begin_lba+ RootEntryCnt +(fat_file_adr-2)*SectorsPerCluster;
003b28 940e 3eb4 	CALL SUBOPT_0x12
003b2a 937f      	PUSH R23
003b2b 936f      	PUSH R22
003b2c 93ff      	PUSH R31
003b2d 93ef      	PUSH R30
003b2e 940e 3ec2 	CALL SUBOPT_0x13
003b30 91af      	POP  R26
003b31 91bf      	POP  R27
003b32 918f      	POP  R24
003b33 919f      	POP  R25
003b34 940e 3f61 	CALL __ADDD12
003b36 d304      	RCALL SUBOPT_0x4
                 ; 0002 012B     for(i=0;i<SectorsPerCluster;i++)
                +
003b37 e000     +LDI R16 , LOW ( 0 )
003b38 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x4005B:
003b39 d334      	RCALL SUBOPT_0xB
003b3a f008      	BRLO PC+2
003b3b c10b      	RJMP _0x4005C
                 ; 0002 012C     {
                 ; 0002 012D         //read data from next sector of file cluster
                 ; 0002 012E #ifdef PRINT_DEBUG
                 ; 0002 012F         //printhex("8",adr,4);
                 ; 0002 0130 #endif
                 ; 0002 0131         if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
003b3c d337      	RCALL SUBOPT_0xC
003b3d f011      	BREQ _0x4005D
                 ; 0002 0132             errorSD(8);
003b3e e0a8      	LDI  R26,LOW(8)
003b3f d130      	RCALL _errorSD
                 ; 0002 0133         }
                 ; 0002 0134         //putchar('F');
                 ; 0002 0135         //address 2000 = start adr flash app 3 bytes, flash pages 2 bytes, checksum 2 bytes
                 ; 0002 0136         //app bytes starts from 2048, roll 0x88
                 ; 0002 0137         if(readbytes==0)
                 _0x4005D:
003b40 940e 3ef0 	CALL SUBOPT_0x17
003b42 940e 3fde 	CALL __CPD10
003b44 f529      	BRNE _0x4005E
                 ; 0002 0138         {
                 ; 0002 0139             for(rollNum=1;rollNum!=0;rollNum++)
003b45 e051      	LDI  R21,LOW(1)
                 _0x40060:
003b46 3050      	CPI  R21,0
003b47 f0f1      	BREQ _0x40061
                 ; 0002 013A             {
                 ; 0002 013B                 for(j=0;j<10;j++)
                +
003b48 e020     +LDI R18 , LOW ( 0 )
003b49 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40063:
                +
003b4a 302a     +CPI R18 , LOW ( 10 )
003b4b e0e0     +LDI R30 , HIGH ( 10 )
003b4c 073e     +CPC R19 , R30
                 	__CPWRN 18,19,10
003b4d f468      	BRSH _0x40064
                 ; 0002 013C                 {
                 ; 0002 013D                     testBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
003b4e 01f9      	MOVW R30,R18
003b4f 5deb      	SUBI R30,LOW(-_testBuf)
003b50 4ffa      	SBCI R31,HIGH(-_testBuf)
003b51 940e 3ef9 	CALL SUBOPT_0x18
                 ; 0002 013E                     testBuf[j]^=rollNum;//0x88;  //XOR
003b53 5dab      	SUBI R26,LOW(-_testBuf)
003b54 4fba      	SBCI R27,HIGH(-_testBuf)
003b55 91ec      	LD   R30,X
003b56 27e5      	EOR  R30,R21
003b57 93ec      	ST   X,R30
                 ; 0002 013F                 }
                +
003b58 5f2f     +SUBI R18 , LOW ( - 1 )
003b59 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
003b5a cfef      	RJMP _0x40063
                 _0x40064:
                 ; 0002 0140                 if(compbuf("[settings]",testBuf))
                +
003b5b e1e5     +LDI R30 , LOW ( _0x4003D + ( 21 ) )
003b5c e0f3     +LDI R31 , HIGH ( _0x4003D + ( 21 ) )
                 	__POINTW1MN _0x4003D,21
003b5d 93fa      	ST   -Y,R31
003b5e 93ea      	ST   -Y,R30
003b5f e2a5      	LDI  R26,LOW(_testBuf)
003b60 e0b5      	LDI  R27,HIGH(_testBuf)
003b61 d0f8      	RCALL _compbuf
003b62 30e0      	CPI  R30,0
003b63 f411      	BRNE _0x40061
                 ; 0002 0141                 {
                 ; 0002 0142                     //printhex("rol=",rollNum,1);
                 ; 0002 0143                     break;
                 ; 0002 0144                 }
                 ; 0002 0145             }
003b64 5f5f      	SUBI R21,-1
003b65 cfe0      	RJMP _0x40060
                 _0x40061:
                 ; 0002 0146             if(rollNum==0){
003b66 3050      	CPI  R21,0
003b67 f411      	BRNE _0x40066
                 ; 0002 0147                  errorSD(9);
003b68 e0a9      	LDI  R26,LOW(9)
003b69 d106      	RCALL _errorSD
                 ; 0002 0148             }
                 ; 0002 0149         }
                 _0x40066:
                 ; 0002 014A         for(j=0;j<512;j++)
                 _0x4005E:
                +
003b6a e020     +LDI R18 , LOW ( 0 )
003b6b e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40068:
                +
003b6c 3020     +CPI R18 , LOW ( 512 )
003b6d e0e2     +LDI R30 , HIGH ( 512 )
003b6e 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
003b6f f4e8      	BRSH _0x40069
                 ; 0002 014B         {
                 ; 0002 014C             sdBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
003b70 01f9      	MOVW R30,R18
003b71 5deb      	SUBI R30,LOW(-_sdBuf)
003b72 4ffc      	SBCI R31,HIGH(-_sdBuf)
003b73 940e 3ef9 	CALL SUBOPT_0x18
                 ; 0002 014D             sdBuf[j]^=rollNum;//0x88;  //XOR
003b75 5dab      	SUBI R26,LOW(-_sdBuf)
003b76 4fbc      	SBCI R27,HIGH(-_sdBuf)
003b77 91ec      	LD   R30,X
003b78 27e5      	EOR  R30,R21
003b79 93ec      	ST   X,R30
                 ; 0002 014E             checksumCnt+=sdBuf[j];
003b7a e2a5      	LDI  R26,LOW(_sdBuf)
003b7b e0b3      	LDI  R27,HIGH(_sdBuf)
003b7c 0fa2      	ADD  R26,R18
003b7d 1fb3      	ADC  R27,R19
003b7e 91ec      	LD   R30,X
003b7f e0f0      	LDI  R31,0
003b80 91a0 05c9 	LDS  R26,_checksumCnt
003b82 91b0 05ca 	LDS  R27,_checksumCnt+1
003b84 0fea      	ADD  R30,R26
003b85 1ffb      	ADC  R31,R27
003b86 93e0 05c9 	STS  _checksumCnt,R30
003b88 93f0 05ca 	STS  _checksumCnt+1,R31
                 ; 0002 014F             //if(readbytes>2000)
                 ; 0002 0150                 ////putchar(sdBuf[j]);
                 ; 0002 0151         }
                +
003b8a 5f2f     +SUBI R18 , LOW ( - 1 )
003b8b 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
003b8c cfdf      	RJMP _0x40068
                 _0x40069:
                 ; 0002 0152         readbytes+=512;
003b8d 940e 3ef0 	CALL SUBOPT_0x17
                +
003b8f 50e0     +SUBI R30 , LOW ( - 512 )
003b90 4ffe     +SBCI R31 , HIGH ( - 512 )
003b91 4f6f     +SBCI R22 , BYTE3 ( - 512 )
003b92 4f7f     +SBCI R23 , BYTE4 ( - 512 )
                 	__ADDD1N 512
003b93 93e0 05c5 	STS  _readbytes,R30
003b95 93f0 05c6 	STS  _readbytes+1,R31
003b97 9360 05c7 	STS  _readbytes+2,R22
003b99 9370 05c8 	STS  _readbytes+3,R23
                 ; 0002 0153         //read app data
                 ; 0002 0154         if(readbytes>2048)
003b9b 940e 3f0e 	CALL SUBOPT_0x19
                +
003b9d 30a1     +CPI R26 , LOW ( 0x801 )
003b9e e0e8     +LDI R30 , HIGH ( 0x801 )
003b9f 07be     +CPC R27 , R30
003ba0 e0e0     +LDI R30 , BYTE3 ( 0x801 )
003ba1 078e     +CPC R24 , R30
003ba2 e0e0     +LDI R30 , BYTE4 ( 0x801 )
003ba3 079e     +CPC R25 , R30
                 	__CPD2N 0x801
003ba4 f1d0      	BRLO _0x4006A
                 ; 0002 0155         {
                 ; 0002 0156            for(pagesCnt=0;pagesCnt<PAGES_PER_SDBUF;pagesCnt++)
003ba5 24aa      	CLR  R10
003ba6 24bb      	CLR  R11
                 _0x4006C:
003ba7 e0e4      	LDI  R30,LOW(4)
003ba8 e0f0      	LDI  R31,HIGH(4)
003ba9 16ae      	CP   R10,R30
003baa 06bf      	CPC  R11,R31
003bab f590      	BRSH _0x4006D
                 ; 0002 0157            {
                 ; 0002 0158                LED_OK_TGL();
003bac 9b29      	SBIS 0x5,1
003bad c002      	RJMP _0x4006E
003bae 9829      	CBI  0x5,1
003baf c001      	RJMP _0x4006F
                 _0x4006E:
003bb0 9a29      	SBI  0x5,1
                 _0x4006F:
                 ; 0002 0159                if(WriteFlashPage(appStartAdr, &sdBuf[pagesCnt*(int)PAGESIZE])==0)
003bb1 91e0 05a5 	LDS  R30,_appStartAdr
003bb3 91f0 05a6 	LDS  R31,_appStartAdr+1
003bb5 93fa      	ST   -Y,R31
003bb6 93ea      	ST   -Y,R30
003bb7 01f5      	MOVW R30,R10
003bb8 940e 3f85 	CALL __LSLW3
003bba 940e 3f83 	CALL __LSLW4
003bbc 5deb      	SUBI R30,LOW(-_sdBuf)
003bbd 4ffc      	SBCI R31,HIGH(-_sdBuf)
003bbe 01df      	MOVW R26,R30
003bbf 940e 387e 	CALL _WriteFlashPage
003bc1 30e0      	CPI  R30,0
003bc2 f411      	BRNE _0x40070
                 ; 0002 015A                {
                 ; 0002 015B                     errorSD(10);
003bc3 e0aa      	LDI  R26,LOW(10)
003bc4 d0ab      	RCALL _errorSD
                 ; 0002 015C                }
                 ; 0002 015D                appStartAdr+=PAGESIZE;
                 _0x40070:
003bc5 91e0 05a5 	LDS  R30,_appStartAdr
003bc7 91f0 05a6 	LDS  R31,_appStartAdr+1
003bc9 9160 05a7 	LDS  R22,_appStartAdr+2
003bcb 9170 05a8 	LDS  R23,_appStartAdr+3
                +
003bcd 58e0     +SUBI R30 , LOW ( - 128 )
003bce 4fff     +SBCI R31 , HIGH ( - 128 )
003bcf 4f6f     +SBCI R22 , BYTE3 ( - 128 )
003bd0 4f7f     +SBCI R23 , BYTE4 ( - 128 )
                 	__ADDD1N 128
003bd1 940e 3f17 	CALL SUBOPT_0x1A
                 ; 0002 015E                appPages--;
003bd3 01f4      	MOVW R30,R8
003bd4 9731      	SBIW R30,1
003bd5 014f      	MOVW R8,R30
                 ; 0002 015F                if(appPages==0)
003bd6 2c08      	MOV  R0,R8
003bd7 2809      	OR   R0,R9
003bd8 f409      	BRNE _0x40071
                 ; 0002 0160                {
                 ; 0002 0161                     LED_OK_OFF();LED_ERR_OFF();
003bd9 d247      	RCALL SUBOPT_0x1
                 ; 0002 0162                     //putchar('P');putchar('\r');
                 ; 0002 0163                     app_pointer();
                 ; 0002 0164                }
                 ; 0002 0165            }
                 _0x40071:
003bda 01f5      	MOVW R30,R10
003bdb 9631      	ADIW R30,1
003bdc 015f      	MOVW R10,R30
003bdd cfc9      	RJMP _0x4006C
                 _0x4006D:
                 ; 0002 0166         }
                 ; 0002 0167         //read app start adr, num of pages, checksum
                 ; 0002 0168         else if(readbytes>=2000)//Offset=512-48=464
003bde c04a      	RJMP _0x40076
                 _0x4006A:
003bdf d32e      	RCALL SUBOPT_0x19
                +
003be0 3da0     +CPI R26 , LOW ( 0x7D0 )
003be1 e0e7     +LDI R30 , HIGH ( 0x7D0 )
003be2 07be     +CPC R27 , R30
003be3 e0e0     +LDI R30 , BYTE3 ( 0x7D0 )
003be4 078e     +CPC R24 , R30
003be5 e0e0     +LDI R30 , BYTE4 ( 0x7D0 )
003be6 079e     +CPC R25 , R30
                 	__CPD2N 0x7D0
003be7 f408      	BRSH PC+2
003be8 c040      	RJMP _0x40077
                 ; 0002 0169         {
                 ; 0002 016A            if(PAGESIZE!=((((unsigned int)sdBuf[478]<<8)|((unsigned int)sdBuf[479]))<<1))
                +
003be9 91b0 0503+LDS R27 , _sdBuf + ( 478 )
                 	__GETBRMN 27,_sdBuf,478
003beb e0a0      	LDI  R26,LOW(0)
                +
003bec 91e0 0504+LDS R30 , _sdBuf + ( 479 )
                 	__GETB1MN _sdBuf,479
003bee e0f0      	LDI  R31,0
003bef 2bea      	OR   R30,R26
003bf0 2bfb      	OR   R31,R27
003bf1 0fee      	LSL  R30
003bf2 1fff      	ROL  R31
003bf3 38e0      	CPI  R30,LOW(0x80)
003bf4 e0a0      	LDI  R26,HIGH(0x80)
003bf5 07fa      	CPC  R31,R26
003bf6 f011      	BREQ _0x40078
                 ; 0002 016B            {
                 ; 0002 016C                errorSD(11);
003bf7 e0ab      	LDI  R26,LOW(11)
003bf8 d077      	RCALL _errorSD
                 ; 0002 016D            }
                 ; 0002 016E            appStartAdr=(unsigned long)sdBuf[464]<<16;
                 _0x40078:
                +
003bf9 91e0 04f5+LDS R30 , _sdBuf + ( 464 )
                 	__GETB1MN _sdBuf,464
003bfb e0f0      	LDI  R31,0
003bfc 940e 3f9b 	CALL __CWD1
003bfe 940e 3f96 	CALL __LSLD16
003c00 d316      	RCALL SUBOPT_0x1A
                 ; 0002 016F            appStartAdr|=(unsigned long)sdBuf[465]<<8;
                +
003c01 91e0 04f6+LDS R30 , _sdBuf + ( 465 )
                 	__GETB1MN _sdBuf,465
003c03 e0f0      	LDI  R31,0
003c04 940e 3f9b 	CALL __CWD1
003c06 01df      	MOVW R26,R30
003c07 01cb      	MOVW R24,R22
003c08 e0e8      	LDI  R30,LOW(8)
003c09 940e 3f6b 	CALL __LSLD12
003c0b d314      	RCALL SUBOPT_0x1B
                 ; 0002 0170            appStartAdr|=(unsigned long)sdBuf[466];
                +
003c0c 91e0 04f7+LDS R30 , _sdBuf + ( 466 )
                 	__GETB1MN _sdBuf,466
003c0e e0f0      	LDI  R31,0
003c0f 940e 3f9b 	CALL __CWD1
003c11 d30e      	RCALL SUBOPT_0x1B
                 ; 0002 0171            appPages=(unsigned int)sdBuf[467]<<8;
                +
003c12 91f0 04f8+LDS R31 , _sdBuf + ( 467 )
                 	__GETBRMN 31,_sdBuf,467
003c14 e0e0      	LDI  R30,LOW(0)
003c15 014f      	MOVW R8,R30
                 ; 0002 0172            appPages|=(unsigned int)sdBuf[468];
                +
003c16 91e0 04f9+LDS R30 , _sdBuf + ( 468 )
                 	__GETB1MN _sdBuf,468
003c18 e0f0      	LDI  R31,0
                +
003c19 2a8e     +OR R8 , R30
003c1a 2a9f     +OR R9 , R31
                 	__ORWRR 8,9,30,31
                 ; 0002 0173            bytesChecksum=(unsigned int)sdBuf[469]<<8;
                +
003c1b 91f0 04fa+LDS R31 , _sdBuf + ( 469 )
                 	__GETBRMN 31,_sdBuf,469
003c1d e0e0      	LDI  R30,LOW(0)
003c1e 016f      	MOVW R12,R30
                 ; 0002 0174            bytesChecksum|=(unsigned int)sdBuf[470];
                +
003c1f 91e0 04fb+LDS R30 , _sdBuf + ( 470 )
                 	__GETB1MN _sdBuf,470
003c21 e0f0      	LDI  R31,0
                +
003c22 2ace     +OR R12 , R30
003c23 2adf     +OR R13 , R31
                 	__ORWRR 12,13,30,31
                 ; 0002 0175            checksumCnt=0;
003c24 e0e0      	LDI  R30,LOW(0)
003c25 93e0 05c9 	STS  _checksumCnt,R30
003c27 93e0 05ca 	STS  _checksumCnt+1,R30
                 ; 0002 0176            //putchar('a');//putchar('d');//putchar('r');//putchar(sdBuf[464]);//putchar(sdBuf[465]);//putchar(sdBuf[466] ...
                 ; 0002 0177         }
                 ; 0002 0178         if((fat_file_next_adr == 0x0FFFFFFFUL) || (fat_file_next_adr == 0xFFFF)){
                 _0x40077:
                 _0x40076:
003c29 d301      	RCALL SUBOPT_0x1C
003c2a d2b5      	RCALL SUBOPT_0x15
003c2b f019      	BREQ _0x4007A
003c2c d2fe      	RCALL SUBOPT_0x1C
003c2d d2ba      	RCALL SUBOPT_0x16
003c2e f4a1      	BRNE _0x40079
                 _0x4007A:
                 ; 0002 0179             if(readbytes >= filesize)
003c2f 91e0 05c1 	LDS  R30,_filesize
003c31 91f0 05c2 	LDS  R31,_filesize+1
003c33 9160 05c3 	LDS  R22,_filesize+2
003c35 9170 05c4 	LDS  R23,_filesize+3
003c37 d2d6      	RCALL SUBOPT_0x19
003c38 940e 3fe2 	CALL __CPD21
003c3a f460      	BRSH _0x4005C
                 ; 0002 017A             {
                 ; 0002 017B                 break;
                 ; 0002 017C             }
                 ; 0002 017D             else if(i>=(SectorsPerCluster-1))
003c3b 2de4      	MOV  R30,R4
003c3c e0f0      	LDI  R31,0
003c3d 9731      	SBIW R30,1
003c3e 170e      	CP   R16,R30
003c3f 071f      	CPC  R17,R31
003c40 f010      	BRLO _0x4007E
                 ; 0002 017E             {
                 ; 0002 017F                 //printhex("12a",readbytes,4);
                 ; 0002 0180                 //printhex("12b",filesize,4);
                 ; 0002 0181                 errorSD(12);
003c41 e0ac      	LDI  R26,LOW(12)
003c42 d02d      	RCALL _errorSD
                 ; 0002 0182             }
                 ; 0002 0183         }
                 _0x4007E:
                 ; 0002 0184         adr++;
                 _0x40079:
003c43 d265      	RCALL SUBOPT_0x11
                 ; 0002 0185     }
                +
003c44 5f0f     +SUBI R16 , LOW ( - 1 )
003c45 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
003c46 cef2      	RJMP _0x4005B
                 _0x4005C:
                 ; 0002 0186     fat_file_adr = fat_file_next_adr;
003c47 91e0 05bd 	LDS  R30,_fat_file_next_adr
003c49 91f0 05be 	LDS  R31,_fat_file_next_adr+1
003c4b 9160 05bf 	LDS  R22,_fat_file_next_adr+2
003c4d 9170 05c0 	LDS  R23,_fat_file_next_adr+3
003c4f 93e0 05b9 	STS  _fat_file_adr,R30
003c51 93f0 05ba 	STS  _fat_file_adr+1,R31
003c53 9360 05bb 	STS  _fat_file_adr+2,R22
003c55 9370 05bc 	STS  _fat_file_adr+3,R23
                 ; 0002 0187   }
003c57 ce93      	RJMP _0x40052
                 _0x40054:
                 ; 0002 0188   while(1);
                 _0x4007F:
003c58 cfff      	RJMP _0x4007F
                 ; 0002 0189 }
                 _0x40082:
003c59 cfff      	RJMP _0x40082
                 ; .FEND
                 
                 	.DSEG
                 _0x4003D:
000300           	.BYTE 0x20
                 ;
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest)
                 ; 0002 018C {
                 
                 	.CSEG
                 _compbuf:
                 ; .FSTART _compbuf
                 ; 0002 018D     while(*src)
003c5a 93ba      	ST   -Y,R27
003c5b 93aa      	ST   -Y,R26
                 ;	*src -> Y+2
                 ;	*dest -> Y+0
                 _0x40083:
003c5c 81aa      	LDD  R26,Y+2
003c5d 81bb      	LDD  R27,Y+2+1
003c5e 91ec      	LD   R30,X
003c5f 30e0      	CPI  R30,0
003c60 f069      	BREQ _0x40085
                 ; 0002 018E     {
                 ; 0002 018F         if(*src++ != *dest++)
003c61 900d      	LD   R0,X+
003c62 83aa      	STD  Y+2,R26
003c63 83bb      	STD  Y+2+1,R27
003c64 81a8      	LD   R26,Y
003c65 81b9      	LDD  R27,Y+1
003c66 91ed      	LD   R30,X+
003c67 83a8      	ST   Y,R26
003c68 83b9      	STD  Y+1,R27
003c69 15e0      	CP   R30,R0
003c6a f011      	BREQ _0x40086
                 ; 0002 0190             return 0;
003c6b e0e0      	LDI  R30,LOW(0)
003c6c c0bf      	RJMP _0x2000008
                 ; 0002 0191         //src++;dest++;
                 ; 0002 0192         //len--;
                 ; 0002 0193     }
                 _0x40086:
003c6d cfee      	RJMP _0x40083
                 _0x40085:
                 ; 0002 0194     return 1;
003c6e e0e1      	LDI  R30,LOW(1)
003c6f c0bc      	RJMP _0x2000008
                 ; 0002 0195 }
                 ; .FEND
                 ;
                 ;void errorSD(unsigned char error_step)
                 ; 0002 0198 {
                 _errorSD:
                 ; .FSTART _errorSD
                 ; 0002 0199     unsigned char i;
                 ; 0002 019A #ifdef PRINT_DEBUG
                 ; 0002 019B     printhex("err:",error_step,1);
                 ; 0002 019C #endif
                 ; 0002 019D     PORTC.1=0;
003c70 93aa      	ST   -Y,R26
003c71 931a      	ST   -Y,R17
                 ;	error_step -> Y+1
                 ;	i -> R17
003c72 9841      	CBI  0x8,1
                 ; 0002 019E     LED_OK_OFF();
003c73 9a29      	SBI  0x5,1
                 ; 0002 019F     for(i=0;i<error_step;i++){
003c74 e010      	LDI  R17,LOW(0)
                 _0x4008C:
003c75 81e9      	LDD  R30,Y+1
003c76 171e      	CP   R17,R30
003c77 f460      	BRSH _0x4008D
                 ; 0002 01A0         LED_ERR_OFF();
003c78 9a28      	SBI  0x5,0
                 ; 0002 01A1         delay_ms(300);
003c79 e2ac      	LDI  R26,LOW(300)
003c7a e0b1      	LDI  R27,HIGH(300)
003c7b 940e 3f57 	CALL _delay_ms
                 ; 0002 01A2         LED_ERR_ON();
003c7d 9828      	CBI  0x5,0
                 ; 0002 01A3         delay_ms(300);
003c7e e2ac      	LDI  R26,LOW(300)
003c7f e0b1      	LDI  R27,HIGH(300)
003c80 940e 3f57 	CALL _delay_ms
                 ; 0002 01A4     }
003c82 5f1f      	SUBI R17,-1
003c83 cff1      	RJMP _0x4008C
                 _0x4008D:
                 ; 0002 01A5 
                 ; 0002 01A6     while(1);
                 _0x40092:
003c84 cfff      	RJMP _0x40092
                 ; 0002 01A7 }
                 ; .FEND
                 ;
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len)
                 ; 0002 01AA {
                 _buf2num:
                 ; .FSTART _buf2num
                 ; 0002 01AB     unsigned long num=0;
                 ; 0002 01AC     //unsigned char i;
                 ; 0002 01AD     for(;len>0;len--)
003c85 93aa      	ST   -Y,R26
003c86 9724      	SBIW R28,4
003c87 e0e0      	LDI  R30,LOW(0)
003c88 83e8      	ST   Y,R30
003c89 83e9      	STD  Y+1,R30
003c8a 83ea      	STD  Y+2,R30
003c8b 83eb      	STD  Y+3,R30
                 ;	*buf -> Y+5
                 ;	len -> Y+4
                 ;	num -> Y+0
                 _0x40096:
003c8c 81ac      	LDD  R26,Y+4
003c8d 30a1      	CPI  R26,LOW(0x1)
003c8e f0e0      	BRLO _0x40097
                 ; 0002 01AE     {
                 ; 0002 01AF         num<<=8;
003c8f 940e 3fcf 	CALL __GETD2S0
003c91 e0e8      	LDI  R30,LOW(8)
003c92 940e 3f6b 	CALL __LSLD12
003c94 940e 3fd4 	CALL __PUTD1S0
                 ; 0002 01B0         num|=buf[len-1];
003c96 81ec      	LDD  R30,Y+4
003c97 e0f0      	LDI  R31,0
003c98 9731      	SBIW R30,1
003c99 81ad      	LDD  R26,Y+5
003c9a 81be      	LDD  R27,Y+5+1
003c9b 0fae      	ADD  R26,R30
003c9c 1fbf      	ADC  R27,R31
003c9d 91ec      	LD   R30,X
003c9e 940e 3fcf 	CALL __GETD2S0
003ca0 27ff      	CLR  R31
003ca1 2766      	CLR  R22
003ca2 2777      	CLR  R23
003ca3 940e 3f66 	CALL __ORD12
003ca5 940e 3fd4 	CALL __PUTD1S0
                 ; 0002 01B1     }
003ca7 81ec      	LDD  R30,Y+4
003ca8 50e1      	SUBI R30,LOW(1)
003ca9 83ec      	STD  Y+4,R30
003caa cfe1      	RJMP _0x40096
                 _0x40097:
                 ; 0002 01B2     return num;
003cab 940e 3fca 	CALL __GETD1S0
003cad c06a      	RJMP _0x2000009
                 ; 0002 01B3 }
                 ; .FEND
                 ;
                 ;#ifndef PRINT_DEBUG
                 ;unsigned char TestADCs()
                 ; 0002 01B7 {
                 _TestADCs:
                 ; .FSTART _TestADCs
                 ; 0002 01B8     unsigned char StateOfButtons=0;
                 ; 0002 01B9     unsigned char adc_data;
                 ; 0002 01BA     ADMUX=(6 | (ADC_VREF_TYPE & 0xff)); //ADC6 ch=6, ADC7 ch=7
003cae 931a      	ST   -Y,R17
003caf 930a      	ST   -Y,R16
                 ;	StateOfButtons -> R17
                 ;	adc_data -> R16
003cb0 e010      	LDI  R17,0
003cb1 e2e6      	LDI  R30,LOW(38)
003cb2 d281      	RCALL SUBOPT_0x1D
                 ; 0002 01BB     // Delay needed for the stabilization of the ADC input voltage
                 ; 0002 01BC     delay_us(20);
                 ; 0002 01BD     // Start the AD conversion
                 ; 0002 01BE     ADCSRA|=0x40;
                 ; 0002 01BF     while(ADCSRA&(1<<ADSC));//while(ADC_DONE==FALSE);
                 _0x40098:
003cb3 91e0 007a 	LDS  R30,122
003cb5 74e0      	ANDI R30,LOW(0x40)
003cb6 f7e1      	BRNE _0x40098
                 ; 0002 01C0     adc_data=ADCH;
003cb7 9100 0079 	LDS  R16,121
                 ; 0002 01C1     if(adc_data<50)
003cb9 3302      	CPI  R16,50
003cba f410      	BRSH _0x4009B
                 ; 0002 01C2         StateOfButtons|=1<<BUTTON_DOWN;
003cbb 6110      	ORI  R17,LOW(16)
                 ; 0002 01C3     else if(adc_data<150)
003cbc c003      	RJMP _0x4009C
                 _0x4009B:
003cbd 3906      	CPI  R16,150
003cbe f408      	BRSH _0x4009D
                 ; 0002 01C4         StateOfButtons|=1<<BUTTON_STOP;
003cbf 6014      	ORI  R17,LOW(4)
                 ; 0002 01C5     ADMUX=(7 | (ADC_VREF_TYPE & 0xff)); //ADC6 ch=6, ADC7 ch=7
                 _0x4009D:
                 _0x4009C:
003cc0 e2e7      	LDI  R30,LOW(39)
003cc1 d272      	RCALL SUBOPT_0x1D
                 ; 0002 01C6     // Delay needed for the stabilization of the ADC input voltage
                 ; 0002 01C7     delay_us(20);
                 ; 0002 01C8     // Start the AD conversion
                 ; 0002 01C9     ADCSRA|=0x40;
                 ; 0002 01CA     while(ADCSRA&(1<<ADSC));//while(ADC_DONE==FALSE);
                 _0x4009E:
003cc2 91e0 007a 	LDS  R30,122
003cc4 74e0      	ANDI R30,LOW(0x40)
003cc5 f7e1      	BRNE _0x4009E
                 ; 0002 01CB     adc_data=ADCH;
003cc6 9100 0079 	LDS  R16,121
                 ; 0002 01CC     if(adc_data<50)
003cc8 3302      	CPI  R16,50
003cc9 f410      	BRSH _0x400A1
                 ; 0002 01CD         StateOfButtons|=1<<BUTTON_UP;
003cca 6018      	ORI  R17,LOW(8)
                 ; 0002 01CE     else if(adc_data<150)
003ccb c003      	RJMP _0x400A2
                 _0x400A1:
003ccc 3906      	CPI  R16,150
003ccd f408      	BRSH _0x400A3
                 ; 0002 01CF         StateOfButtons|=1<<BUTTON_START;
003cce 6012      	ORI  R17,LOW(2)
                 ; 0002 01D0     if(StateOfButtons)
                 _0x400A3:
                 _0x400A2:
003ccf 3010      	CPI  R17,0
003cd0 f011      	BREQ _0x400A4
                 ; 0002 01D1         return StateOfButtons;
003cd1 2fe1      	MOV  R30,R17
003cd2 c001      	RJMP _0x200000A
                 ; 0002 01D2     return (1<<BUTTONS_RELEASED);
                 _0x400A4:
003cd3 e0e1      	LDI  R30,LOW(1)
                 _0x200000A:
003cd4 9109      	LD   R16,Y+
003cd5 9119      	LD   R17,Y+
003cd6 9508      	RET
                 ; 0002 01D3 }
                 ; .FEND
                 ;
                 ;#endif
                 ;#include "spi_sdcard.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;
                 ;
                 ;
                 ;void SPI_init()
                 ; 0003 0007 {
                 
                 	.CSEG
                 _SPI_init:
                 ; .FSTART _SPI_init
                 ; 0003 0008     // set CS, MOSI and SCK to output
                 ; 0003 0009     DDR_SPI |= (1 << CS) | (1 << MOSI) | (1 << SCK);
003cd7 b1e4      	IN   R30,0x4
003cd8 62ec      	ORI  R30,LOW(0x2C)
003cd9 b9e4      	OUT  0x4,R30
                 ; 0003 000A     PORT_SPI|=(1 << CS);
003cda 9a2a      	SBI  0x5,2
                 ; 0003 000B     // enable pull up resistor in MISO
                 ; 0003 000C     DDR_SPI &= ~(1 << MISO);
003cdb 9824      	CBI  0x4,4
                 ; 0003 000D     //PORT_SPI &= ~(1 << MISO);
                 ; 0003 000E     PORT_SPI |= (1 << MISO);
003cdc 9a2c      	SBI  0x5,4
                 ; 0003 000F 
                 ; 0003 0010     // enable SPI, set as master, and clock to fosc/128
                 ; 0003 0011     SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
003cdd e5e3      	LDI  R30,LOW(83)
003cde bdec      	OUT  0x2C,R30
                 ; 0003 0012 }
003cdf 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SPI_transfer(unsigned char data)
                 ; 0003 0015 {
                 _SPI_transfer:
                 ; .FSTART _SPI_transfer
                 ; 0003 0016     // load data into register
                 ; 0003 0017     SPDR = data;
003ce0 93aa      	ST   -Y,R26
                 ;	data -> Y+0
003ce1 81e8      	LD   R30,Y
003ce2 bdee      	OUT  0x2E,R30
                 ; 0003 0018 
                 ; 0003 0019     // Wait for transmission complete
                 ; 0003 001A     while(!(SPSR & (1 << SPIF)));
                 _0x60003:
003ce3 b5ed      	IN   R30,0x2D
003ce4 78e0      	ANDI R30,LOW(0x80)
003ce5 f3e9      	BREQ _0x60003
                 ; 0003 001B 
                 ; 0003 001C     // return SPDR
                 ; 0003 001D     return SPDR;
003ce6 b5ee      	IN   R30,0x2E
003ce7 9621      	ADIW R28,1
003ce8 9508      	RET
                 ; 0003 001E }
                 ; .FEND
                 ;
                 ;
                 ;void SD_powerUpSeq()
                 ; 0003 0022 {
                 _SD_powerUpSeq:
                 ; .FSTART _SD_powerUpSeq
                 ; 0003 0023     unsigned char i;
                 ; 0003 0024 
                 ; 0003 0025     SPI_init();
003ce9 931a      	ST   -Y,R17
                 ;	i -> R17
003cea dfec      	RCALL _SPI_init
                 ; 0003 0026 
                 ; 0003 0027     // make sure card is deselected
                 ; 0003 0028     CS_DISABLE();
003ceb 9a2a      	SBI  0x5,2
                 ; 0003 0029 
                 ; 0003 002A     // give SD card time to power up
                 ; 0003 002B     delay_ms(1);
003cec e0a1      	LDI  R26,LOW(1)
003ced e0b0      	LDI  R27,0
003cee 940e 3f57 	CALL _delay_ms
                 ; 0003 002C 
                 ; 0003 002D     // send 80 clock cycles to synchronize
                 ; 0003 002E     for(i = 0; i < 10; i++)
003cf0 e010      	LDI  R17,LOW(0)
                 _0x60007:
003cf1 301a      	CPI  R17,10
003cf2 f420      	BRSH _0x60008
                 ; 0003 002F         SPI_transfer(0xFF);
003cf3 efaf      	LDI  R26,LOW(255)
003cf4 dfeb      	RCALL _SPI_transfer
003cf5 5f1f      	SUBI R17,-1
003cf6 cffa      	RJMP _0x60007
                 _0x60008:
                 ; 0003 0032 PORTB |= (1 << 2       );
003cf7 d247      	RCALL SUBOPT_0x1E
                 ; 0003 0033     SPI_transfer(0xFF);
                 ; 0003 0034 }
003cf8 c086      	RJMP _0x2000005
                 ; .FEND
                 ;
                 ;unsigned char SD_command(unsigned char cmd, unsigned long arg, unsigned char crc)
                 ; 0003 0037 {
                 _SD_command:
                 ; .FSTART _SD_command
                 ; 0003 0038     unsigned char res;//,count;
                 ; 0003 0039     // transmit command to sd card
                 ; 0003 003A     SPI_transfer(cmd|0x40);
003cf9 93aa      	ST   -Y,R26
003cfa 931a      	ST   -Y,R17
                 ;	cmd -> Y+6
                 ;	arg -> Y+2
                 ;	crc -> Y+1
                 ;	res -> R17
003cfb 81ee      	LDD  R30,Y+6
003cfc 64e0      	ORI  R30,0x40
003cfd d244      	RCALL SUBOPT_0x1F
                 ; 0003 003B 
                 ; 0003 003C     // transmit argument
                 ; 0003 003D     SPI_transfer((unsigned char)(arg >> 24));
003cfe e1e8      	LDI  R30,LOW(24)
003cff 940e 3f77 	CALL __LSRD12
003d01 2fae      	MOV  R26,R30
003d02 dfdd      	RCALL _SPI_transfer
                 ; 0003 003E     SPI_transfer((unsigned char)(arg >> 16));
                +
003d03 81ea     +LDD R30 , Y + 2
003d04 81fb     +LDD R31 , Y + 2 + 1
003d05 816c     +LDD R22 , Y + 2 + 2
003d06 817d     +LDD R23 , Y + 2 + 3
                 	__GETD1S 2
003d07 940e 3f91 	CALL __LSRD16
003d09 d238      	RCALL SUBOPT_0x1F
                 ; 0003 003F     SPI_transfer((unsigned char)(arg >> 8));
003d0a e0e8      	LDI  R30,LOW(8)
003d0b 940e 3f77 	CALL __LSRD12
003d0d 2fae      	MOV  R26,R30
003d0e dfd1      	RCALL _SPI_transfer
                 ; 0003 0040     SPI_transfer((unsigned char)(arg));
003d0f 81aa      	LDD  R26,Y+2
003d10 dfcf      	RCALL _SPI_transfer
                 ; 0003 0041 
                 ; 0003 0042     // transmit crc
                 ; 0003 0043     SPI_transfer(crc|0x01);
003d11 81e9      	LDD  R30,Y+1
003d12 60e1      	ORI  R30,1
003d13 2fae      	MOV  R26,R30
003d14 dfcb      	RCALL _SPI_transfer
                 ; 0003 0044 
                 ; 0003 0045     //wait response R1
                 ; 0003 0046     res = SD_readRes1();
003d15 d004      	RCALL _SD_readRes1
003d16 2f1e      	MOV  R17,R30
                 ; 0003 0047     /*
                 ; 0003 0048     do {
                 ; 0003 0049      res=SPI_transfer(0xFF);;
                 ; 0003 004A      count++;
                 ; 0003 004B     } while ( ((res&0x80)!=0x00)&&(count<0xff) );
                 ; 0003 004C     */
                 ; 0003 004D     return res;
003d17 8118      	LDD  R17,Y+0
                 _0x2000009:
003d18 9627      	ADIW R28,7
003d19 9508      	RET
                 ; 0003 004E }
                 ; .FEND
                 ;
                 ;
                 ;unsigned char SD_readRes1()
                 ; 0003 0052 {
                 _SD_readRes1:
                 ; .FSTART _SD_readRes1
                 ; 0003 0053     unsigned char res1;
                 ; 0003 0054     unsigned int i = 0;
                 ; 0003 0055 
                 ; 0003 0056     // keep polling until actual data received
                 ; 0003 0057     //while((res1 = SPI_transfer(0xFF)) == 0xFF)
                 ; 0003 0058     while(((res1 = SPI_transfer(0xFF))&0x80) != 0x00)
003d1a 940e 3fe9 	CALL __SAVELOCR4
                 ;	res1 -> R17
                 ;	i -> R18,R19
                +
003d1c e020     +LDI R18 , LOW ( 0 )
003d1d e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60009:
003d1e efaf      	LDI  R26,LOW(255)
003d1f dfc0      	RCALL _SPI_transfer
003d20 2f1e      	MOV  R17,R30
003d21 78e0      	ANDI R30,LOW(0x80)
003d22 f031      	BREQ _0x6000B
                 ; 0003 0059     {
                 ; 0003 005A         i++;
                +
003d23 5f2f     +SUBI R18 , LOW ( - 1 )
003d24 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                 ; 0003 005B 
                 ; 0003 005C         // if no data received for (254)8 bytes, break
                 ; 0003 005D         if(i > 0x1FF) break;
                +
003d25 3020     +CPI R18 , LOW ( 512 )
003d26 e0e2     +LDI R30 , HIGH ( 512 )
003d27 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
003d28 f3a8      	BRLO _0x60009
                 ; 0003 005E     }
                 _0x6000B:
                 ; 0003 005F 
                 ; 0003 0060     return res1;
003d29 2fe1      	MOV  R30,R17
003d2a 940e 3ff0 	CALL __LOADLOCR4
                 _0x2000008:
003d2c 9624      	ADIW R28,4
003d2d 9508      	RET
                 ; 0003 0061 }
                 ; .FEND
                 ;
                 ;unsigned char SD_goIdleState()
                 ; 0003 0064 {
                 _SD_goIdleState:
                 ; .FSTART _SD_goIdleState
                 ; 0003 0065     unsigned char res1;
                 ; 0003 0066     // assert chip select
                 ; 0003 0067     SPI_transfer(0xFF);
003d2e d21a      	RCALL SUBOPT_0x20
                 ;	res1 -> R17
                 ; 0003 0068     CS_ENABLE();
                 ; 0003 0069     //SPI_transfer(0xFF);
                 ; 0003 006A 
                 ; 0003 006B     // send CMD0
                 ; 0003 006C     res1 = SD_command(CMD0, CMD0_ARG, CMD0_CRC);
003d2f e0e0      	LDI  R30,LOW(0)
003d30 93ea      	ST   -Y,R30
003d31 d0f7      	RCALL SUBOPT_0x2
003d32 e9a4      	LDI  R26,LOW(148)
003d33 c047      	RJMP _0x2000004
                 ; 0003 006D 
                 ; 0003 006E     // read response
                 ; 0003 006F     //res1 = SD_readRes1();
                 ; 0003 0070 
                 ; 0003 0071     // deassert chip select
                 ; 0003 0072     SPI_transfer(0xFF);
                 ; 0003 0073     CS_DISABLE();
                 ; 0003 0074     SPI_transfer(0xFF);
                 ; 0003 0075 
                 ; 0003 0076     return res1;
                 ; 0003 0077 }
                 ; .FEND
                 ;
                 ;void SD_readRes7(unsigned char *res)
                 ; 0003 007A {
                 _SD_readRes7:
                 ; .FSTART _SD_readRes7
                 ; 0003 007B     // read response 1 in R7
                 ; 0003 007C     //res[0] = SD_readRes1();
                 ; 0003 007D 
                 ; 0003 007E     // if error reading R1, return
                 ; 0003 007F     if(res[0] > 1) return;
003d34 d0e7      	RCALL SUBOPT_0x0
                 ;	*res -> Y+0
003d35 91ac      	LD   R26,X
003d36 30a2      	CPI  R26,LOW(0x2)
003d37 f578      	BRSH _0x2000007
                 ; 0003 0080 
                 ; 0003 0081     // read remaining bytes
                 ; 0003 0082     res[1] = SPI_transfer(0xFF);
003d38 efaf      	LDI  R26,LOW(255)
003d39 dfa6      	RCALL _SPI_transfer
                +
003d3a 81a8     +LDD R26 , Y + 0
003d3b 81b9     +LDD R27 , Y + 0 + 1
003d3c 9611     +ADIW R26 , 1
003d3d 93ec     +ST X , R30
                 	__PUTB1SNS 0,1
                 ; 0003 0083     res[2] = SPI_transfer(0xFF);
003d3e efaf      	LDI  R26,LOW(255)
003d3f dfa0      	RCALL _SPI_transfer
                +
003d40 81a8     +LDD R26 , Y + 0
003d41 81b9     +LDD R27 , Y + 0 + 1
003d42 9612     +ADIW R26 , 2
003d43 93ec     +ST X , R30
                 	__PUTB1SNS 0,2
                 ; 0003 0084     res[3] = SPI_transfer(0xFF);
003d44 efaf      	LDI  R26,LOW(255)
003d45 df9a      	RCALL _SPI_transfer
                +
003d46 81a8     +LDD R26 , Y + 0
003d47 81b9     +LDD R27 , Y + 0 + 1
003d48 9613     +ADIW R26 , 3
003d49 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
                 ; 0003 0085     res[4] = SPI_transfer(0xFF);
003d4a efaf      	LDI  R26,LOW(255)
003d4b df94      	RCALL _SPI_transfer
                +
003d4c 81a8     +LDD R26 , Y + 0
003d4d 81b9     +LDD R27 , Y + 0 + 1
003d4e 9614     +ADIW R26 , 4
003d4f 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
                 ; 0003 0086 }
003d50 c016      	RJMP _0x2000007
                 ; .FEND
                 ;
                 ;void SD_sendIfCond(unsigned char *res)
                 ; 0003 0089 {
                 _SD_sendIfCond:
                 ; .FSTART _SD_sendIfCond
                 ; 0003 008A     // assert chip select
                 ; 0003 008B     SPI_transfer(0xFF);
003d51 d1fc      	RCALL SUBOPT_0x21
                 ;	*res -> Y+0
                 ; 0003 008C     CS_ENABLE();
                 ; 0003 008D     //SPI_transfer(0xFF);
                 ; 0003 008E 
                 ; 0003 008F     // send CMD8
                 ; 0003 0090     res[0]=SD_command(CMD8, CMD8_ARG, CMD8_CRC);
003d52 e0e8      	LDI  R30,LOW(8)
003d53 93ea      	ST   -Y,R30
                +
003d54 eaea     +LDI R30 , LOW ( 0x1AA )
003d55 e0f1     +LDI R31 , HIGH ( 0x1AA )
003d56 e060     +LDI R22 , BYTE3 ( 0x1AA )
003d57 e070     +LDI R23 , BYTE4 ( 0x1AA )
                 	__GETD1N 0x1AA
003d58 940e 3fd9 	CALL __PUTPARD1
003d5a e8a6      	LDI  R26,LOW(134)
003d5b c005      	RJMP _0x2000006
                 ; 0003 0091 
                 ; 0003 0092     // read response
                 ; 0003 0093     SD_readRes7(res);
                 ; 0003 0094 
                 ; 0003 0095     // deassert chip select
                 ; 0003 0096     SPI_transfer(0xFF);
                 ; 0003 0097     CS_DISABLE();
                 ; 0003 0098     SPI_transfer(0xFF);
                 ; 0003 0099 }
                 ; .FEND
                 ;
                 ;/*
                 ;void SD_readRes3_7(unsigned char *res)
                 ;{
                 ;    // read R1
                 ;    //res[0] = SD_readRes1();
                 ;
                 ;    // if error reading R1, return
                 ;    if(res[0] > 1) return;
                 ;
                 ;    // read remaining bytes
                 ;    res[1] = SPI_transfer(0xFF);
                 ;    res[2] = SPI_transfer(0xFF);
                 ;    res[3] = SPI_transfer(0xFF);
                 ;    res[4] = SPI_transfer(0xFF);
                 ;}
                 ;*/
                 ;
                 ;void SD_readOCR(unsigned char *res)
                 ; 0003 00AD {
                 _SD_readOCR:
                 ; .FSTART _SD_readOCR
                 ; 0003 00AE     // assert chip select
                 ; 0003 00AF     SPI_transfer(0xFF);
003d5c d1f1      	RCALL SUBOPT_0x21
                 ;	*res -> Y+0
                 ; 0003 00B0     CS_ENABLE();
                 ; 0003 00B1     //SPI_transfer(0xFF);
                 ; 0003 00B2 
                 ; 0003 00B3     // send CMD58
                 ; 0003 00B4     res[0] = SD_command(CMD58, CMD58_ARG, CMD58_CRC);
003d5d e3ea      	LDI  R30,LOW(58)
003d5e 93ea      	ST   -Y,R30
003d5f d0c9      	RCALL SUBOPT_0x2
003d60 e0a0      	LDI  R26,LOW(0)
                 _0x2000006:
003d61 df97      	RCALL _SD_command
003d62 81a8      	LD   R26,Y
003d63 81b9      	LDD  R27,Y+1
003d64 93ec      	ST   X,R30
                 ; 0003 00B5 
                 ; 0003 00B6     // read response
                 ; 0003 00B7     //SD_readRes3_7(res);
                 ; 0003 00B8     SD_readRes7(res);
003d65 dfce      	RCALL _SD_readRes7
                 ; 0003 00B9 
                 ; 0003 00BA     // deassert chip select
                 ; 0003 00BB     SPI_transfer(0xFF);
003d66 d1ed      	RCALL SUBOPT_0x22
                 ; 0003 00BC     CS_DISABLE();
                 ; 0003 00BD     SPI_transfer(0xFF);
                 ; 0003 00BE }
                 _0x2000007:
003d67 9622      	ADIW R28,2
003d68 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SD_sendApp()
                 ; 0003 00C1 {
                 _SD_sendApp:
                 ; .FSTART _SD_sendApp
                 ; 0003 00C2     unsigned char res1;
                 ; 0003 00C3     // assert chip select
                 ; 0003 00C4     SPI_transfer(0xFF);
003d69 d1df      	RCALL SUBOPT_0x20
                 ;	res1 -> R17
                 ; 0003 00C5     CS_ENABLE();
                 ; 0003 00C6     //SPI_transfer(0xFF);
                 ; 0003 00C7 
                 ; 0003 00C8     // send CMD0
                 ; 0003 00C9     res1 = SD_command(CMD55, CMD55_ARG, CMD55_CRC);
003d6a e3e7      	LDI  R30,LOW(55)
003d6b 93ea      	ST   -Y,R30
                +
003d6c e0e0     +LDI R30 , LOW ( 0x0 )
003d6d e0f0     +LDI R31 , HIGH ( 0x0 )
003d6e e060     +LDI R22 , BYTE3 ( 0x0 )
003d6f e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
003d70 c007      	RJMP _0x2000003
                 ; 0003 00CA 
                 ; 0003 00CB     // read response
                 ; 0003 00CC     //res1 = SD_readRes1();
                 ; 0003 00CD 
                 ; 0003 00CE     // deassert chip select
                 ; 0003 00CF     SPI_transfer(0xFF);
                 ; 0003 00D0     CS_DISABLE();
                 ; 0003 00D1     SPI_transfer(0xFF);
                 ; 0003 00D2 
                 ; 0003 00D3     return res1;
                 ; 0003 00D4 }
                 ; .FEND
                 ;
                 ;unsigned char SD_sendOpCond()
                 ; 0003 00D7 {
                 _SD_sendOpCond:
                 ; .FSTART _SD_sendOpCond
                 ; 0003 00D8     unsigned char res1;
                 ; 0003 00D9     // assert chip select
                 ; 0003 00DA     SPI_transfer(0xFF);
003d71 d1d7      	RCALL SUBOPT_0x20
                 ;	res1 -> R17
                 ; 0003 00DB     CS_ENABLE();
                 ; 0003 00DC     //SPI_transfer(0xFF);
                 ; 0003 00DD 
                 ; 0003 00DE     // send CMD0
                 ; 0003 00DF     res1 =  SD_command(ACMD41, ACMD41_ARG, ACMD41_CRC);
003d72 e2e9      	LDI  R30,LOW(41)
003d73 93ea      	ST   -Y,R30
                +
003d74 e0e0     +LDI R30 , LOW ( 0x40000000 )
003d75 e0f0     +LDI R31 , HIGH ( 0x40000000 )
003d76 e060     +LDI R22 , BYTE3 ( 0x40000000 )
003d77 e470     +LDI R23 , BYTE4 ( 0x40000000 )
                 	__GETD1N 0x40000000
                 _0x2000003:
003d78 940e 3fd9 	CALL __PUTPARD1
003d7a e0a0      	LDI  R26,LOW(0)
                 _0x2000004:
003d7b df7d      	RCALL _SD_command
003d7c 2f1e      	MOV  R17,R30
                 ; 0003 00E0 
                 ; 0003 00E1     // read response
                 ; 0003 00E2     //res1 = SD_readRes1();
                 ; 0003 00E3 
                 ; 0003 00E4     // deassert chip select
                 ; 0003 00E5     SPI_transfer(0xFF);
003d7d d1d6      	RCALL SUBOPT_0x22
                 ; 0003 00E6     CS_DISABLE();
                 ; 0003 00E7     SPI_transfer(0xFF);
                 ; 0003 00E8 
                 ; 0003 00E9     return res1;
003d7e 2fe1      	MOV  R30,R17
                 _0x2000005:
003d7f 9119      	LD   R17,Y+
003d80 9508      	RET
                 ; 0003 00EA }
                 ; .FEND
                 ;
                 ;unsigned char SD_init()
                 ; 0003 00ED {
                 _SD_init:
                 ; .FSTART _SD_init
                 ; 0003 00EE     unsigned char res[5], cmdAttempts = 0;
                 ; 0003 00EF 
                 ; 0003 00F0     SD_powerUpSeq();
003d81 9725      	SBIW R28,5
003d82 931a      	ST   -Y,R17
                 ;	res -> Y+1
                 ;	cmdAttempts -> R17
003d83 e010      	LDI  R17,0
003d84 df64      	RCALL _SD_powerUpSeq
                 ; 0003 00F1 
                 ; 0003 00F2     // command card to idle
                 ; 0003 00F3     while((res[0] = SD_goIdleState()) != 0x01)
                 _0x6000E:
003d85 dfa8      	RCALL _SD_goIdleState
003d86 83e9      	STD  Y+1,R30
003d87 30e1      	CPI  R30,LOW(0x1)
003d88 f031      	BREQ _0x60010
                 ; 0003 00F4     {
                 ; 0003 00F5         //putchar('I');putchar('d');
                 ; 0003 00F6         //putchar(res[0]);
                 ; 0003 00F7         cmdAttempts++;
003d89 5f1f      	SUBI R17,-1
                 ; 0003 00F8         if(cmdAttempts > 100) return SD_ERROR;
003d8a 3615      	CPI  R17,101
003d8b f010      	BRLO _0x60011
003d8c e0e1      	LDI  R30,LOW(1)
003d8d c02e      	RJMP _0x2000002
                 ; 0003 00F9     }
                 _0x60011:
003d8e cff6      	RJMP _0x6000E
                 _0x60010:
                 ; 0003 00FA 
                 ; 0003 00FB 
                 ; 0003 00FC 
                 ; 0003 00FD     // send interface conditions
                 ; 0003 00FE     SD_sendIfCond(res);
003d8f 01de      	MOVW R26,R28
003d90 9611      	ADIW R26,1
003d91 dfbf      	RCALL _SD_sendIfCond
                 ; 0003 00FF 
                 ; 0003 0100     //printhex("If",res[0],1);
                 ; 0003 0101 
                 ; 0003 0102     if(res[0] != 0x01)
003d92 81a9      	LDD  R26,Y+1
003d93 30a1      	CPI  R26,LOW(0x1)
003d94 f011      	BREQ _0x60012
                 ; 0003 0103     {
                 ; 0003 0104         return SD_ERROR;
003d95 e0e1      	LDI  R30,LOW(1)
003d96 c025      	RJMP _0x2000002
                 ; 0003 0105     }
                 ; 0003 0106 
                 ; 0003 0107     // check echo pattern
                 ; 0003 0108     if(res[4] != 0xAA)
                 _0x60012:
003d97 81ad      	LDD  R26,Y+5
003d98 3aaa      	CPI  R26,LOW(0xAA)
003d99 f011      	BREQ _0x60013
                 ; 0003 0109     {
                 ; 0003 010A         return SD_ERROR;
003d9a e0e1      	LDI  R30,LOW(1)
003d9b c020      	RJMP _0x2000002
                 ; 0003 010B     }
                 ; 0003 010C 
                 ; 0003 010D     // attempt to initialize card
                 ; 0003 010E     cmdAttempts = 0;
                 _0x60013:
003d9c e010      	LDI  R17,LOW(0)
                 ; 0003 010F     do
                 _0x60015:
                 ; 0003 0110     {
                 ; 0003 0111         if(cmdAttempts > 100) return SD_ERROR;
003d9d 3615      	CPI  R17,101
003d9e f010      	BRLO _0x60017
003d9f e0e1      	LDI  R30,LOW(1)
003da0 c01b      	RJMP _0x2000002
                 ; 0003 0112 
                 ; 0003 0113         // send app cmd
                 ; 0003 0114         res[0] = SD_sendApp();
                 _0x60017:
003da1 dfc7      	RCALL _SD_sendApp
003da2 83e9      	STD  Y+1,R30
                 ; 0003 0115 
                 ; 0003 0116         // if no error in response
                 ; 0003 0117         if(res[0] < 2)
003da3 81a9      	LDD  R26,Y+1
003da4 30a2      	CPI  R26,LOW(0x2)
003da5 f410      	BRSH _0x60018
                 ; 0003 0118         {
                 ; 0003 0119             res[0] = SD_sendOpCond();
003da6 dfca      	RCALL _SD_sendOpCond
003da7 83e9      	STD  Y+1,R30
                 ; 0003 011A         }
                 ; 0003 011B 
                 ; 0003 011C         // wait
                 ; 0003 011D         if(res[0] != SD_READY)
                 _0x60018:
003da8 81e9      	LDD  R30,Y+1
003da9 30e0      	CPI  R30,0
003daa f021      	BREQ _0x60019
                 ; 0003 011E             delay_ms(10);
003dab e0aa      	LDI  R26,LOW(10)
003dac e0b0      	LDI  R27,0
003dad 940e 3f57 	CALL _delay_ms
                 ; 0003 011F 
                 ; 0003 0120         cmdAttempts++;
                 _0x60019:
003daf 5f1f      	SUBI R17,-1
                 ; 0003 0121     }
                 ; 0003 0122     while(res[0] != SD_READY);
003db0 81e9      	LDD  R30,Y+1
003db1 30e0      	CPI  R30,0
003db2 f751      	BRNE _0x60015
                 ; 0003 0123 
                 ; 0003 0124     // read OCR
                 ; 0003 0125     SD_readOCR(res);
003db3 01de      	MOVW R26,R28
003db4 9611      	ADIW R26,1
003db5 dfa6      	RCALL _SD_readOCR
                 ; 0003 0126 
                 ; 0003 0127     // check card is ready
                 ; 0003 0128     if(!(res[1] & 0x80)) return SD_ERROR;
003db6 81ea      	LDD  R30,Y+2
003db7 78e0      	ANDI R30,LOW(0x80)
003db8 f411      	BRNE _0x6001A
003db9 e0e1      	LDI  R30,LOW(1)
003dba c001      	RJMP _0x2000002
                 ; 0003 0129 
                 ; 0003 012A     return SD_SUCCESS;
                 _0x6001A:
003dbb e0e0      	LDI  R30,LOW(0)
                 _0x2000002:
003dbc 8118      	LDD  R17,Y+0
003dbd 9626      	ADIW R28,6
003dbe 9508      	RET
                 ; 0003 012B }
                 ; .FEND
                 ;
                 ;#define CMD17                   17
                 ;#define CMD17_CRC               0x00
                 ;#define SD_MAX_READ_ATTEMPTS    1563
                 ;
                 ;/*******************************************************************************
                 ; Read single 512 byte block
                 ; token = 0xFE - Successful read
                 ; token = 0x0X - Data error
                 ; token = 0xFF - Timeout
                 ;*******************************************************************************/
                 ;unsigned char SD_readSingleBlock(unsigned long addr, unsigned char *buf, unsigned char *token)
                 ; 0003 0138 {
                 _SD_readSingleBlock:
                 ; .FSTART _SD_readSingleBlock
                 ; 0003 0139     unsigned char res1, read;
                 ; 0003 013A     unsigned int i, readAttempts;
                 ; 0003 013B     addr*=512UL;
003dbf 93ba      	ST   -Y,R27
003dc0 93aa      	ST   -Y,R26
003dc1 940e 3fe7 	CALL __SAVELOCR6
                 ;	addr -> Y+10
                 ;	*buf -> Y+8
                 ;	*token -> Y+6
                 ;	res1 -> R17
                 ;	read -> R16
                 ;	i -> R18,R19
                 ;	readAttempts -> R20,R21
                +
003dc3 85ea     +LDD R30 , Y + 10
003dc4 85fb     +LDD R31 , Y + 10 + 1
003dc5 856c     +LDD R22 , Y + 10 + 2
003dc6 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
                +
003dc7 e0a0     +LDI R26 , LOW ( 0x200 )
003dc8 e0b2     +LDI R27 , HIGH ( 0x200 )
003dc9 e080     +LDI R24 , BYTE3 ( 0x200 )
003dca e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
003dcb 940e 3fa0 	CALL __MULD12U
                +
003dcd 87ea     +STD Y + 10 , R30
003dce 87fb     +STD Y + 10 + 1 , R31
003dcf 876c     +STD Y + 10 + 2 , R22
003dd0 877d     +STD Y + 10 + 3 , R23
                 	__PUTD1S 10
                 ; 0003 013C     // set token to none
                 ; 0003 013D     *token = 0xFF;
003dd1 81ae      	LDD  R26,Y+6
003dd2 81bf      	LDD  R27,Y+6+1
003dd3 efef      	LDI  R30,LOW(255)
003dd4 93ec      	ST   X,R30
                 ; 0003 013E 
                 ; 0003 013F     // assert chip select
                 ; 0003 0140     SPI_transfer(0xFF);
003dd5 efaf      	LDI  R26,LOW(255)
003dd6 df09      	RCALL _SPI_transfer
                 ; 0003 0141     CS_ENABLE();
003dd7 982a      	CBI  0x5,2
                 ; 0003 0142     //SPI_transfer(0xFF);
                 ; 0003 0143 
                 ; 0003 0144     // send CMD17
                 ; 0003 0145     res1 = SD_command(CMD17, addr, CMD17_CRC);
003dd8 e1e1      	LDI  R30,LOW(17)
003dd9 93ea      	ST   -Y,R30
                +
003dda 85eb     +LDD R30 , Y + 11
003ddb 85fc     +LDD R31 , Y + 11 + 1
003ddc 856d     +LDD R22 , Y + 11 + 2
003ddd 857e     +LDD R23 , Y + 11 + 3
                 	__GETD1S 11
003dde 940e 3fd9 	CALL __PUTPARD1
003de0 e0a0      	LDI  R26,LOW(0)
003de1 df17      	RCALL _SD_command
003de2 2f1e      	MOV  R17,R30
                 ; 0003 0146 
                 ; 0003 0147     // read R1
                 ; 0003 0148     //res1 = SD_readRes1();
                 ; 0003 0149 
                 ; 0003 014A     // if response received from card
                 ; 0003 014B     if(res1 != 0xFF)
003de3 3f1f      	CPI  R17,255
003de4 f169      	BREQ _0x6001B
                 ; 0003 014C     {
                 ; 0003 014D         // wait for a response token (timeout = 100ms)
                 ; 0003 014E         readAttempts = 0;
                +
003de5 e040     +LDI R20 , LOW ( 0 )
003de6 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 014F         while(++readAttempts != SD_MAX_READ_ATTEMPTS)
                 _0x6001C:
003de7 01fa      	MOVW R30,R20
003de8 9631      	ADIW R30,1
003de9 01af      	MOVW R20,R30
003dea 31eb      	CPI  R30,LOW(0x61B)
003deb e0a6      	LDI  R26,HIGH(0x61B)
003dec 07fa      	CPC  R31,R26
003ded f029      	BREQ _0x6001E
                 ; 0003 0150             if((read = SPI_transfer(0xFF)) != 0xFF) break;
003dee efaf      	LDI  R26,LOW(255)
003def def0      	RCALL _SPI_transfer
003df0 2f0e      	MOV  R16,R30
003df1 3fef      	CPI  R30,LOW(0xFF)
003df2 f3a1      	BREQ _0x6001C
                 ; 0003 0151 
                 ; 0003 0152         // if response token is 0xFE
                 ; 0003 0153         if(read == 0xFE)
                 _0x6001E:
003df3 3f0e      	CPI  R16,254
003df4 f4d1      	BRNE _0x60020
                 ; 0003 0154         {
                 ; 0003 0155             // read 512 byte block
                 ; 0003 0156             for(i = 0; i < 512; i++) *buf++ = SPI_transfer(0xFF);
                +
003df5 e020     +LDI R18 , LOW ( 0 )
003df6 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60022:
                +
003df7 3020     +CPI R18 , LOW ( 512 )
003df8 e0e2     +LDI R30 , HIGH ( 512 )
003df9 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
003dfa f480      	BRSH _0x60023
003dfb 85e8      	LDD  R30,Y+8
003dfc 85f9      	LDD  R31,Y+8+1
003dfd 9631      	ADIW R30,1
003dfe 87e8      	STD  Y+8,R30
003dff 87f9      	STD  Y+8+1,R31
003e00 9731      	SBIW R30,1
003e01 93ff      	PUSH R31
003e02 93ef      	PUSH R30
003e03 efaf      	LDI  R26,LOW(255)
003e04 dedb      	RCALL _SPI_transfer
003e05 91af      	POP  R26
003e06 91bf      	POP  R27
003e07 93ec      	ST   X,R30
                +
003e08 5f2f     +SUBI R18 , LOW ( - 1 )
003e09 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
003e0a cfec      	RJMP _0x60022
                 _0x60023:
                 ; 0003 0159 SPI_transfer(0xFF);
003e0b efaf      	LDI  R26,LOW(255)
003e0c ded3      	RCALL _SPI_transfer
                 ; 0003 015A             SPI_transfer(0xFF);
003e0d efaf      	LDI  R26,LOW(255)
003e0e ded1      	RCALL _SPI_transfer
                 ; 0003 015B         }
                 ; 0003 015C 
                 ; 0003 015D         // set token to card response
                 ; 0003 015E         *token = read;
                 _0x60020:
003e0f 81ae      	LDD  R26,Y+6
003e10 81bf      	LDD  R27,Y+6+1
003e11 930c      	ST   X,R16
                 ; 0003 015F     }
                 ; 0003 0160 
                 ; 0003 0161     // deassert chip select
                 ; 0003 0162     SPI_transfer(0xFF);
                 _0x6001B:
003e12 d141      	RCALL SUBOPT_0x22
                 ; 0003 0163     CS_DISABLE();
                 ; 0003 0164     SPI_transfer(0xFF);
                 ; 0003 0165     if(read==0xFE)
003e13 3f0e      	CPI  R16,254
003e14 f411      	BRNE _0x60024
                 ; 0003 0166         return res1;
003e15 2fe1      	MOV  R30,R17
003e16 c001      	RJMP _0x2000001
                 ; 0003 0167     else
                 _0x60024:
                 ; 0003 0168         return SD_ERROR;
003e17 e0e1      	LDI  R30,LOW(1)
                 ; 0003 0169 }
                 _0x2000001:
003e18 940e 3fee 	CALL __LOADLOCR6
003e1a 962e      	ADIW R28,14
003e1b 9508      	RET
                 ; .FEND
                 ;
                 ;
                 ;#ifdef PRINT_DEBUG
                 ;void putchar(char c)
                 ;{
                 ;    while ((UCSR0A & (1<<UDRE0))==0);
                 ;    UDR0=c;
                 ;}
                 ;
                 ;void printhex(flash char *str,unsigned long var,unsigned char len)
                 ;{
                 ;    unsigned char value;
                 ;    putstr(str);
                 ;    putstr(":0x");
                 ;    for(;len>0;len--)
                 ;    {
                 ;        //0x12345678  len=4
                 ;        value=(var>>((len-1)*8)+4)&0x0F;
                 ;        if(value<10){
                 ;            putchar(value+'0');
                 ;        }
                 ;        else{
                 ;            putchar(value-10+'A');
                 ;        }
                 ;        value=(var>>((len-1)*8))&0x0F;
                 ;        if(value<10){
                 ;            putchar(value+'0');
                 ;        }
                 ;        else{
                 ;            putchar(value-10+'A');
                 ;        }
                 ;    }
                 ;    putchar('\r');
                 ;}
                 ;
                 ;void putstr(flash char *str)
                 ;{
                 ;    while(*str){
                 ;        putchar(*str++);
                 ;    }
                 ;}
                 ;void USART_Flush( void )
                 ;{
                 ;    unsigned char dummy;
                 ;    while ( UCSR0A & (1<<RXC0) ) dummy = UDR0;
                 ;}
                 ;
                 ;unsigned char recchar(void)
                 ;{
                 ;    //unsigned char delay=0;
                 ;    // Wait for data to be received
                 ;    //while ( !(UCSR0A & (1<<RXC0)) && ++delay);
                 ;    if( !(UCSR0A & (1<<RXC0)))
                 ;        return 0;
                 ;    else
                 ;        return UDR0;
                 ;}
                 ;#endif
                 
                 	.DSEG
                 _result:
000320           	.BYTE 0x5
                 _sdBuf:
000325           	.BYTE 0x200
                 _testBuf:
000525           	.BYTE 0x80
                 _appStartAdr:
0005a5           	.BYTE 0x4
                 _adr:
0005a9           	.BYTE 0x4
                 _SectorsPerFat:
0005ad           	.BYTE 0x4
                 _fat_begin_lba:
0005b1           	.BYTE 0x4
                 _cluster_begin_lba:
0005b5           	.BYTE 0x4
                 _fat_file_adr:
0005b9           	.BYTE 0x4
                 _fat_file_next_adr:
0005bd           	.BYTE 0x4
                 _filesize:
0005c1           	.BYTE 0x4
                 _readbytes:
0005c5           	.BYTE 0x4
                 _checksumCnt:
0005c9           	.BYTE 0x2
                 _app_pointer:
0005cb           	.BYTE 0x2
                 _partition_type:
0005cd           	.BYTE 0x1
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
003e1c 93ba      	ST   -Y,R27
003e1d 93aa      	ST   -Y,R26
003e1e 81a8      	LD   R26,Y
003e1f 81b9      	LDD  R27,Y+1
003e20 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1:
003e21 9a29      	SBI  0x5,1
003e22 9a28      	SBI  0x5,0
                +
003e23 91e0 05cb+LDS R30 , _app_pointer + ( 0 )
003e25 91f0 05cc+LDS R31 , _app_pointer + ( 0 ) + 1
003e27 9509     +ICALL
                 	__CALL1MN _app_pointer,0
003e28 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x2:
                +
003e29 e0e0     +LDI R30 , LOW ( 0x0 )
003e2a e0f0     +LDI R31 , HIGH ( 0x0 )
003e2b e060     +LDI R22 , BYTE3 ( 0x0 )
003e2c e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
003e2d 940e 3fd9 	CALL __PUTPARD1
003e2f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:42 WORDS
                 SUBOPT_0x3:
003e30 e2e5      	LDI  R30,LOW(_sdBuf)
003e31 e0f3      	LDI  R31,HIGH(_sdBuf)
003e32 93fa      	ST   -Y,R31
003e33 93ea      	ST   -Y,R30
003e34 e0a5      	LDI  R26,LOW(5)
003e35 e0b0      	LDI  R27,HIGH(5)
003e36 df88      	RCALL _SD_readSingleBlock
003e37 93e0 0320 	STS  _result,R30
003e39 30e0      	CPI  R30,0
003e3a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x4:
003e3b 93e0 05a9 	STS  _adr,R30
003e3d 93f0 05aa 	STS  _adr+1,R31
003e3f 9360 05ab 	STS  _adr+2,R22
003e41 9370 05ac 	STS  _adr+3,R23
003e43 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
                 SUBOPT_0x5:
003e44 91e0 05a9 	LDS  R30,_adr
003e46 91f0 05aa 	LDS  R31,_adr+1
003e48 9160 05ab 	LDS  R22,_adr+2
003e4a 9170 05ac 	LDS  R23,_adr+3
003e4c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x6:
003e4d 940e 3fd9 	CALL __PUTPARD1
003e4f cfe0      	RJMP SUBOPT_0x3
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x7:
                +
003e50 e3e3     +LDI R30 , LOW ( _sdBuf + ( 14 ) )
003e51 e0f3     +LDI R31 , HIGH ( _sdBuf + ( 14 ) )
                 	__POINTW1MN _sdBuf,14
003e52 93fa      	ST   -Y,R31
003e53 93ea      	ST   -Y,R30
003e54 e0a2      	LDI  R26,LOW(2)
003e55 ce2f      	RJMP _buf2num
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x8:
003e56 91a0 05b1 	LDS  R26,_fat_begin_lba
003e58 91b0 05b2 	LDS  R27,_fat_begin_lba+1
003e5a 9180 05b3 	LDS  R24,_fat_begin_lba+2
003e5c 9190 05b4 	LDS  R25,_fat_begin_lba+3
003e5e 940e 3f61 	CALL __ADDD12
003e60 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x9:
003e61 93fa      	ST   -Y,R31
003e62 93ea      	ST   -Y,R30
003e63 e0a2      	LDI  R26,LOW(2)
003e64 ce20      	RJMP _buf2num
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xA:
003e65 93e0 05ad 	STS  _SectorsPerFat,R30
003e67 93f0 05ae 	STS  _SectorsPerFat+1,R31
003e69 9360 05af 	STS  _SectorsPerFat+2,R22
003e6b 9370 05b0 	STS  _SectorsPerFat+3,R23
003e6d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xB:
003e6e 2de4      	MOV  R30,R4
003e6f 01d8      	MOVW R26,R16
003e70 e0f0      	LDI  R31,0
003e71 17ae      	CP   R26,R30
003e72 07bf      	CPC  R27,R31
003e73 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xC:
003e74 dfcf      	RCALL SUBOPT_0x5
003e75 cfd7      	RJMP SUBOPT_0x6
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0xD:
003e76 93fa      	ST   -Y,R31
003e77 93ea      	ST   -Y,R30
                +
003e78 e2a0     +LDI R26 , 32
003e79 9fa2     +MUL R26 , R18
003e7a 01f0     +MOVW R30 , R0
003e7b 9fa3     +MUL R26 , R19
003e7c 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
003e7d 5deb      	SUBI R30,LOW(-_sdBuf)
003e7e 4ffc      	SBCI R31,HIGH(-_sdBuf)
003e7f 01df      	MOVW R26,R30
003e80 ddd9      	RCALL _compbuf
                +
003e81 93e0 0321+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
003e83 30e0      	CPI  R30,0
003e84 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0xE:
                +
003e85 e2a0     +LDI R26 , 32
003e86 9fa2     +MUL R26 , R18
003e87 01f0     +MOVW R30 , R0
003e88 9fa3     +MUL R26 , R19
003e89 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
003e8a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0xF:
003e8b 940e 3f96 	CALL __LSLD16
003e8d 93e0 05b9 	STS  _fat_file_adr,R30
003e8f 93f0 05ba 	STS  _fat_file_adr+1,R31
003e91 9360 05bb 	STS  _fat_file_adr+2,R22
003e93 9370 05bc 	STS  _fat_file_adr+3,R23
003e95 cfef      	RJMP SUBOPT_0xE
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x10:
003e96 91a0 05b9 	LDS  R26,_fat_file_adr
003e98 91b0 05ba 	LDS  R27,_fat_file_adr+1
003e9a 9180 05bb 	LDS  R24,_fat_file_adr+2
003e9c 9190 05bc 	LDS  R25,_fat_file_adr+3
003e9e 940e 3f66 	CALL __ORD12
003ea0 93e0 05b9 	STS  _fat_file_adr,R30
003ea2 93f0 05ba 	STS  _fat_file_adr+1,R31
003ea4 9360 05bb 	STS  _fat_file_adr+2,R22
003ea6 9370 05bc 	STS  _fat_file_adr+3,R23
003ea8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x11:
003ea9 eaa9      	LDI  R26,LOW(_adr)
003eaa e0b5      	LDI  R27,HIGH(_adr)
003eab 940e 3fc0 	CALL __GETD1P_INC
                +
003ead 5fef     +SUBI R30 , LOW ( - 1 )
003eae 4fff     +SBCI R31 , HIGH ( - 1 )
003eaf 4f6f     +SBCI R22 , BYTE3 ( - 1 )
003eb0 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
003eb1 940e 3fc5 	CALL __PUTDP1_DEC
003eb3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x12:
003eb4 01f3      	MOVW R30,R6
003eb5 91a0 05b5 	LDS  R26,_cluster_begin_lba
003eb7 91b0 05b6 	LDS  R27,_cluster_begin_lba+1
003eb9 9180 05b7 	LDS  R24,_cluster_begin_lba+2
003ebb 9190 05b8 	LDS  R25,_cluster_begin_lba+3
003ebd 2766      	CLR  R22
003ebe 2777      	CLR  R23
003ebf 940e 3f61 	CALL __ADDD12
003ec1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x13:
003ec2 91e0 05b9 	LDS  R30,_fat_file_adr
003ec4 91f0 05ba 	LDS  R31,_fat_file_adr+1
003ec6 9160 05bb 	LDS  R22,_fat_file_adr+2
003ec8 9170 05bc 	LDS  R23,_fat_file_adr+3
                +
003eca 50e2     +SUBI R30 , LOW ( 2 )
003ecb 40f0     +SBCI R31 , HIGH ( 2 )
003ecc 4060     +SBCI R22 , BYTE3 ( 2 )
003ecd 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
003ece 01df      	MOVW R26,R30
003ecf 01cb      	MOVW R24,R22
003ed0 2de4      	MOV  R30,R4
003ed1 e0f0      	LDI  R31,0
003ed2 940e 3f9b 	CALL __CWD1
003ed4 940e 3fa0 	CALL __MULD12U
003ed6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x14:
003ed7 91a0 05b9 	LDS  R26,_fat_file_adr
003ed9 91b0 05ba 	LDS  R27,_fat_file_adr+1
003edb 9180 05bb 	LDS  R24,_fat_file_adr+2
003edd 9190 05bc 	LDS  R25,_fat_file_adr+3
003edf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x15:
                +
003ee0 3faf     +CPI R26 , LOW ( 0xFFFFFFF )
003ee1 efef     +LDI R30 , HIGH ( 0xFFFFFFF )
003ee2 07be     +CPC R27 , R30
003ee3 efef     +LDI R30 , BYTE3 ( 0xFFFFFFF )
003ee4 078e     +CPC R24 , R30
003ee5 e0ef     +LDI R30 , BYTE4 ( 0xFFFFFFF )
003ee6 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFFFFF
003ee7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x16:
                +
003ee8 3faf     +CPI R26 , LOW ( 0xFFFF )
003ee9 efef     +LDI R30 , HIGH ( 0xFFFF )
003eea 07be     +CPC R27 , R30
003eeb e0e0     +LDI R30 , BYTE3 ( 0xFFFF )
003eec 078e     +CPC R24 , R30
003eed e0e0     +LDI R30 , BYTE4 ( 0xFFFF )
003eee 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFF
003eef 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x17:
003ef0 91e0 05c5 	LDS  R30,_readbytes
003ef2 91f0 05c6 	LDS  R31,_readbytes+1
003ef4 9160 05c7 	LDS  R22,_readbytes+2
003ef6 9170 05c8 	LDS  R23,_readbytes+3
003ef8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x18:
003ef9 01bf      	MOVW R22,R30
003efa e2a5      	LDI  R26,LOW(_sdBuf)
003efb e0b3      	LDI  R27,HIGH(_sdBuf)
003efc 0fa2      	ADD  R26,R18
003efd 1fb3      	ADC  R27,R19
003efe 91ec      	LD   R30,X
003eff 0fee      	LSL  R30
003f00 2e0e      	MOV  R0,R30
003f01 e2a5      	LDI  R26,LOW(_sdBuf)
003f02 e0b3      	LDI  R27,HIGH(_sdBuf)
003f03 0fa2      	ADD  R26,R18
003f04 1fb3      	ADC  R27,R19
003f05 91ec      	LD   R30,X
003f06 1fee      	ROL  R30
003f07 e0e0      	LDI  R30,0
003f08 1fee      	ROL  R30
003f09 29e0      	OR   R30,R0
003f0a 01db      	MOVW R26,R22
003f0b 93ec      	ST   X,R30
003f0c 01d9      	MOVW R26,R18
003f0d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x19:
003f0e 91a0 05c5 	LDS  R26,_readbytes
003f10 91b0 05c6 	LDS  R27,_readbytes+1
003f12 9180 05c7 	LDS  R24,_readbytes+2
003f14 9190 05c8 	LDS  R25,_readbytes+3
003f16 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x1A:
003f17 93e0 05a5 	STS  _appStartAdr,R30
003f19 93f0 05a6 	STS  _appStartAdr+1,R31
003f1b 9360 05a7 	STS  _appStartAdr+2,R22
003f1d 9370 05a8 	STS  _appStartAdr+3,R23
003f1f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x1B:
003f20 91a0 05a5 	LDS  R26,_appStartAdr
003f22 91b0 05a6 	LDS  R27,_appStartAdr+1
003f24 9180 05a7 	LDS  R24,_appStartAdr+2
003f26 9190 05a8 	LDS  R25,_appStartAdr+3
003f28 940e 3f66 	CALL __ORD12
003f2a cfec      	RJMP SUBOPT_0x1A
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1C:
003f2b 91a0 05bd 	LDS  R26,_fat_file_next_adr
003f2d 91b0 05be 	LDS  R27,_fat_file_next_adr+1
003f2f 9180 05bf 	LDS  R24,_fat_file_next_adr+2
003f31 9190 05c0 	LDS  R25,_fat_file_next_adr+3
003f33 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x1D:
003f34 93e0 007c 	STS  124,R30
                +
003f36 e385     +LDI R24 , LOW ( 53 )
                +__DELAY_USB_LOOP :
003f37 958a     +DEC R24
003f38 f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 53
003f39 91e0 007a 	LDS  R30,122
003f3b 64e0      	ORI  R30,0x40
003f3c 93e0 007a 	STS  122,R30
003f3e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1E:
003f3f 9a2a      	SBI  0x5,2
003f40 efaf      	LDI  R26,LOW(255)
003f41 cd9e      	RJMP _SPI_transfer
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1F:
003f42 2fae      	MOV  R26,R30
003f43 dd9c      	RCALL _SPI_transfer
                +
003f44 81aa     +LDD R26 , Y + 2
003f45 81bb     +LDD R27 , Y + 2 + 1
003f46 818c     +LDD R24 , Y + 2 + 2
003f47 819d     +LDD R25 , Y + 2 + 3
                 	__GETD2S 2
003f48 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x20:
003f49 931a      	ST   -Y,R17
003f4a efaf      	LDI  R26,LOW(255)
003f4b dd94      	RCALL _SPI_transfer
003f4c 982a      	CBI  0x5,2
003f4d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x21:
003f4e 93ba      	ST   -Y,R27
003f4f 93aa      	ST   -Y,R26
003f50 efaf      	LDI  R26,LOW(255)
003f51 dd8e      	RCALL _SPI_transfer
003f52 982a      	CBI  0x5,2
003f53 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x22:
003f54 efaf      	LDI  R26,LOW(255)
003f55 dd8a      	RCALL _SPI_transfer
003f56 cfe8      	RJMP SUBOPT_0x1E
                 
                 
                 	.CSEG
                 _delay_ms:
003f57 9610      	adiw r26,0
003f58 f039      	breq __delay_ms1
                 __delay_ms0:
                +
003f59 ed80     +LDI R24 , LOW ( 0x7D0 )
003f5a e097     +LDI R25 , HIGH ( 0x7D0 )
                +__DELAY_USW_LOOP :
003f5b 9701     +SBIW R24 , 1
003f5c f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x7D0
003f5d 95a8      	wdr
003f5e 9711      	sbiw r26,1
003f5f f7c9      	brne __delay_ms0
                 __delay_ms1:
003f60 9508      	ret
                 
                 __ADDD12:
003f61 0fea      	ADD  R30,R26
003f62 1ffb      	ADC  R31,R27
003f63 1f68      	ADC  R22,R24
003f64 1f79      	ADC  R23,R25
003f65 9508      	RET
                 
                 __ORD12:
003f66 2bea      	OR   R30,R26
003f67 2bfb      	OR   R31,R27
003f68 2b68      	OR   R22,R24
003f69 2b79      	OR   R23,R25
003f6a 9508      	RET
                 
                 __LSLD12:
003f6b 23ee      	TST  R30
003f6c 2e0e      	MOV  R0,R30
003f6d 01fd      	MOVW R30,R26
003f6e 01bc      	MOVW R22,R24
003f6f f031      	BREQ __LSLD12R
                 __LSLD12L:
003f70 0fee      	LSL  R30
003f71 1fff      	ROL  R31
003f72 1f66      	ROL  R22
003f73 1f77      	ROL  R23
003f74 940a      	DEC  R0
003f75 f7d1      	BRNE __LSLD12L
                 __LSLD12R:
003f76 9508      	RET
                 
                 __LSRD12:
003f77 23ee      	TST  R30
003f78 2e0e      	MOV  R0,R30
003f79 01fd      	MOVW R30,R26
003f7a 01bc      	MOVW R22,R24
003f7b f031      	BREQ __LSRD12R
                 __LSRD12L:
003f7c 9576      	LSR  R23
003f7d 9567      	ROR  R22
003f7e 95f7      	ROR  R31
003f7f 95e7      	ROR  R30
003f80 940a      	DEC  R0
003f81 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
003f82 9508      	RET
                 
                 __LSLW4:
003f83 0fee      	LSL  R30
003f84 1fff      	ROL  R31
                 __LSLW3:
003f85 0fee      	LSL  R30
003f86 1fff      	ROL  R31
                 __LSLW2:
003f87 0fee      	LSL  R30
003f88 1fff      	ROL  R31
003f89 0fee      	LSL  R30
003f8a 1fff      	ROL  R31
003f8b 9508      	RET
                 
                 __LSLD1:
003f8c 0fee      	LSL  R30
003f8d 1fff      	ROL  R31
003f8e 1f66      	ROL  R22
003f8f 1f77      	ROL  R23
003f90 9508      	RET
                 
                 __LSRD16:
003f91 2fe6      	MOV  R30,R22
003f92 2ff7      	MOV  R31,R23
003f93 e060      	LDI  R22,0
003f94 e070      	LDI  R23,0
003f95 9508      	RET
                 
                 __LSLD16:
003f96 2f6e      	MOV  R22,R30
003f97 2f7f      	MOV  R23,R31
003f98 e0e0      	LDI  R30,0
003f99 e0f0      	LDI  R31,0
003f9a 9508      	RET
                 
                 __CWD1:
003f9b 2f6f      	MOV  R22,R31
003f9c 0f66      	ADD  R22,R22
003f9d 0b66      	SBC  R22,R22
003f9e 2f76      	MOV  R23,R22
003f9f 9508      	RET
                 
                 __MULD12U:
003fa0 9f7a      	MUL  R23,R26
003fa1 2d70      	MOV  R23,R0
003fa2 9f6b      	MUL  R22,R27
003fa3 0d70      	ADD  R23,R0
003fa4 9ff8      	MUL  R31,R24
003fa5 0d70      	ADD  R23,R0
003fa6 9fe9      	MUL  R30,R25
003fa7 0d70      	ADD  R23,R0
003fa8 9f6a      	MUL  R22,R26
003fa9 2d60      	MOV  R22,R0
003faa 0d71      	ADD  R23,R1
003fab 9ffb      	MUL  R31,R27
003fac 0d60      	ADD  R22,R0
003fad 1d71      	ADC  R23,R1
003fae 9fe8      	MUL  R30,R24
003faf 0d60      	ADD  R22,R0
003fb0 1d71      	ADC  R23,R1
003fb1 2788      	CLR  R24
003fb2 9ffa      	MUL  R31,R26
003fb3 2df0      	MOV  R31,R0
003fb4 0d61      	ADD  R22,R1
003fb5 1f78      	ADC  R23,R24
003fb6 9feb      	MUL  R30,R27
003fb7 0df0      	ADD  R31,R0
003fb8 1d61      	ADC  R22,R1
003fb9 1f78      	ADC  R23,R24
003fba 9fea      	MUL  R30,R26
003fbb 2de0      	MOV  R30,R0
003fbc 0df1      	ADD  R31,R1
003fbd 1f68      	ADC  R22,R24
003fbe 1f78      	ADC  R23,R24
003fbf 9508      	RET
                 
                 __GETD1P_INC:
003fc0 91ed      	LD   R30,X+
003fc1 91fd      	LD   R31,X+
003fc2 916d      	LD   R22,X+
003fc3 917d      	LD   R23,X+
003fc4 9508      	RET
                 
                 __PUTDP1_DEC:
003fc5 937e      	ST   -X,R23
003fc6 936e      	ST   -X,R22
003fc7 93fe      	ST   -X,R31
003fc8 93ee      	ST   -X,R30
003fc9 9508      	RET
                 
                 __GETD1S0:
003fca 81e8      	LD   R30,Y
003fcb 81f9      	LDD  R31,Y+1
003fcc 816a      	LDD  R22,Y+2
003fcd 817b      	LDD  R23,Y+3
003fce 9508      	RET
                 
                 __GETD2S0:
003fcf 81a8      	LD   R26,Y
003fd0 81b9      	LDD  R27,Y+1
003fd1 818a      	LDD  R24,Y+2
003fd2 819b      	LDD  R25,Y+3
003fd3 9508      	RET
                 
                 __PUTD1S0:
003fd4 83e8      	ST   Y,R30
003fd5 83f9      	STD  Y+1,R31
003fd6 836a      	STD  Y+2,R22
003fd7 837b      	STD  Y+3,R23
003fd8 9508      	RET
                 
                 __PUTPARD1:
003fd9 937a      	ST   -Y,R23
003fda 936a      	ST   -Y,R22
003fdb 93fa      	ST   -Y,R31
003fdc 93ea      	ST   -Y,R30
003fdd 9508      	RET
                 
                 __CPD10:
003fde 9730      	SBIW R30,0
003fdf 4060      	SBCI R22,0
003fe0 4070      	SBCI R23,0
003fe1 9508      	RET
                 
                 __CPD21:
003fe2 17ae      	CP   R26,R30
003fe3 07bf      	CPC  R27,R31
003fe4 0786      	CPC  R24,R22
003fe5 0797      	CPC  R25,R23
003fe6 9508      	RET
                 
                 __SAVELOCR6:
003fe7 935a      	ST   -Y,R21
                 __SAVELOCR5:
003fe8 934a      	ST   -Y,R20
                 __SAVELOCR4:
003fe9 933a      	ST   -Y,R19
                 __SAVELOCR3:
003fea 932a      	ST   -Y,R18
                 __SAVELOCR2:
003feb 931a      	ST   -Y,R17
003fec 930a      	ST   -Y,R16
003fed 9508      	RET
                 
                 __LOADLOCR6:
003fee 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
003fef 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
003ff0 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
003ff1 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
003ff2 8119      	LDD  R17,Y+1
003ff3 8108      	LD   R16,Y
003ff4 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  34 r1 :   9 r2 :   0 r3 :   0 r4 :   4 r5 :   0 r6 :   3 r7 :   1 
r8 :   5 r9 :   2 r10:   5 r11:   2 r12:   2 r13:   1 r14:   0 r15:   0 
r16:  34 r17:  55 r18:  37 r19:  32 r20:   5 r21:   9 r22:  93 r23:  62 
r24:  43 r25:  25 r26: 182 r27:  83 r28:  12 r29:   1 r30: 443 r31: 147 
x  :  34 y  : 192 z  :   7 
Registers used: 30 out of 35 (85.7%)

ATmega328P instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  18 add   :  21 
adiw  :  20 and   :   0 andi  :   9 asr   :   0 bclr  :   0 bld   :   0 
brbc  :   0 brbs  :   0 brcc  :   0 brcs  :   0 break :   0 breq  :  34 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :  10 
brlt  :   0 brmi  :   1 brne  :  29 brpl  :   0 brsh  :  23 brtc  :   0 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 call  : 115 
cbi   :  17 cbr   :   0 clc   :   0 clh   :   0 cli   :   2 cln   :   0 
clr   :  16 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   0 
cp    :   8 cpc   :  32 cpi   :  57 cpse  :   0 dec   :   4 des   :   0 
eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   0 
in    :  24 inc   :   0 jmp   :  34 ld    :  28 ldd   :  87 ldi   : 263 
lds   :  90 lpm   :   7 lsl   :   9 lsr   :   1 mov   :  32 movw  :  42 
mul   :  14 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :  13 
ori   :   8 out   :  21 pop   :  10 push  :  10 rcall :  86 ret   :  59 
reti  :   0 rjmp  : 104 rol   :  14 ror   :   3 sbc   :   1 sbci  :  38 
sbi   :  22 sbic  :   1 sbis  :   9 sbiw  :  14 sbr   :   0 sbrc  :  17 
sbrs  :   1 sec   :   0 seh   :   0 sei   :   0 sen   :   0 ser   :   0 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :  20 
st    :  92 std   :  19 sts   :  66 sub   :   0 subi  :  34 swap  :   0 
tst   :   3 wdr   :   1 
Instructions used: 56 out of 116 (48.3%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x007000 0x007fea   4022     52   4074   32768  12.4%
[.dseg] 0x000100 0x0005ce      0    718    718    2048  35.1%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 10 warnings
