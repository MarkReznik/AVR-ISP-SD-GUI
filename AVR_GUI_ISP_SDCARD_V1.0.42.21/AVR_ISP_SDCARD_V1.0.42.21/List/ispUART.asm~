
;CodeVisionAVR C Compiler V3.12 Advanced
;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com

;Build configuration    : Release
;Chip type              : ATmega328P
;Program type           : Application
;Clock frequency        : 12.000000 MHz
;Memory model           : Small
;Optimize for           : Size
;(s)printf features     : long, width
;(s)scanf features      : int, width
;External RAM size      : 0
;Data Stack size        : 512 byte(s)
;Heap size              : 0 byte(s)
;Promote 'char' to 'int': Yes
;'char' is unsigned     : No
;8 bit enums            : Yes
;Global 'const' stored in FLASH: Yes
;Enhanced function parameter passing: No
;Enhanced core instructions: On
;Automatic register allocation for global variables: On
;Smart register allocation: On

	#define _MODEL_SMALL_

	#pragma AVRPART ADMIN PART_NAME ATmega328P
	#pragma AVRPART MEMORY PROG_FLASH 32768
	#pragma AVRPART MEMORY EEPROM 1024
	#pragma AVRPART MEMORY INT_SRAM SIZE 2048
	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100

	#define CALL_SUPPORTED 1

	.LISTMAC
	.EQU EERE=0x0
	.EQU EEWE=0x1
	.EQU EEMWE=0x2
	.EQU UDRE=0x5
	.EQU RXC=0x7
	.EQU EECR=0x1F
	.EQU EEDR=0x20
	.EQU EEARL=0x21
	.EQU EEARH=0x22
	.EQU SPSR=0x2D
	.EQU SPDR=0x2E
	.EQU SMCR=0x33
	.EQU MCUSR=0x34
	.EQU MCUCR=0x35
	.EQU WDTCSR=0x60
	.EQU UCSR0A=0xC0
	.EQU UDR0=0xC6
	.EQU SPL=0x3D
	.EQU SPH=0x3E
	.EQU SREG=0x3F
	.EQU GPIOR0=0x1E

	.DEF R0X0=R0
	.DEF R0X1=R1
	.DEF R0X2=R2
	.DEF R0X3=R3
	.DEF R0X4=R4
	.DEF R0X5=R5
	.DEF R0X6=R6
	.DEF R0X7=R7
	.DEF R0X8=R8
	.DEF R0X9=R9
	.DEF R0XA=R10
	.DEF R0XB=R11
	.DEF R0XC=R12
	.DEF R0XD=R13
	.DEF R0XE=R14
	.DEF R0XF=R15
	.DEF R0X10=R16
	.DEF R0X11=R17
	.DEF R0X12=R18
	.DEF R0X13=R19
	.DEF R0X14=R20
	.DEF R0X15=R21
	.DEF R0X16=R22
	.DEF R0X17=R23
	.DEF R0X18=R24
	.DEF R0X19=R25
	.DEF R0X1A=R26
	.DEF R0X1B=R27
	.DEF R0X1C=R28
	.DEF R0X1D=R29
	.DEF R0X1E=R30
	.DEF R0X1F=R31

	.EQU __SRAM_START=0x0100
	.EQU __SRAM_END=0x08FF
	.EQU __DSTACK_SIZE=0x0200
	.EQU __HEAP_SIZE=0x0000
	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1

	.MACRO __CPD1N
	CPI  R30,LOW(@0)
	LDI  R26,HIGH(@0)
	CPC  R31,R26
	LDI  R26,BYTE3(@0)
	CPC  R22,R26
	LDI  R26,BYTE4(@0)
	CPC  R23,R26
	.ENDM

	.MACRO __CPD2N
	CPI  R26,LOW(@0)
	LDI  R30,HIGH(@0)
	CPC  R27,R30
	LDI  R30,BYTE3(@0)
	CPC  R24,R30
	LDI  R30,BYTE4(@0)
	CPC  R25,R30
	.ENDM

	.MACRO __CPWRR
	CP   R@0,R@2
	CPC  R@1,R@3
	.ENDM

	.MACRO __CPWRN
	CPI  R@0,LOW(@2)
	LDI  R30,HIGH(@2)
	CPC  R@1,R30
	.ENDM

	.MACRO __ADDB1MN
	SUBI R30,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDB2MN
	SUBI R26,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDW1MN
	SUBI R30,LOW(-@0-(@1))
	SBCI R31,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW2MN
	SUBI R26,LOW(-@0-(@1))
	SBCI R27,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	SBCI R22,BYTE3(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1N
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	SBCI R23,BYTE4(-@0)
	.ENDM

	.MACRO __ADDD2N
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	SBCI R24,BYTE3(-@0)
	SBCI R25,BYTE4(-@0)
	.ENDM

	.MACRO __SUBD1N
	SUBI R30,LOW(@0)
	SBCI R31,HIGH(@0)
	SBCI R22,BYTE3(@0)
	SBCI R23,BYTE4(@0)
	.ENDM

	.MACRO __SUBD2N
	SUBI R26,LOW(@0)
	SBCI R27,HIGH(@0)
	SBCI R24,BYTE3(@0)
	SBCI R25,BYTE4(@0)
	.ENDM

	.MACRO __ANDBMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ANDWMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ANDI R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ANDD1N
	ANDI R30,LOW(@0)
	ANDI R31,HIGH(@0)
	ANDI R22,BYTE3(@0)
	ANDI R23,BYTE4(@0)
	.ENDM

	.MACRO __ANDD2N
	ANDI R26,LOW(@0)
	ANDI R27,HIGH(@0)
	ANDI R24,BYTE3(@0)
	ANDI R25,BYTE4(@0)
	.ENDM

	.MACRO __ORBMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ORWMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ORI  R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ORD1N
	ORI  R30,LOW(@0)
	ORI  R31,HIGH(@0)
	ORI  R22,BYTE3(@0)
	ORI  R23,BYTE4(@0)
	.ENDM

	.MACRO __ORD2N
	ORI  R26,LOW(@0)
	ORI  R27,HIGH(@0)
	ORI  R24,BYTE3(@0)
	ORI  R25,BYTE4(@0)
	.ENDM

	.MACRO __DELAY_USB
	LDI  R24,LOW(@0)
__DELAY_USB_LOOP:
	DEC  R24
	BRNE __DELAY_USB_LOOP
	.ENDM

	.MACRO __DELAY_USW
	LDI  R24,LOW(@0)
	LDI  R25,HIGH(@0)
__DELAY_USW_LOOP:
	SBIW R24,1
	BRNE __DELAY_USW_LOOP
	.ENDM

	.MACRO __GETD1S
	LDD  R30,Y+@0
	LDD  R31,Y+@0+1
	LDD  R22,Y+@0+2
	LDD  R23,Y+@0+3
	.ENDM

	.MACRO __GETD2S
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	LDD  R24,Y+@0+2
	LDD  R25,Y+@0+3
	.ENDM

	.MACRO __PUTD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R31
	STD  Y+@0+2,R22
	STD  Y+@0+3,R23
	.ENDM

	.MACRO __PUTD2S
	STD  Y+@0,R26
	STD  Y+@0+1,R27
	STD  Y+@0+2,R24
	STD  Y+@0+3,R25
	.ENDM

	.MACRO __PUTDZ2
	STD  Z+@0,R26
	STD  Z+@0+1,R27
	STD  Z+@0+2,R24
	STD  Z+@0+3,R25
	.ENDM

	.MACRO __CLRD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R30
	STD  Y+@0+2,R30
	STD  Y+@0+3,R30
	.ENDM

	.MACRO __POINTB1MN
	LDI  R30,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW1MN
	LDI  R30,LOW(@0+(@1))
	LDI  R31,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTD1M
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __POINTW1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	LDI  R23,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTB2MN
	LDI  R26,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW2MN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTW2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	LDI  R24,BYTE3(2*@0+(@1))
	LDI  R25,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTBRM
	LDI  R@0,LOW(@1)
	.ENDM

	.MACRO __POINTWRM
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __POINTBRMN
	LDI  R@0,LOW(@1+(@2))
	.ENDM

	.MACRO __POINTWRMN
	LDI  R@0,LOW(@2+(@3))
	LDI  R@1,HIGH(@2+(@3))
	.ENDM

	.MACRO __POINTWRFN
	LDI  R@0,LOW(@2*2+(@3))
	LDI  R@1,HIGH(@2*2+(@3))
	.ENDM

	.MACRO __GETD1N
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __GETD2N
	LDI  R26,LOW(@0)
	LDI  R27,HIGH(@0)
	LDI  R24,BYTE3(@0)
	LDI  R25,BYTE4(@0)
	.ENDM

	.MACRO __GETB1MN
	LDS  R30,@0+(@1)
	.ENDM

	.MACRO __GETB1HMN
	LDS  R31,@0+(@1)
	.ENDM

	.MACRO __GETW1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	.ENDM

	.MACRO __GETD1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	LDS  R23,@0+(@1)+3
	.ENDM

	.MACRO __GETBRMN
	LDS  R@0,@1+(@2)
	.ENDM

	.MACRO __GETWRMN
	LDS  R@0,@2+(@3)
	LDS  R@1,@2+(@3)+1
	.ENDM

	.MACRO __GETWRZ
	LDD  R@0,Z+@2
	LDD  R@1,Z+@2+1
	.ENDM

	.MACRO __GETD2Z
	LDD  R26,Z+@0
	LDD  R27,Z+@0+1
	LDD  R24,Z+@0+2
	LDD  R25,Z+@0+3
	.ENDM

	.MACRO __GETB2MN
	LDS  R26,@0+(@1)
	.ENDM

	.MACRO __GETW2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	.ENDM

	.MACRO __GETD2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	LDS  R24,@0+(@1)+2
	LDS  R25,@0+(@1)+3
	.ENDM

	.MACRO __PUTB1MN
	STS  @0+(@1),R30
	.ENDM

	.MACRO __PUTW1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	.ENDM

	.MACRO __PUTD1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	STS  @0+(@1)+2,R22
	STS  @0+(@1)+3,R23
	.ENDM

	.MACRO __PUTB1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRB
	.ENDM

	.MACRO __PUTW1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRW
	.ENDM

	.MACRO __PUTD1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRD
	.ENDM

	.MACRO __PUTBR0MN
	STS  @0+(@1),R0
	.ENDM

	.MACRO __PUTBMRN
	STS  @0+(@1),R@2
	.ENDM

	.MACRO __PUTWMRN
	STS  @0+(@1),R@2
	STS  @0+(@1)+1,R@3
	.ENDM

	.MACRO __PUTBZR
	STD  Z+@1,R@0
	.ENDM

	.MACRO __PUTWZR
	STD  Z+@2,R@0
	STD  Z+@2+1,R@1
	.ENDM

	.MACRO __GETW1R
	MOV  R30,R@0
	MOV  R31,R@1
	.ENDM

	.MACRO __GETW2R
	MOV  R26,R@0
	MOV  R27,R@1
	.ENDM

	.MACRO __GETWRN
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __PUTW1R
	MOV  R@0,R30
	MOV  R@1,R31
	.ENDM

	.MACRO __PUTW2R
	MOV  R@0,R26
	MOV  R@1,R27
	.ENDM

	.MACRO __ADDWRN
	SUBI R@0,LOW(-@2)
	SBCI R@1,HIGH(-@2)
	.ENDM

	.MACRO __ADDWRR
	ADD  R@0,R@2
	ADC  R@1,R@3
	.ENDM

	.MACRO __SUBWRN
	SUBI R@0,LOW(@2)
	SBCI R@1,HIGH(@2)
	.ENDM

	.MACRO __SUBWRR
	SUB  R@0,R@2
	SBC  R@1,R@3
	.ENDM

	.MACRO __ANDWRN
	ANDI R@0,LOW(@2)
	ANDI R@1,HIGH(@2)
	.ENDM

	.MACRO __ANDWRR
	AND  R@0,R@2
	AND  R@1,R@3
	.ENDM

	.MACRO __ORWRN
	ORI  R@0,LOW(@2)
	ORI  R@1,HIGH(@2)
	.ENDM

	.MACRO __ORWRR
	OR   R@0,R@2
	OR   R@1,R@3
	.ENDM

	.MACRO __EORWRR
	EOR  R@0,R@2
	EOR  R@1,R@3
	.ENDM

	.MACRO __GETWRS
	LDD  R@0,Y+@2
	LDD  R@1,Y+@2+1
	.ENDM

	.MACRO __PUTBSR
	STD  Y+@1,R@0
	.ENDM

	.MACRO __PUTWSR
	STD  Y+@2,R@0
	STD  Y+@2+1,R@1
	.ENDM

	.MACRO __MOVEWRR
	MOV  R@0,R@2
	MOV  R@1,R@3
	.ENDM

	.MACRO __INWR
	IN   R@0,@2
	IN   R@1,@2+1
	.ENDM

	.MACRO __OUTWR
	OUT  @2+1,R@1
	OUT  @2,R@0
	.ENDM

	.MACRO __CALL1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	ICALL
	.ENDM

	.MACRO __CALL1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	CALL __GETW1PF
	ICALL
	.ENDM

	.MACRO __CALL2EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMRDW
	ICALL
	.ENDM

	.MACRO __CALL2EX
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	CALL __EEPROMRDD
	ICALL
	.ENDM

	.MACRO __GETW1STACK
	IN   R30,SPL
	IN   R31,SPH
	ADIW R30,@0+1
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1STACK
	IN   R30,SPL
	IN   R31,SPH
	ADIW R30,@0+1
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z
	MOVW R30,R0
	.ENDM

	.MACRO __NBST
	BST  R@0,@1
	IN   R30,SREG
	LDI  R31,0x40
	EOR  R30,R31
	OUT  SREG,R30
	.ENDM


	.MACRO __PUTB1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RNS
	MOVW R26,R@0
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	CALL __PUTDP1
	.ENDM


	.MACRO __GETB1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R30,Z
	.ENDM

	.MACRO __GETB1HSX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	.ENDM

	.MACRO __GETW1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z+
	LD   R23,Z
	MOVW R30,R0
	.ENDM

	.MACRO __GETB2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R26,X
	.ENDM

	.MACRO __GETW2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	.ENDM

	.MACRO __GETD2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R1,X+
	LD   R24,X+
	LD   R25,X
	MOVW R26,R0
	.ENDM

	.MACRO __GETBRSX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	LD   R@0,Z
	.ENDM

	.MACRO __GETWRSX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	LD   R@0,Z+
	LD   R@1,Z
	.ENDM

	.MACRO __GETBRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	LD   R@0,X
	.ENDM

	.MACRO __GETWRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	LD   R@0,X+
	LD   R@1,X
	.ENDM

	.MACRO __LSLW8SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	CLR  R30
	.ENDM

	.MACRO __PUTB1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __CLRW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __CLRD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R30
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __PUTB2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R26
	.ENDM

	.MACRO __PUTW2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z,R27
	.ENDM

	.MACRO __PUTD2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z+,R27
	ST   Z+,R24
	ST   Z,R25
	.ENDM

	.MACRO __PUTBSRX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	ST   Z,R@0
	.ENDM

	.MACRO __PUTWSRX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	ST   Z+,R@0
	ST   Z,R@1
	.ENDM

	.MACRO __PUTB1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __MULBRR
	MULS R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRRU
	MUL  R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRR0
	MULS R@0,R@1
	.ENDM

	.MACRO __MULBRRU0
	MUL  R@0,R@1
	.ENDM

	.MACRO __MULBNWRU
	LDI  R26,@2
	MUL  R26,R@0
	MOVW R30,R0
	MUL  R26,R@1
	ADD  R31,R0
	.ENDM

;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
	.DEF _rx_wr_index=R5
	.DEF _rx_rd_index=R4
	.DEF _rx_counter=R7
	.DEF _tx_wr_index=R6
	.DEF _tx_rd_index=R9
	.DEF _Buttons=R8
	.DEF _CurrentButton=R11
	.DEF _g_IsFuseClock=R10
	.DEF _g_DeviceCode=R13
	.DEF _g_MemType=R12

;GPIOR0 INITIALIZATION VALUE
	.EQU __GPIOR0_INIT=0x00

	.CSEG
	.ORG 0x00

;START OF CODE MARKER
__START_OF_CODE:

;INTERRUPT VECTORS
	JMP  __RESET
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer_comp_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _usart_rx_isr
	JMP  0x00
	JMP  _usart_tx_isr
	JMP  _adc_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00

_DeviceDesc:
	.DB  0x13,0xFF,0x20,0x7F,0x28,0x7F,0x30,0xFF
	.DB  0x34,0xFF,0x38,0x7F,0x48,0xFF,0x4C,0xFF
	.DB  0x51,0xFF,0x55,0xFF,0x56,0xFF,0x68,0xFF
	.DB  0x6C,0xFF,0x86,0xFF,0x87,0xFF,0x1,0x40
	.DB  0x4,0x40,0x5,0x40,0x6,0x40,0x7,0x40
	.DB  0x8,0x40,0x9,0x40,0xE,0x10,0x1A,0x10
	.DB  0xF,0x20,0x1B,0x20,0x14,0x20,0x1C,0x20
	.DB  0x1D,0x40,0x23,0x10,0x31,0x20,0x33,0x20
	.DB  0x35,0x40,0x37,0x40,0x39,0x40,0x3D,0x40
	.DB  0x3E,0x40,0x57,0x10,0x3A,0x20,0x41,0x40
	.DB  0x43,0x80,0x45,0x80,0x5E,0x10,0x60,0x40
	.DB  0x62,0x40,0x64,0x40,0x69,0x20,0x72,0x40
	.DB  0x74,0x40,0x76,0x20,0x78,0x40,0x0
_SwID:
	.DB  0x41,0x56,0x52,0x20,0x49,0x53,0x50,0x0
_roll:
	.DB  0xE9,0x79,0x25,0x54,0x88,0xDF,0xA5,0xB9
	.DB  0xF6,0xC2,0xAB,0xFC,0xB3,0xB1,0x37,0xE1
	.DB  0x83,0xD5,0x97,0x4,0x38,0xFE,0x99,0x26
	.DB  0xE4,0x8E,0x4B,0xF7,0x4,0xC5,0xA5,0x1F
	.DB  0x88,0x68,0xEF,0x1D,0x39,0xBC,0x62,0xD8
	.DB  0x63,0xF,0x6A,0xA5,0x12,0xAA,0xE5,0x8C
	.DB  0x75,0x36,0xBA,0x81,0x8F,0x30,0x3D,0xEB
	.DB  0xE0,0xFE,0x70,0xFA,0x94,0xAE,0xB5,0x31
_error_msg:
	.DB  LOW(_0x60000*2),HIGH(_0x60000*2),LOW(_0x60000*2+1),HIGH(_0x60000*2+1),LOW(_0x60000*2+13),HIGH(_0x60000*2+13),LOW(_0x60000*2+24),HIGH(_0x60000*2+24)
	.DB  LOW(_0x60000*2+37),HIGH(_0x60000*2+37),LOW(_0x60000*2+48),HIGH(_0x60000*2+48),LOW(_0x60000*2+59),HIGH(_0x60000*2+59),LOW(_0x60000*2+75),HIGH(_0x60000*2+75)
	.DB  LOW(_0x60000*2+85),HIGH(_0x60000*2+85),LOW(_0x60000*2+94),HIGH(_0x60000*2+94),LOW(_0x60000*2+112),HIGH(_0x60000*2+112),LOW(_0x60000*2+131),HIGH(_0x60000*2+131)
	.DB  LOW(_0x60000*2+148),HIGH(_0x60000*2+148),LOW(_0x60000*2+163),HIGH(_0x60000*2+163),LOW(_0x60000*2+180),HIGH(_0x60000*2+180),LOW(_0x60000*2+196),HIGH(_0x60000*2+196)
_cvt_G005:
	.DB  0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80
	.DB  0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F
	.DB  0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55
	.DB  0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F
	.DB  0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7
	.DB  0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF
	.DB  0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7
	.DB  0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF
	.DB  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
	.DB  0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF
	.DB  0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7
	.DB  0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF
	.DB  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7
	.DB  0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF
	.DB  0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7
	.DB  0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF

;GLOBAL REGISTER VARIABLES INITIALIZATION
__REG_VARS:
	.DB  0x5

_0x0:
	.DB  0x49,0x6E,0x69,0x74,0x20,0x64,0x6F,0x6E
	.DB  0x65,0x2E,0x20,0x43,0x75,0x72,0x72,0x65
	.DB  0x6E,0x74,0x20,0x66,0x6F,0x6C,0x64,0x65
	.DB  0x72,0x20,0x69,0x73,0x20,0x25,0x64,0x2E
	.DB  0xD,0xA,0x0,0x41,0x56,0x52,0x20,0x49
	.DB  0x53,0x50,0x20,0x53,0x44,0x20,0x56,0x0
	.DB  0x32,0x33,0x61,0x0,0x2E,0x0,0x50,0x72
	.DB  0x65,0x73,0x73,0x20,0x53,0x74,0x6F,0x70
	.DB  0x0,0x4C,0x69,0x73,0x74,0x20,0x4C,0x6F
	.DB  0x63,0x6B,0x65,0x64,0x0,0x43,0x75,0x72
	.DB  0x72,0x65,0x6E,0x74,0x20,0x46,0x6F,0x6C
	.DB  0x64,0x65,0x72,0x20,0x25,0x64,0xD,0xA
	.DB  0x0,0x50,0x72,0x6F,0x67,0x72,0x61,0x6D
	.DB  0x6D,0x69,0x6E,0x67,0x20,0x2E,0x2E,0x2E
	.DB  0x2E,0x0,0x4C,0x69,0x73,0x74,0x20,0x55
	.DB  0x6E,0x6C,0x6F,0x63,0x6B,0x65,0x64,0x0
	.DB  0x52,0x65,0x61,0x64,0x20,0x66,0x6F,0x6C
	.DB  0x64,0x65,0x72,0x20,0x0,0x30,0x0,0x20
	.DB  0x6F,0x66,0x20,0x0,0x46,0x69,0x6C,0x65
	.DB  0x20,0x0,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x2E,0x0,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x0
_0x20000:
	.DB  0x72,0x65,0x61,0x64,0x79,0x0,0xD,0xA
	.DB  0x52,0x65,0x62,0x6F,0x6F,0x74,0x69,0x6E
	.DB  0x67,0x20,0x74,0x6F,0x20,0x62,0x6F,0x6F
	.DB  0x74,0x6C,0x61,0x64,0x65,0x72,0x2E,0x2E
	.DB  0x2E,0x0
_0x40000:
	.DB  0xD,0xA,0x45,0x72,0x72,0x6F,0x72,0x2E
	.DB  0x66,0x70,0x74,0x72,0x3D,0x25,0x75,0x2C
	.DB  0x62,0x75,0x66,0x5B,0x30,0x5D,0x3D,0x25
	.DB  0x30,0x32,0x78,0x2C,0x62,0x75,0x66,0x5B
	.DB  0x31,0x5D,0x3D,0x25,0x30,0x32,0x78,0xD
	.DB  0xA,0x0,0xD,0xA,0x42,0x61,0x64,0x20
	.DB  0x68,0x65,0x78,0x3D,0x25,0x30,0x32,0x78
	.DB  0xD,0xA,0x0,0x42,0x61,0x64,0x20,0x68
	.DB  0x65,0x78,0x20,0x64,0x69,0x67,0x69,0x74
	.DB  0x21,0x0,0xD,0xA,0x64,0x65,0x62,0x75
	.DB  0x67,0x3D,0x25,0x64,0x0,0xD,0xA,0x66
	.DB  0x69,0x6C,0x65,0x6E,0x61,0x6D,0x65,0x20
	.DB  0x3D,0x20,0x25,0x73,0x0,0xD,0xA,0x66
	.DB  0x77,0x5F,0x76,0x65,0x72,0x20,0x3D,0x20
	.DB  0x25,0x73,0x0,0xD,0xA,0x63,0x68,0x69
	.DB  0x70,0x6E,0x61,0x6D,0x65,0x20,0x3D,0x20
	.DB  0x25,0x73,0x0,0xD,0xA,0x63,0x68,0x69
	.DB  0x70,0x63,0x6F,0x64,0x65,0x20,0x3D,0x20
	.DB  0x30,0x78,0x25,0x78,0x0,0xD,0xA,0x73
	.DB  0x69,0x67,0x6E,0x61,0x74,0x75,0x72,0x65
	.DB  0x20,0x3D,0x20,0x25,0x30,0x32,0x78,0x20
	.DB  0x25,0x30,0x32,0x78,0x20,0x25,0x30,0x32
	.DB  0x78,0x0,0xD,0xA,0x70,0x72,0x6F,0x67
	.DB  0x66,0x75,0x73,0x65,0x73,0x20,0x3D,0x20
	.DB  0x25,0x30,0x32,0x78,0x20,0x25,0x30,0x32
	.DB  0x78,0x20,0x25,0x30,0x32,0x78,0x20,0x25
	.DB  0x30,0x32,0x78,0x0,0xD,0xA,0x6E,0x6F
	.DB  0x72,0x6D,0x66,0x75,0x73,0x65,0x73,0x20
	.DB  0x3D,0x20,0x25,0x30,0x32,0x78,0x20,0x25
	.DB  0x30,0x32,0x78,0x20,0x25,0x30,0x32,0x78
	.DB  0x20,0x25,0x30,0x32,0x78,0x0,0xD,0xA
	.DB  0x6D,0x61,0x73,0x6B,0x66,0x75,0x73,0x65
	.DB  0x73,0x20,0x3D,0x20,0x25,0x30,0x32,0x78
	.DB  0x20,0x25,0x30,0x32,0x78,0x20,0x25,0x30
	.DB  0x32,0x78,0x20,0x25,0x30,0x32,0x78,0x0
	.DB  0xD,0xA,0x63,0x68,0x69,0x70,0x73,0x69
	.DB  0x7A,0x65,0x20,0x3D,0x20,0x25,0x6C,0x75
	.DB  0x0,0xD,0xA,0x70,0x61,0x67,0x65,0x73
	.DB  0x69,0x7A,0x65,0x20,0x3D,0x20,0x25,0x75
	.DB  0x0,0xD,0xA,0x50,0x72,0x6F,0x67,0x72
	.DB  0x61,0x6D,0x6D,0x69,0x6E,0x67,0x20,0x44
	.DB  0x6F,0x6E,0x65,0x20,0x3D,0x20,0x25,0x6C
	.DB  0x75,0x0,0xD,0xA,0x50,0x72,0x6F,0x67
	.DB  0x72,0x61,0x6D,0x6D,0x69,0x6E,0x67,0x20
	.DB  0x41,0x76,0x61,0x69,0x6C,0x61,0x62,0x6C
	.DB  0x65,0x20,0x3D,0x20,0x25,0x6C,0x75,0x0
	.DB  0xD,0xA,0x53,0x74,0x61,0x72,0x74,0x69
	.DB  0x6E,0x67,0x20,0x50,0x72,0x6F,0x67,0x72
	.DB  0x61,0x6D,0x20,0x4D,0x6F,0x64,0x65,0x2E
	.DB  0x2E,0x2E,0x20,0x0,0x50,0x72,0x6F,0x67
	.DB  0x20,0x4D,0x6F,0x64,0x65,0x20,0x0,0x50
	.DB  0x0,0x46,0x41,0x49,0x4C,0x0,0x4E,0x6F
	.DB  0x20,0x74,0x61,0x72,0x67,0x65,0x74,0x0
	.DB  0x20,0x4F,0x4B,0x2E,0x0,0x44,0x6F,0x6E
	.DB  0x65,0x0,0xD,0xA,0x43,0x61,0x6C,0x6C
	.DB  0x20,0x73,0x64,0x5F,0x6D,0x6F,0x75,0x6E
	.DB  0x74,0x20,0x66,0x75,0x6E,0x63,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0x20,0xD,0xA
	.DB  0x0,0xD,0xA,0x43,0x61,0x6C,0x6C,0x20
	.DB  0x73,0x64,0x5F,0x6D,0x6F,0x75,0x6E,0x74
	.DB  0x20,0x66,0x75,0x6E,0x63,0x20,0x6F,0x6B
	.DB  0x20,0xD,0xA,0x0,0x75,0x70,0x0,0x64
	.DB  0x6F,0x77,0x6E,0x0,0x6D,0x61,0x78,0x66
	.DB  0x6F,0x6C,0x64,0x65,0x72,0x73,0x0,0xD
	.DB  0xA,0x63,0x6F,0x6E,0x66,0x69,0x67,0x3A
	.DB  0x20,0x55,0x70,0x3D,0x25,0x64,0x20,0x44
	.DB  0x6F,0x77,0x6E,0x3D,0x25,0x64,0x20,0x4D
	.DB  0x61,0x78,0x46,0x6F,0x6C,0x64,0x65,0x72
	.DB  0x73,0x3D,0x25,0x64,0x0,0x72,0x6F,0x6C
	.DB  0x6C,0x63,0x6F,0x75,0x6E,0x74,0x65,0x72
	.DB  0x0,0xD,0xA,0x62,0x75,0x66,0x66,0x65
	.DB  0x72,0xD,0xA,0x25,0x73,0x0,0x70,0x72
	.DB  0x6F,0x67,0x63,0x6F,0x75,0x6E,0x74,0x65
	.DB  0x72,0x72,0x65,0x73,0x65,0x74,0x0,0xD
	.DB  0xA,0x52,0x65,0x73,0x65,0x74,0x20,0x70
	.DB  0x72,0x6F,0x67,0x20,0x63,0x6F,0x75,0x6E
	.DB  0x74,0x65,0x72,0x20,0x64,0x6F,0x6E,0x65
	.DB  0x2E,0xD,0xA,0x0,0x6D,0x61,0x78,0x70
	.DB  0x72,0x6F,0x67,0x73,0x0,0x70,0x61,0x67
	.DB  0x65,0x73,0x69,0x7A,0x65,0x0,0x63,0x68
	.DB  0x69,0x70,0x73,0x69,0x7A,0x65,0x0,0x6D
	.DB  0x61,0x73,0x6B,0x66,0x75,0x73,0x65,0x73
	.DB  0x0,0x6E,0x6F,0x72,0x6D,0x66,0x75,0x73
	.DB  0x65,0x73,0x0,0x70,0x72,0x6F,0x67,0x66
	.DB  0x75,0x73,0x65,0x73,0x0,0x73,0x69,0x67
	.DB  0x6E,0x61,0x74,0x75,0x72,0x65,0x0,0x73
	.DB  0x70,0x69,0x64,0x69,0x76,0x0,0x70,0x72
	.DB  0x6F,0x67,0x69,0x6E,0x66,0x6F,0x0,0x70
	.DB  0x72,0x6F,0x67,0x6E,0x61,0x6D,0x65,0x0
	.DB  0xD,0xA,0x70,0x72,0x6F,0x67,0x69,0x6E
	.DB  0x66,0x6F,0x3D,0x25,0x73,0x0,0xD,0xA
	.DB  0x73,0x70,0x69,0x64,0x69,0x76,0x3D,0x25
	.DB  0x64,0x0,0xD,0xA,0x54,0x61,0x72,0x67
	.DB  0x65,0x74,0x20,0x73,0x69,0x67,0x6E,0x61
	.DB  0x74,0x75,0x72,0x65,0x20,0x69,0x73,0x3A
	.DB  0x20,0x25,0x30,0x32,0x78,0x20,0x25,0x30
	.DB  0x32,0x78,0x20,0x25,0x30,0x32,0x78,0x0
	.DB  0x20,0x74,0x61,0x72,0x67,0x65,0x74,0x20
	.DB  0x6E,0x6F,0x74,0x20,0x63,0x6F,0x6E,0x6E
	.DB  0x65,0x63,0x74,0x65,0x64,0xD,0xA,0x0
	.DB  0x57,0x72,0x6F,0x6E,0x67,0x20,0x74,0x61
	.DB  0x72,0x67,0x65,0x74,0x0,0xD,0xA,0x52
	.DB  0x65,0x61,0x64,0x69,0x6E,0x67,0x20,0x73
	.DB  0x69,0x67,0x6E,0x61,0x74,0x75,0x72,0x65
	.DB  0x3A,0x20,0x4F,0x4B,0x2E,0x0,0x53,0x69
	.DB  0x67,0x6E,0x61,0x74,0x75,0x72,0x65,0x20
	.DB  0x4F,0x4B,0x2E,0x0,0xD,0xA,0x45,0x72
	.DB  0x61,0x73,0x69,0x6E,0x67,0x20,0x70,0x6C
	.DB  0x65,0x61,0x73,0x65,0x20,0x77,0x61,0x69
	.DB  0x74,0x2E,0x2E,0x2E,0x20,0x0,0x45,0x72
	.DB  0x61,0x73,0x69,0x6E,0x67,0x2E,0x2E,0x2E
	.DB  0x20,0x0,0x44,0x6F,0x6E,0x65,0x2E,0x0
	.DB  0xD,0xA,0x50,0x72,0x6F,0x67,0x72,0x61
	.DB  0x6D,0x20,0x46,0x75,0x73,0x65,0x73,0x20
	.DB  0x66,0x61,0x69,0x6C,0x0,0x50,0x72,0x6F
	.DB  0x67,0x20,0x46,0x75,0x73,0x65,0x73,0x20
	.DB  0x66,0x61,0x69,0x6C,0x0,0xD,0xA,0x46
	.DB  0x61,0x69,0x6C,0x65,0x64,0x20,0x74,0x6F
	.DB  0x20,0x76,0x65,0x72,0x69,0x66,0x79,0x20
	.DB  0x66,0x75,0x73,0x65,0x73,0x0,0x43,0x68
	.DB  0x65,0x63,0x6B,0x20,0x46,0x75,0x73,0x65
	.DB  0x73,0x20,0x66,0x61,0x69,0x6C,0x0,0xD
	.DB  0xA,0x50,0x72,0x6F,0x67,0x72,0x61,0x6D
	.DB  0x20,0x46,0x75,0x73,0x65,0x73,0x20,0x56
	.DB  0x65,0x72,0x69,0x66,0x69,0x65,0x64,0x20
	.DB  0x4F,0x4B,0x2E,0x0,0xD,0xA,0x53,0x65
	.DB  0x74,0x41,0x64,0x64,0x72,0x20,0x46,0x41
	.DB  0x49,0x4C,0x0,0xD,0xA,0x57,0x72,0x69
	.DB  0x74,0x69,0x6E,0x67,0x20,0x66,0x6C,0x61
	.DB  0x73,0x68,0x2E,0x2E,0x2E,0x0,0xD,0xA
	.DB  0x41,0x66,0x74,0x65,0x72,0x20,0x66,0x69
	.DB  0x6C,0x65,0x4F,0x70,0x65,0x6E,0xD,0xA
	.DB  0x0,0xD,0xA,0x41,0x66,0x74,0x65,0x72
	.DB  0x20,0x73,0x65,0x74,0x20,0x61,0x64,0x72
	.DB  0x20,0x31,0x30,0x30,0x30,0xD,0xA,0x0
	.DB  0xD,0xA,0x46,0x6C,0x61,0x73,0x68,0x20
	.DB  0x70,0x72,0x6F,0x67,0x72,0x61,0x6D,0x6D
	.DB  0x69,0x6E,0x67,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0x0,0x20,0x44,0x6F,0x6E,0x65
	.DB  0x2E,0x0,0xD,0xA,0x53,0x74,0x61,0x72
	.DB  0x74,0x20,0x66,0x6C,0x61,0x73,0x68,0x69
	.DB  0x6E,0x67,0x20,0x66,0x72,0x6F,0x6D,0x20
	.DB  0x53,0x44,0x63,0x61,0x72,0x64,0x2E,0x2E
	.DB  0x2E,0xD,0xA,0x0,0xD,0xA,0x4C,0x69
	.DB  0x63,0x65,0x6E,0x73,0x65,0x73,0x20,0x54
	.DB  0x6F,0x74,0x61,0x6C,0x20,0x3D,0x20,0x25
	.DB  0x6C,0x75,0x20,0x2D,0x20,0x44,0x6F,0x6E
	.DB  0x65,0x20,0x3D,0x20,0x25,0x6C,0x75,0x0
	.DB  0x4E,0x6F,0x20,0x6C,0x69,0x63,0x65,0x6E
	.DB  0x73,0x65,0x73,0x0,0xD,0xA,0x56,0x65
	.DB  0x72,0x69,0x66,0x69,0x6E,0x67,0x20,0x66
	.DB  0x6C,0x61,0x73,0x68,0x2E,0x2E,0x2E,0x0
	.DB  0xD,0xA,0x46,0x61,0x69,0x6C,0x65,0x64
	.DB  0x20,0x74,0x6F,0x20,0x76,0x65,0x72,0x69
	.DB  0x66,0x79,0x20,0x63,0x68,0x69,0x70,0x0
	.DB  0x46,0x61,0x69,0x6C,0x65,0x64,0x20,0x74
	.DB  0x6F,0x20,0x76,0x65,0x72,0x69,0x66,0x79
	.DB  0x0,0x44,0x6F,0x6E,0x65,0x2E,0xD,0xA
	.DB  0x46,0x6C,0x61,0x73,0x68,0x20,0x76,0x65
	.DB  0x72,0x69,0x66,0x69,0x65,0x64,0x20,0x63
	.DB  0x6F,0x72,0x72,0x65,0x63,0x74,0x6C,0x79
	.DB  0x20,0x21,0x21,0x21,0x0,0xD,0xA,0x4E
	.DB  0x6F,0x72,0x6D,0x61,0x6C,0x20,0x46,0x75
	.DB  0x73,0x65,0x73,0x20,0x66,0x61,0x69,0x6C
	.DB  0x0,0xD,0xA,0x4E,0x6F,0x72,0x6D,0x61
	.DB  0x6C,0x20,0x66,0x75,0x73,0x65,0x73,0x20
	.DB  0x77,0x72,0x69,0x74,0x69,0x6E,0x67,0x20
	.DB  0x64,0x6F,0x6E,0x65,0x2E,0x0,0xD,0xA
	.DB  0x4E,0x6F,0x72,0x6D,0x61,0x6C,0x20,0x66
	.DB  0x75,0x73,0x65,0x73,0x20,0x76,0x65,0x72
	.DB  0x69,0x66,0x69,0x65,0x64,0x20,0x63,0x6F
	.DB  0x72,0x72,0x65,0x63,0x74,0x6C,0x79,0x20
	.DB  0x21,0x21,0x21,0x0,0xD,0xA,0x4C,0x65
	.DB  0x61,0x76,0x69,0x6E,0x67,0x20,0x70,0x72
	.DB  0x6F,0x67,0x72,0x61,0x6D,0x6D,0x69,0x6E
	.DB  0x67,0x20,0x6D,0x6F,0x64,0x65,0x2E,0x2E
	.DB  0x2E,0x20,0x0,0x20,0x4F,0x4B,0x2E,0xA
	.DB  0x0,0x46,0x61,0x69,0x6C,0x65,0x64,0x2E
	.DB  0x0,0xD,0xA,0x46,0x6C,0x61,0x73,0x68
	.DB  0x69,0x6E,0x67,0x20,0x66,0x72,0x6F,0x6D
	.DB  0x20,0x73,0x64,0x63,0x61,0x72,0x64,0x20
	.DB  0x46,0x61,0x69,0x6C,0x65,0x64,0x20,0x2E
	.DB  0xD,0xA,0x0,0xD,0xA,0x53,0x44,0x43
	.DB  0x41,0x52,0x44,0x20,0x46,0x61,0x69,0x6C
	.DB  0x65,0x64,0x20,0x2E,0xD,0xA,0x0,0x70
	.DB  0x72,0x6F,0x6A,0x65,0x63,0x74,0x2E,0x74
	.DB  0x78,0x74,0x20,0x66,0x69,0x6C,0x65,0x20
	.DB  0x6D,0x69,0x73,0x73,0x69,0x6E,0x67,0x20
	.DB  0x6F,0x72,0x20,0x63,0x6F,0x72,0x72,0x75
	.DB  0x70,0x74,0x65,0x64,0x2E,0xD,0xA,0x0
	.DB  0xD,0xA,0x46,0x6C,0x61,0x73,0x68,0x69
	.DB  0x6E,0x67,0x20,0x66,0x72,0x6F,0x6D,0x20
	.DB  0x73,0x64,0x63,0x61,0x72,0x64,0x20,0x50
	.DB  0x61,0x73,0x73,0x65,0x64,0x20,0x25,0x75
	.DB  0x2E,0xD,0xA,0x0,0x53,0x75,0x63,0x63
	.DB  0x65,0x73,0x73,0x21,0x20,0x20,0x0,0x42
	.DB  0x61,0x64,0x20,0x63,0x68,0x65,0x63,0x6B
	.DB  0x73,0x75,0x6D,0x3A,0x20,0x0,0x4E,0x6F
	.DB  0x20,0x65,0x6E,0x64,0x20,0x6F,0x66,0x20
	.DB  0x6C,0x69,0x6E,0x65,0x0,0x56,0x65,0x72
	.DB  0x69,0x66,0x69,0x6E,0x67,0x20,0x66,0x6C
	.DB  0x61,0x73,0x68,0x2E,0x2E,0x0,0x4E,0x6F
	.DB  0x20,0x63,0x6F,0x6C,0x6F,0x6E,0x0,0x76
	.DB  0x65,0x72,0x69,0x66,0x69,0x63,0x61,0x74
	.DB  0x69,0x6F,0x6E,0x20,0x65,0x72,0x72,0x6F
	.DB  0x72,0x20,0x61,0x74,0x20,0x61,0x64,0x64
	.DB  0x72,0x65,0x73,0x73,0x20,0x30,0x78,0x25
	.DB  0x58,0x0,0x20,0x53,0x68,0x6F,0x75,0x6C
	.DB  0x64,0x20,0x62,0x65,0x20,0x30,0x78,0x25
	.DB  0x58,0x0,0x20,0x6E,0x6F,0x74,0x20,0x30
	.DB  0x78,0x25,0x58,0x0,0x52,0x0,0xD,0xA
	.DB  0x30,0x3D,0x25,0x30,0x32,0x78,0x20,0x31
	.DB  0x3D,0x25,0x30,0x32,0x78,0x20,0x20,0xD
	.DB  0xA,0x0,0xD,0xA,0x53,0x65,0x74,0x74
	.DB  0x69,0x6E,0x67,0x20,0x66,0x75,0x73,0x65
	.DB  0x73,0x0,0xD,0xA,0x20,0x20,0x53,0x65
	.DB  0x74,0x20,0x4C,0x6F,0x77,0x20,0x46,0x75
	.DB  0x73,0x65,0x73,0x20,0x74,0x6F,0x3A,0x20
	.DB  0x30,0x78,0x25,0x30,0x32,0x78,0x0,0xD
	.DB  0xA,0x20,0x20,0x53,0x65,0x74,0x20,0x48
	.DB  0x69,0x67,0x68,0x20,0x46,0x75,0x73,0x65
	.DB  0x20,0x74,0x6F,0x3A,0x20,0x30,0x78,0x25
	.DB  0x30,0x32,0x78,0x0,0xD,0xA,0x20,0x20
	.DB  0x53,0x65,0x74,0x20,0x45,0x78,0x74,0x20
	.DB  0x46,0x75,0x73,0x65,0x20,0x74,0x6F,0x3A
	.DB  0x20,0x30,0x78,0x25,0x30,0x32,0x78,0x0
	.DB  0xD,0xA,0x20,0x20,0x53,0x65,0x74,0x20
	.DB  0x4C,0x6F,0x63,0x6B,0x20,0x46,0x75,0x73
	.DB  0x65,0x20,0x74,0x6F,0x3A,0x20,0x30,0x78
	.DB  0x25,0x30,0x32,0x78,0x0,0xD,0xA,0x56
	.DB  0x65,0x72,0x69,0x66,0x79,0x69,0x6E,0x67
	.DB  0x20,0x66,0x75,0x73,0x65,0x73,0x2E,0x2E
	.DB  0x2E,0x0,0x56,0x65,0x72,0x69,0x66,0x79
	.DB  0x69,0x6E,0x67,0x20,0x66,0x75,0x73,0x65
	.DB  0x73,0x2E,0x0,0x46,0x0,0xD,0xA,0x20
	.DB  0x20,0x4C,0x6F,0x77,0x20,0x46,0x75,0x73
	.DB  0x65,0x20,0x57,0x72,0x69,0x74,0x65,0x6E
	.DB  0x3A,0x20,0x30,0x78,0x25,0x30,0x32,0x78
	.DB  0x0,0xD,0xA,0x20,0x20,0x4C,0x6F,0x77
	.DB  0x20,0x46,0x75,0x73,0x65,0x20,0x52,0x65
	.DB  0x61,0x64,0x65,0x64,0x3A,0x20,0x30,0x78
	.DB  0x25,0x30,0x32,0x78,0x0,0x4E,0x0,0xD
	.DB  0xA,0x20,0x20,0x48,0x69,0x67,0x68,0x20
	.DB  0x46,0x75,0x73,0x65,0x20,0x57,0x72,0x69
	.DB  0x74,0x65,0x6E,0x3A,0x20,0x30,0x78,0x25
	.DB  0x30,0x32,0x78,0x0,0xD,0xA,0x20,0x20
	.DB  0x48,0x69,0x67,0x68,0x20,0x46,0x75,0x73
	.DB  0x65,0x20,0x52,0x65,0x61,0x64,0x65,0x64
	.DB  0x3A,0x20,0x30,0x78,0x25,0x30,0x32,0x78
	.DB  0x0,0x4F,0x0,0xD,0xA,0x20,0x20,0x45
	.DB  0x78,0x74,0x20,0x46,0x75,0x73,0x65,0x20
	.DB  0x57,0x72,0x69,0x74,0x65,0x6E,0x3A,0x20
	.DB  0x30,0x78,0x25,0x30,0x32,0x78,0x0,0xD
	.DB  0xA,0x20,0x20,0x45,0x78,0x74,0x20,0x46
	.DB  0x75,0x73,0x65,0x20,0x52,0x65,0x61,0x64
	.DB  0x65,0x64,0x3A,0x20,0x30,0x78,0x25,0x30
	.DB  0x32,0x78,0x0,0x51,0x0,0xD,0xA,0x20
	.DB  0x20,0x4C,0x6F,0x63,0x6B,0x20,0x46,0x75
	.DB  0x73,0x65,0x20,0x57,0x72,0x69,0x74,0x65
	.DB  0x6E,0x3A,0x20,0x30,0x78,0x25,0x30,0x32
	.DB  0x78,0x0,0xD,0xA,0x20,0x20,0x4C,0x6F
	.DB  0x63,0x6B,0x20,0x46,0x75,0x73,0x65,0x20
	.DB  0x52,0x65,0x61,0x64,0x65,0x64,0x3A,0x20
	.DB  0x30,0x78,0x25,0x30,0x32,0x78,0x0
_0x60020:
	.DB  0x30,0x3A,0x2F,0x31,0x30,0x2F,0x66,0x69
	.DB  0x6C,0x65,0x31,0x32,0x33,0x34,0x2E,0x74
	.DB  0x78,0x74
_0x60000:
	.DB  0x0,0x46,0x52,0x5F,0x44,0x49,0x53,0x4B
	.DB  0x5F,0x45,0x52,0x52,0x0,0x46,0x52,0x5F
	.DB  0x49,0x4E,0x54,0x5F,0x45,0x52,0x52,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x54,0x5F,0x52
	.DB  0x45,0x41,0x44,0x59,0x0,0x46,0x52,0x5F
	.DB  0x4E,0x4F,0x5F,0x46,0x49,0x4C,0x45,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x5F,0x50,0x41
	.DB  0x54,0x48,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x4E,0x41
	.DB  0x4D,0x45,0x0,0x46,0x52,0x5F,0x44,0x45
	.DB  0x4E,0x49,0x45,0x44,0x0,0x46,0x52,0x5F
	.DB  0x45,0x58,0x49,0x53,0x54,0x0,0x46,0x52
	.DB  0x5F,0x49,0x4E,0x56,0x41,0x4C,0x49,0x44
	.DB  0x5F,0x4F,0x42,0x4A,0x45,0x43,0x54,0x0
	.DB  0x46,0x52,0x5F,0x57,0x52,0x49,0x54,0x45
	.DB  0x5F,0x50,0x52,0x4F,0x54,0x45,0x43,0x54
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x44,0x52
	.DB  0x49,0x56,0x45,0x0,0x46,0x52,0x5F,0x4E
	.DB  0x4F,0x54,0x5F,0x45,0x4E,0x41,0x42,0x4C
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x4E,0x4F
	.DB  0x5F,0x46,0x49,0x4C,0x45,0x53,0x59,0x53
	.DB  0x54,0x45,0x4D,0x0,0x46,0x52,0x5F,0x4D
	.DB  0x4B,0x46,0x53,0x5F,0x41,0x42,0x4F,0x52
	.DB  0x54,0x45,0x44,0x0,0x46,0x52,0x5F,0x54
	.DB  0x49,0x4D,0x45,0x4F,0x55,0x54,0x0,0xD
	.DB  0xA,0x45,0x52,0x52,0x4F,0x52,0x20,0x25
	.DB  0x64,0x3A,0x20,0x25,0x70,0x0,0xD,0xA
	.DB  0x53,0x50,0x49,0x20,0x49,0x6E,0x69,0x74
	.DB  0x20,0x46,0x61,0x69,0x6C,0x65,0x64,0x2E
	.DB  0x20,0x52,0x65,0x74,0x75,0x72,0x6E,0x20
	.DB  0x73,0x74,0x61,0x74,0x75,0x73,0x20,0x25
	.DB  0x64,0x2E,0xD,0xA,0x0,0x44,0x69,0x73
	.DB  0x6B,0x20,0x69,0x6E,0x69,0x74,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0x0,0x43,0x61
	.DB  0x72,0x64,0x20,0x6E,0x6F,0x74,0x20,0x70
	.DB  0x72,0x65,0x73,0x65,0x6E,0x74,0x0,0x43
	.DB  0x61,0x72,0x64,0x20,0x77,0x72,0x69,0x74
	.DB  0x65,0xA,0x70,0x72,0x6F,0x74,0x65,0x63
	.DB  0x74,0x65,0x64,0x0,0x43,0x61,0x72,0x64
	.DB  0x20,0x77,0x72,0x69,0x74,0x65,0x20,0x70
	.DB  0x72,0x6F,0x74,0x0,0xD,0xA,0x4C,0x6F
	.DB  0x67,0x69,0x63,0x61,0x6C,0x20,0x64,0x72
	.DB  0x69,0x76,0x65,0x20,0x30,0x3A,0x20,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x65,0x64,0x20,0x4F
	.DB  0x4B,0xD,0xA,0x0,0xD,0xA,0x74,0x6D
	.DB  0x70,0x69,0x6D,0x61,0x67,0x65,0x2E,0x52
	.DB  0x6F,0x6C,0x6C,0x43,0x6F,0x75,0x6E,0x74
	.DB  0x65,0x72,0x3D,0x25,0x64,0x2C,0x20,0x0
	.DB  0xD,0xA,0x52,0x6F,0x6C,0x6C,0x43,0x6F
	.DB  0x75,0x6E,0x74,0x65,0x72,0x54,0x6F,0x43
	.DB  0x68,0x65,0x63,0x6B,0x3D,0x25,0x64,0x2C
	.DB  0x20,0x0,0x5B,0x73,0x65,0x74,0x74,0x69
	.DB  0x6E,0x67,0x73,0x5D,0x0,0xD,0xA,0x25
	.DB  0x64,0x3D,0x25,0x30,0x32,0x78,0x2C,0x20
	.DB  0x25,0x30,0x32,0x78,0x20,0x0,0xD,0xA
	.DB  0x25,0x64,0x3D,0x25,0x30,0x32,0x78,0x2C
	.DB  0x20,0x25,0x63,0x0,0xD,0xA,0x25,0x73
	.DB  0x0,0x72,0x6F,0x6C,0x6C,0x63,0x6F,0x75
	.DB  0x6E,0x74,0x65,0x72,0x0,0xD,0xA,0x25
	.DB  0x70,0x20,0x6B,0x65,0x79,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x66,0x6F,0x75,0x6E,0x64,0x2E
	.DB  0x0,0x46,0x6F,0x75,0x6E,0x64,0x20,0x4B
	.DB  0x65,0x79,0x20,0x72,0x6F,0x6C,0x6C,0x63
	.DB  0x6F,0x75,0x6E,0x74,0x65,0x72,0x0,0xD
	.DB  0xA,0x25,0x70,0x20,0x4B,0x65,0x79,0x20
	.DB  0x6E,0x6F,0x74,0x20,0x66,0x6F,0x75,0x6E
	.DB  0x64,0x2E,0x0,0xD,0xA,0x46,0x6F,0x75
	.DB  0x6E,0x64,0x20,0x4B,0x65,0x79,0x20,0x25
	.DB  0x70,0x3D,0x25,0x73,0x2E,0x0,0x2F,0x0
	.DB  0x2E,0x64,0x61,0x74,0x0,0xD,0xA,0x46
	.DB  0x69,0x6C,0x65,0x20,0x25,0x73,0x20,0x6F
	.DB  0x70,0x65,0x6E,0x65,0x64,0x20,0x4F,0x4B
	.DB  0x2E,0xD,0xA,0x0,0xD,0xA,0x57,0x72
	.DB  0x6F,0x6E,0x67,0x20,0x70,0x61,0x74,0x68
	.DB  0x3A,0x20,0x25,0x73,0xD,0xA,0x0,0x2F
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x2E,0x69
	.DB  0x6E,0x69,0x0,0x20,0x46,0x6F,0x75,0x6E
	.DB  0x64,0x20,0x4B,0x65,0x79,0x20,0x25,0x70
	.DB  0x3D,0x25,0x73,0x2E,0xD,0xA,0x0,0x4E
	.DB  0x6F,0x20,0x63,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x2E,0x69,0x6E,0x69,0x0,0x2F,0x31,0x2F
	.DB  0x70,0x72,0x6F,0x6A,0x65,0x63,0x74,0x2E
	.DB  0x74,0x78,0x74,0x0,0xD,0xA,0x77,0x72
	.DB  0x6F,0x6E,0x67,0x20,0x70,0x61,0x74,0x68
	.DB  0x3A,0x20,0x25,0x73,0xD,0xA,0x0
_0x2000003:
	.DB  0x80,0xC0
_0x2020060:
	.DB  0x1
_0x2020000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
	.DB  0x0

__GLOBAL_INI_TBL:
	.DW  0x01
	.DW  0x0B
	.DW  __REG_VARS*2

	.DW  0x12
	.DW  _path
	.DW  _0x60020*2

	.DW  0x02
	.DW  __base_y_G100
	.DW  _0x2000003*2

	.DW  0x01
	.DW  __seed_G101
	.DW  _0x2020060*2

_0xFFFFFFFF:
	.DW  0

#define __GLOBAL_INI_TBL_PRESENT 1

__RESET:
	CLI
	CLR  R30
	OUT  EECR,R30

;INTERRUPT VECTORS ARE PLACED
;AT THE START OF FLASH
	LDI  R31,1
	OUT  MCUCR,R31
	OUT  MCUCR,R30

;DISABLE WATCHDOG
	LDI  R31,0x18
	WDR
	IN   R26,MCUSR
	CBR  R26,8
	OUT  MCUSR,R26
	STS  WDTCSR,R31
	STS  WDTCSR,R30

;CLEAR R2-R14
	LDI  R24,(14-2)+1
	LDI  R26,2
	CLR  R27
__CLEAR_REG:
	ST   X+,R30
	DEC  R24
	BRNE __CLEAR_REG

;CLEAR SRAM
	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
	LDI  R26,LOW(__SRAM_START)
	LDI  R27,HIGH(__SRAM_START)
__CLEAR_SRAM:
	ST   X+,R30
	SBIW R24,1
	BRNE __CLEAR_SRAM

;GLOBAL VARIABLES INITIALIZATION
	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
__GLOBAL_INI_NEXT:
	LPM  R24,Z+
	LPM  R25,Z+
	SBIW R24,0
	BREQ __GLOBAL_INI_END
	LPM  R26,Z+
	LPM  R27,Z+
	LPM  R0,Z+
	LPM  R1,Z+
	MOVW R22,R30
	MOVW R30,R0
__GLOBAL_INI_LOOP:
	LPM  R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __GLOBAL_INI_LOOP
	MOVW R30,R22
	RJMP __GLOBAL_INI_NEXT
__GLOBAL_INI_END:

;GPIOR0 INITIALIZATION
	LDI  R30,__GPIOR0_INIT
	OUT  GPIOR0,R30

;HARDWARE STACK POINTER INITIALIZATION
	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
	OUT  SPL,R30
	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
	OUT  SPH,R30

;DATA STACK POINTER INITIALIZATION
	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)

	JMP  _main

	.ESEG
	.ORG 0

	.DSEG
	.ORG 0x300

	.CSEG
;/*****************************************************
;This program was produced by the
;CodeWizardAVR V2.05.0 Professional
;Automatic Program Generator
;© Copyright 1998-2010 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com
;
;Project : Standalone avr isp programmer for use with sdcard  lcd  maybe m64
;Version : 12  isp pinout changed to port d to improve lcd progress
;Date    : 06/25/2015
;Author  : Mark Reznik
;Company :
;Comments: Based on usb avrprog from PROTTOSS
;V18:    fixed fusemask to 1's instead 0's
;        freq changed to 12MHz
;        fixed up/down/start buttons
;V19:    Buttons rotated. but not stable response
;V21:    RC1.
;
;
;Chip type               : ATmega328
;Program type            : Application
;AVR Core Clock frequency: 12.000000 MHz
;Memory model            : Small 2048
;External RAM size       : 0
;Data Stack size         : 256
;*****************************************************/
;#define FW_VER  "23a"//rolling
;#include "common.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif
;
;#ifdef PRINT_DEBUG
;
;#ifndef RXB8
;#define RXB8 1
;#endif
;
;#ifndef TXB8
;#define TXB8 0
;#endif
;
;#ifndef UPE
;#define UPE 2
;#endif
;
;#ifndef DOR
;#define DOR 3
;#endif
;
;#ifndef FE
;#define FE 4
;#endif
;
;#ifndef UDRE
;#define UDRE 5
;#endif
;
;#ifndef RXC
;#define RXC 7
;#endif
;
;#define FRAMING_ERROR (1<<FE)
;#define PARITY_ERROR (1<<UPE)
;#define DATA_OVERRUN (1<<DOR)
;#define DATA_REGISTER_EMPTY (1<<UDRE)
;#define RX_COMPLETE (1<<RXC)
;
;// USART Receiver buffer
;#define RX_BUFFER_SIZE 8
;char rx_buffer[RX_BUFFER_SIZE];
;
;#if RX_BUFFER_SIZE <= 256
;unsigned char rx_wr_index,rx_rd_index,rx_counter;
;#else
;unsigned int rx_wr_index,rx_rd_index,rx_counter;
;#endif
;
;// This flag is set on USART Receiver buffer overflow
;bit rx_buffer_overflow;
;
;// USART Receiver interrupt service routine
;#ifdef _MEGA64_INCLUDED_
;interrupt [USART0_RXC] void usart_rx_isr(void)
;#else
;interrupt [USART_RXC] void usart_rx_isr(void)
; 0000 0055 #endif
; 0000 0056 {

	.CSEG
_usart_rx_isr:
; .FSTART _usart_rx_isr
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
; 0000 0057 char status,data;
; 0000 0058 status=UCSR0A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,192
; 0000 0059 data=UDR0;
	LDS  R16,198
; 0000 005A if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BRNE _0x3
; 0000 005B    {
; 0000 005C    rx_buffer[rx_wr_index++]=data;
	MOV  R30,R5
	INC  R5
	LDI  R31,0
	SUBI R30,LOW(-_rx_buffer)
	SBCI R31,HIGH(-_rx_buffer)
	ST   Z,R16
; 0000 005D #if RX_BUFFER_SIZE == 256
; 0000 005E    // special case for receiver buffer size=256
; 0000 005F    if (++rx_counter == 0)
; 0000 0060       {
; 0000 0061 #else
; 0000 0062    if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
	LDI  R30,LOW(8)
	CP   R30,R5
	BRNE _0x4
	CLR  R5
; 0000 0063    if (++rx_counter == RX_BUFFER_SIZE)
_0x4:
	INC  R7
	LDI  R30,LOW(8)
	CP   R30,R7
	BRNE _0x5
; 0000 0064       {
; 0000 0065       rx_counter=0;
	CLR  R7
; 0000 0066 #endif
; 0000 0067       rx_buffer_overflow=1;
	SBI  0x1E,0
; 0000 0068       }
; 0000 0069    }
_0x5:
; 0000 006A }
_0x3:
	LD   R16,Y+
	LD   R17,Y+
	RJMP _0xB1
; .FEND
;
;#ifndef _DEBUG_TERMINAL_IO_
;// Get a character from the USART Receiver buffer
;#define _ALTERNATE_GETCHAR_
;#pragma used+
;char getchar(void)
; 0000 0071 {
_getchar:
; .FSTART _getchar
; 0000 0072 char data;
; 0000 0073 while (rx_counter==0);
	ST   -Y,R17
;	data -> R17
_0x8:
	TST  R7
	BREQ _0x8
; 0000 0074 data=rx_buffer[rx_rd_index++];
	MOV  R30,R4
	INC  R4
	LDI  R31,0
	SUBI R30,LOW(-_rx_buffer)
	SBCI R31,HIGH(-_rx_buffer)
	LD   R17,Z
; 0000 0075 #if RX_BUFFER_SIZE != 256
; 0000 0076 if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index=0;
	LDI  R30,LOW(8)
	CP   R30,R4
	BRNE _0xB
	CLR  R4
; 0000 0077 #endif
; 0000 0078 #asm("cli")
_0xB:
	cli
; 0000 0079 --rx_counter;
	DEC  R7
; 0000 007A #asm("sei")
	sei
; 0000 007B return data;
	MOV  R30,R17
	RJMP _0x20C0031
; 0000 007C }
; .FEND
;#pragma used-
;#endif
;
;// USART Transmitter buffer
;#define TX_BUFFER_SIZE 128
;char tx_buffer[TX_BUFFER_SIZE];
;
;#if TX_BUFFER_SIZE <= 256
;unsigned char tx_wr_index,tx_rd_index,tx_counter;
;#else
;unsigned int tx_wr_index,tx_rd_index,tx_counter;
;#endif
;
;// USART Transmitter interrupt service routine
;#ifdef _MEGA64_INCLUDED_
;interrupt [USART0_TXC] void usart_tx_isr(void)
;#else
;interrupt [USART_TXC] void usart_tx_isr(void)
; 0000 008F #endif
; 0000 0090 {
_usart_tx_isr:
; .FSTART _usart_tx_isr
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
; 0000 0091 if (tx_counter)
	LDS  R30,_tx_counter
	CPI  R30,0
	BREQ _0xC
; 0000 0092    {
; 0000 0093    --tx_counter;
	SUBI R30,LOW(1)
	STS  _tx_counter,R30
; 0000 0094    UDR0=tx_buffer[tx_rd_index++];
	MOV  R30,R9
	INC  R9
	LDI  R31,0
	SUBI R30,LOW(-_tx_buffer)
	SBCI R31,HIGH(-_tx_buffer)
	LD   R30,Z
	STS  198,R30
; 0000 0095 #if TX_BUFFER_SIZE != 256
; 0000 0096    if (tx_rd_index == TX_BUFFER_SIZE) tx_rd_index=0;
	LDI  R30,LOW(128)
	CP   R30,R9
	BRNE _0xD
	CLR  R9
; 0000 0097 #endif
; 0000 0098    }
_0xD:
; 0000 0099 }
_0xC:
_0xB1:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	RETI
; .FEND
;
;#ifndef _DEBUG_TERMINAL_IO_
;// Write a character to the USART Transmitter buffer
;#define _ALTERNATE_PUTCHAR_
;#pragma used+
;void putchar(char c)
; 0000 00A0 {
_putchar:
; .FSTART _putchar
; 0000 00A1 while (tx_counter == TX_BUFFER_SIZE);
;	c -> Y+0
_0xE:
	LDS  R26,_tx_counter
	CPI  R26,LOW(0x80)
	BREQ _0xE
; 0000 00A2 #asm("cli")
	cli
; 0000 00A3 if (tx_counter || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x12
	LDS  R30,192
	ANDI R30,LOW(0x20)
	BRNE _0x11
_0x12:
; 0000 00A4    {
; 0000 00A5    tx_buffer[tx_wr_index++]=c;
	MOV  R30,R6
	INC  R6
	LDI  R31,0
	SUBI R30,LOW(-_tx_buffer)
	SBCI R31,HIGH(-_tx_buffer)
	LD   R26,Y
	STD  Z+0,R26
; 0000 00A6 #if TX_BUFFER_SIZE != 256
; 0000 00A7    if (tx_wr_index == TX_BUFFER_SIZE) tx_wr_index=0;
	LDI  R30,LOW(128)
	CP   R30,R6
	BRNE _0x14
	CLR  R6
; 0000 00A8 #endif
; 0000 00A9    ++tx_counter;
_0x14:
	LDS  R30,_tx_counter
	SUBI R30,-LOW(1)
	STS  _tx_counter,R30
; 0000 00AA    }
; 0000 00AB else
	RJMP _0x15
_0x11:
; 0000 00AC    UDR0=c;
	LD   R30,Y
	STS  198,R30
; 0000 00AD #asm("sei")
_0x15:
	sei
; 0000 00AE }
	ADIW R28,1
	RET
; .FEND
;#pragma used-
;#endif
;
;#endif //end of PRINT_DEBUG
;
;/*ADC defines*/
;enum
;{   BUTTONS_RELEASED=0,
;    BUTTON_START,
;    BUTTON_STOP,
;    BUTTON_UP,
;    BUTTON_DOWN,
;    BUTTONS_PRESSED
;}Buttons;
;
;// Declare your global variables here
;char lcdnum[16];
;UCHAR CanTestButtons=FALSE;
;
;UCHAR CurrentButton=BUTTONS_PRESSED;
;
;#define MAX_BUTTONS     4
;#define ADC_VREF_TYPE   0x20
;
;volatile unsigned char adc_data;
;volatile BOOL ADC_DONE;
;
;
;
;#define NUM_OF_TICKS    100//ticks to measure long button press.  Max long press=NUM_OF_TICKS*TICK_DELAY=100*50=5sec
;#define TICK_DELAY      50//50ms delay between ticks
;// ADC interrupt service routine
;interrupt [ADC_INT] void adc_isr(void)
; 0000 00D0 {
_adc_isr:
; .FSTART _adc_isr
	ST   -Y,R30
; 0000 00D1     // Read the 8 most significant bits  (Vref*(1/1))1024=(11,1111,11)11=FF , (Vref*(1/2))512=(01,1111,11)11=7F (Vref*(1 ...
; 0000 00D2     // of the AD conversion result
; 0000 00D3     ADC_DONE=TRUE;
	LDI  R30,LOW(1)
	STS  _ADC_DONE,R30
; 0000 00D4     adc_data=ADCH;
	LDS  R30,121
	STS  _adc_data,R30
; 0000 00D5     // Place your code here
; 0000 00D6 }
	LD   R30,Y+
	RETI
; .FEND
;
;
;// Standard Input/Output functions
;#include <stdio.h>
;
;void main(void)
; 0000 00DD {
_main:
; .FSTART _main
; 0000 00DE // Declare your local variables here
; 0000 00DF UINT i;//blink led loops
; 0000 00E0 // Crystal Oscillator division factor: 1
; 0000 00E1 #ifdef _MEGA328_INCLUDED_
; 0000 00E2 #pragma optsize-
; 0000 00E3 CLKPR=0x80;
; 0000 00E4 CLKPR=0x00;
; 0000 00E5 #ifdef _OPTIMIZE_SIZE_
; 0000 00E6 #pragma optsize+
; 0000 00E7 #endif
; 0000 00E8 #endif
; 0000 00E9 // Port B initialization
; 0000 00EA // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0000 00EB // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0000 00EC PORTB=0x00;
;	i -> R16,R17
	LDI  R30,LOW(0)
	OUT  0x5,R30
; 0000 00ED DDRB=0x00;
	OUT  0x4,R30
; 0000 00EE 
; 0000 00EF // Port C initialization
; 0000 00F0 // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0000 00F1 // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0000 00F2 PORTC=0x00;
	OUT  0x8,R30
; 0000 00F3 DDRC=0x00;
	OUT  0x7,R30
; 0000 00F4 
; 0000 00F5 // Port D initialization
; 0000 00F6 // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0000 00F7 // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0000 00F8 PORTD=0x00;
	OUT  0xB,R30
; 0000 00F9 DDRD=0x00;
	OUT  0xA,R30
; 0000 00FA 
; 0000 00FB // Timer/Counter 0 initialization
; 0000 00FC // Clock source: System Clock
; 0000 00FD // Clock value: Timer 0 Stopped
; 0000 00FE // Mode: Normal top=0xFF
; 0000 00FF // OC0A output: Disconnected
; 0000 0100 // OC0B output: Disconnected
; 0000 0101 #ifdef _MEGA64_INCLUDED_
; 0000 0102 ASSR=0x00;
; 0000 0103 TCCR0=0x00;
; 0000 0104 TCNT0=0x00;
; 0000 0105 OCR0=0x00;
; 0000 0106 #else
; 0000 0107 TCCR0A=0x00;
	OUT  0x24,R30
; 0000 0108 TCCR0B=0x00;
	OUT  0x25,R30
; 0000 0109 TCNT0=0x00;
	OUT  0x26,R30
; 0000 010A OCR0A=0x00;
	OUT  0x27,R30
; 0000 010B OCR0B=0x00;
	OUT  0x28,R30
; 0000 010C #endif
; 0000 010D // Timer/Counter 1 initialization
; 0000 010E // Clock source: System Clock
; 0000 010F // Clock value: Timer1 Stopped
; 0000 0110 // Mode: Normal top=0xFFFF
; 0000 0111 // OC1A output: Discon.
; 0000 0112 // OC1B output: Discon.
; 0000 0113 // Noise Canceler: Off
; 0000 0114 // Input Capture on Falling Edge
; 0000 0115 // Timer1 Overflow Interrupt: Off
; 0000 0116 // Input Capture Interrupt: Off
; 0000 0117 // Compare A Match Interrupt: Off
; 0000 0118 // Compare B Match Interrupt: Off
; 0000 0119 TCCR1A=0x00;
	STS  128,R30
; 0000 011A TCCR1B=0x00;
	STS  129,R30
; 0000 011B TCNT1H=0x00;
	STS  133,R30
; 0000 011C TCNT1L=0x00;
	STS  132,R30
; 0000 011D ICR1H=0x00;
	STS  135,R30
; 0000 011E ICR1L=0x00;
	STS  134,R30
; 0000 011F OCR1AH=0x00;
	STS  137,R30
; 0000 0120 OCR1AL=0x00;
	STS  136,R30
; 0000 0121 OCR1BH=0x00;
	STS  139,R30
; 0000 0122 OCR1BL=0x00;
	STS  138,R30
; 0000 0123 
; 0000 0124 // Timer/Counter 2 initialization
; 0000 0125 // Clock source: System Clock
; 0000 0126 // Clock value: Timer2 Stopped
; 0000 0127 // Mode: Normal top=0xFF
; 0000 0128 // OC2A output: Disconnected
; 0000 0129 // OC2B output: Disconnected
; 0000 012A #ifdef _MEGA64_INCLUDED_
; 0000 012B TCCR2=0x00;
; 0000 012C TCNT2=0x00;
; 0000 012D OCR2=0x00;
; 0000 012E #else
; 0000 012F ASSR=0x00;
	STS  182,R30
; 0000 0130 TCCR2A=0x00;
	STS  176,R30
; 0000 0131 TCCR2B=0x00;
	STS  177,R30
; 0000 0132 TCNT2=0x00;
	STS  178,R30
; 0000 0133 OCR2A=0x00;
	STS  179,R30
; 0000 0134 OCR2B=0x00;
	STS  180,R30
; 0000 0135 #endif
; 0000 0136 // External Interrupt(s) initialization
; 0000 0137 // INT0: Off
; 0000 0138 // INT1: Off
; 0000 0139 // Interrupt on any change on pins PCINT0-7: Off
; 0000 013A // Interrupt on any change on pins PCINT8-14: Off
; 0000 013B // Interrupt on any change on pins PCINT16-23: Off
; 0000 013C EICRA=0x00;
	STS  105,R30
; 0000 013D EIMSK=0x00;
	OUT  0x1D,R30
; 0000 013E #ifdef _MEGA64_INCLUDED_
; 0000 013F EICRA=0x00;
; 0000 0140 EICRB=0x00;
; 0000 0141 EIMSK=0x00;
; 0000 0142 #else
; 0000 0143 PCICR=0x00;
	STS  104,R30
; 0000 0144 #endif
; 0000 0145 #ifdef _MEGA64_INCLUDED_
; 0000 0146 TIMSK=0x00;
; 0000 0147 ETIMSK=0x00;
; 0000 0148 #else
; 0000 0149 // Timer/Counter 0 Interrupt(s) initialization
; 0000 014A TIMSK0=0x00;
	STS  110,R30
; 0000 014B 
; 0000 014C // Timer/Counter 1 Interrupt(s) initialization
; 0000 014D TIMSK1=0x00;
	STS  111,R30
; 0000 014E 
; 0000 014F // Timer/Counter 2 Interrupt(s) initialization
; 0000 0150 TIMSK2=0x00;
	STS  112,R30
; 0000 0151 #endif
; 0000 0152 #ifdef PRINT_DEBUG
; 0000 0153 // USART initialization
; 0000 0154 // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0000 0155 // USART Receiver: On
; 0000 0156 // USART Transmitter: On
; 0000 0157 // USART0 Mode: Asynchronous
; 0000 0158 // USART Baud Rate: 9600
; 0000 0159 UCSR0A=0x00;
	STS  192,R30
; 0000 015A UCSR0B=0xD8;
	LDI  R30,LOW(216)
	STS  193,R30
; 0000 015B UCSR0C=0x06;
	LDI  R30,LOW(6)
	STS  194,R30
; 0000 015C UBRR0H=0x00;
	LDI  R30,LOW(0)
	STS  197,R30
; 0000 015D //UBRR0L=0x33; //9600 for 8Mhz osc
; 0000 015E UBRR0L=0x4D; //9600 for 12Mhz osc
	LDI  R30,LOW(77)
	STS  196,R30
; 0000 015F //UBRR0L=0x67; //9600 for 16Mhz osc
; 0000 0160 #endif
; 0000 0161 
; 0000 0162 // Analog Comparator initialization
; 0000 0163 // Analog Comparator: Off
; 0000 0164 // Analog Comparator Input Capture by Timer/Counter 1: Off
; 0000 0165 ACSR=0x80;
	LDI  R30,LOW(128)
	OUT  0x30,R30
; 0000 0166 ADCSRB=0x00;
	LDI  R30,LOW(0)
	STS  123,R30
; 0000 0167 #ifndef _MEGA64_INCLUDED_
; 0000 0168 DIDR1=0x00;
	STS  127,R30
; 0000 0169 #endif
; 0000 016A // ADC initialization
; 0000 016B // ADC Clock frequency: 1000.000 kHz
; 0000 016C // ADC Voltage Reference: AREF pin
; 0000 016D // ADC Auto Trigger Source: ADC Stopped
; 0000 016E // Only the 8 most significant bits of
; 0000 016F // the AD conversion result are used
; 0000 0170 // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On
; 0000 0171 // ADC4: On, ADC5: On
; 0000 0172 #ifndef _MEGA64_INCLUDED_
; 0000 0173 DIDR0=0x00;
	STS  126,R30
; 0000 0174 #endif
; 0000 0175 ADMUX=ADC_VREF_TYPE & 0xff;
	LDI  R30,LOW(32)
	STS  124,R30
; 0000 0176 ADCSRA=0x8B;
	LDI  R30,LOW(139)
	STS  122,R30
; 0000 0177 
; 0000 0178 // SPI initialization
; 0000 0179 // SPI disabled
; 0000 017A SPCR=0x00;
	LDI  R30,LOW(0)
	OUT  0x2C,R30
; 0000 017B 
; 0000 017C // TWI initialization
; 0000 017D // TWI disabled
; 0000 017E TWCR=0x00;
	STS  188,R30
; 0000 017F 
; 0000 0180 ADC_DONE=TRUE;
	LDI  R30,LOW(1)
	STS  _ADC_DONE,R30
; 0000 0181 AVR910_Init();
	CALL _AVR910_Init
; 0000 0182 init_sd_tim1();
	CALL _init_sd_tim1
; 0000 0183 BUZ_INIT();
	SBI  0xA,6
	CBI  0xB,6
; 0000 0184 debug=1;
	LDI  R30,LOW(1)
	STS  _debug,R30
; 0000 0185 // Global enable interrupts
; 0000 0186 #asm("sei")
	sei
; 0000 0187 #ifdef PRINT_DEBUG
; 0000 0188 if(debug)printf("Init done. Current folder is %d.\r\n",dirnum);
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x1A
	__POINTW1FN _0x0,0
	CALL SUBOPT_0x0
; 0000 0189 #endif
; 0000 018A g_UpSkip=1;
_0x1A:
	LDI  R30,LOW(1)
	STS  _g_UpSkip,R30
; 0000 018B g_DownSkip=1;
	STS  _g_DownSkip,R30
; 0000 018C g_MaxFolders=4;
	LDI  R30,LOW(4)
	STS  _g_MaxFolders,R30
; 0000 018D #ifdef PRINT_LCD
; 0000 018E lcd_init(16);
	LDI  R30,LOW(16)
	ST   -Y,R30
	CALL _lcd_init
; 0000 018F lcd_gotoxy(0,0);
	CALL SUBOPT_0x1
	CALL _lcd_gotoxy
; 0000 0190 lcd_putsf("AVR ISP SD V");
	__POINTW1FN _0x0,35
	CALL SUBOPT_0x2
; 0000 0191 lcd_putsf(FW_VER);
	__POINTW1FN _0x0,48
	CALL SUBOPT_0x2
; 0000 0192 
; 0000 0193 #ifndef DEBUG_PROTEUS
; 0000 0194 delay_ms(2000);
	CALL SUBOPT_0x3
; 0000 0195 #endif
; 0000 0196 Call_GetConfig();
	CALL _Call_GetConfig
; 0000 0197 #endif
; 0000 0198 if(SaveDirNum==0 || SaveDirNum>=(g_MaxFolders-1)) //reset eeprom last project directory
	CALL SUBOPT_0x4
	CPI  R30,0
	BREQ _0x1C
	CALL SUBOPT_0x4
	MOV  R26,R30
	LDS  R30,_g_MaxFolders
	LDI  R31,0
	SBIW R30,1
	LDI  R27,0
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x1B
_0x1C:
; 0000 0199     SaveDirNum=1;
	LDI  R26,LOW(_SaveDirNum)
	LDI  R27,HIGH(_SaveDirNum)
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 0000 019A dirnum=SaveDirNum;
_0x1B:
	CALL SUBOPT_0x4
	STS  _dirnum,R30
; 0000 019B if(SaveLockState>1)
	CALL SUBOPT_0x5
	CPI  R30,LOW(0x2)
	BRLO _0x1E
; 0000 019C     SaveLockState=0;
	LDI  R26,LOW(_SaveLockState)
	LDI  R27,HIGH(_SaveLockState)
	LDI  R30,LOW(0)
	CALL __EEPROMWRB
; 0000 019D #ifdef PRINT_LCD
; 0000 019E lcd_GetProgName(0);
_0x1E:
	CALL SUBOPT_0x6
; 0000 019F #endif
; 0000 01A0     while (1)
_0x1F:
; 0000 01A1     {
; 0000 01A2       delay_us(1000);
	__DELAY_USW 3000
; 0000 01A3       // Place your code here
; 0000 01A4       #ifdef PRINT_DEBUG
; 0000 01A5       //check if uart received some bytes
; 0000 01A6       if(rx_counter){
	TST  R7
	BREQ _0x22
; 0000 01A7         while(rx_counter)//move the received bytes to FIFO
_0x23:
	TST  R7
	BREQ _0x25
; 0000 01A8             FIFO_Write(getchar());
	RCALL _getchar
	ST   -Y,R30
	CALL _FIFO_Write
	RJMP _0x23
_0x25:
; 0000 01AA AVR910_Command();
	RCALL _AVR910_Command
; 0000 01AB       }
; 0000 01AC       //check if some UART bytes waiting to send
; 0000 01AD       AVR910_SendRxToUart();
_0x22:
	CALL _AVR910_SendRxToUart
; 0000 01AE       #endif
; 0000 01AF 
; 0000 01B0       //check if program button was pressed
; 0000 01B1       if(CanTestButtons==0){
	LDS  R30,_CanTestButtons
	CPI  R30,0
	BRNE _0x26
; 0000 01B2         CanTestButtons=TestButton(BUTTONS_RELEASED);
	CALL SUBOPT_0x7
; 0000 01B3         #ifdef DEBUG_BUTTONS;
; 0000 01B4         lcd_putsf_row(0,"Cannot test");
; 0000 01B5         #endif
; 0000 01B6       }
; 0000 01B7       if(CanTestButtons)
_0x26:
	LDS  R30,_CanTestButtons
	CPI  R30,0
	BREQ _0x27
; 0000 01B8       {
; 0000 01B9          #ifdef DEBUG_BUTTONS;
; 0000 01BA          lcd_putsf_row(0,"Mode ");
; 0000 01BB          lcd_putchar(StandaloneMode+0x30);
; 0000 01BC          delay_ms(10);
; 0000 01BD          #endif
; 0000 01BE          CanTestButtons=TestADCs();
	RCALL _TestADCs
	STS  _CanTestButtons,R30
; 0000 01BF          switch(CanTestButtons)
	LDI  R31,0
; 0000 01C0          {
; 0000 01C1             case (1<<BUTTONS_RELEASED):CanTestButtons=1;
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x2B
	LDI  R30,LOW(1)
	RJMP _0xAE
; 0000 01C2                 break;
; 0000 01C3             case (1<<BUTTON_UP):UpButtonAction();
_0x2B:
	CPI  R30,LOW(0x8)
	LDI  R26,HIGH(0x8)
	CPC  R31,R26
	BRNE _0x2C
	RCALL _UpButtonAction
; 0000 01C4                 break;
	RJMP _0x2A
; 0000 01C5             case (1<<BUTTON_DOWN):DownButtonAction();
_0x2C:
	CPI  R30,LOW(0x10)
	LDI  R26,HIGH(0x10)
	CPC  R31,R26
	BRNE _0x2D
	RCALL _DownButtonAction
; 0000 01C6                 break;
	RJMP _0x2A
; 0000 01C7             case (1<<BUTTON_START):StartButtonAction();
_0x2D:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x2E
	RCALL _StartButtonAction
; 0000 01C8                 break;
	RJMP _0x2A
; 0000 01C9             case (1<<BUTTON_STOP):StopButtonAction();
_0x2E:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x30
	RCALL _StopButtonAction
; 0000 01CA                 break;
	RJMP _0x2A
; 0000 01CB             default:CanTestButtons=0;
_0x30:
	LDI  R30,LOW(0)
_0xAE:
	STS  _CanTestButtons,R30
; 0000 01CC                 break;
; 0000 01CD          }
_0x2A:
; 0000 01CE          CanTestButtons=TestButton(BUTTONS_RELEASED);
	CALL SUBOPT_0x7
; 0000 01CF       }
; 0000 01D0       if(StandaloneMode==IDLE || StandaloneMode==PASS){
_0x27:
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x0)
	BREQ _0x32
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x1)
	BRNE _0x31
_0x32:
; 0000 01D1         delay_ms(10);
	CALL SUBOPT_0x8
; 0000 01D2         if(++CounterLed==250){
	CALL SUBOPT_0x9
	CPI  R26,LOW(0xFA)
	BRNE _0x34
; 0000 01D3             CounterLed=0;
	LDI  R30,LOW(0)
	STS  _CounterLed,R30
; 0000 01D4             #ifdef PRINT_LCD
; 0000 01D5             itoa(dirnum,lcdnum);
	CALL SUBOPT_0xA
; 0000 01D6             lcd_puts_row(0,lcdnum);
; 0000 01D7             lcd_putsf(".");
; 0000 01D8             lcd_puts(tmpimage.progname);
	CALL SUBOPT_0xB
; 0000 01D9             #endif
; 0000 01DA         }
; 0000 01DB         if(CounterLed==130){
_0x34:
	LDS  R26,_CounterLed
	CPI  R26,LOW(0x82)
	BRNE _0x35
; 0000 01DC             #ifdef PRINT_LCD
; 0000 01DD             lcd_puts_row(0,tmpimage.fw_ver);
	LDI  R30,LOW(0)
	ST   -Y,R30
	__POINTW1MN _tmpimage,75
	ST   -Y,R31
	ST   -Y,R30
	RCALL _lcd_puts_row
; 0000 01DE             #endif
; 0000 01DF         }
; 0000 01E0       }
_0x35:
; 0000 01E1       else if(StandaloneMode==FAIL || StandaloneMode==SDFAIL){
	RJMP _0x36
_0x31:
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x2)
	BREQ _0x38
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BRNE _0x37
_0x38:
; 0000 01E2            #ifdef PRINT_LCD
; 0000 01E3            lcd_putsf_row(0,"Press Stop");
	LDI  R30,LOW(0)
	ST   -Y,R30
	__POINTW1FN _0x0,54
	CALL SUBOPT_0xC
; 0000 01E4            #endif
; 0000 01E5       }
; 0000 01E6     }//end while
_0x37:
_0x36:
	RJMP _0x1F
; 0000 01E7 }//end main
_0x3A:
	RJMP _0x3A
; .FEND
;void UpButtonAction()
; 0000 01E9 {
_UpButtonAction:
; .FSTART _UpButtonAction
; 0000 01EA     char i;
; 0000 01EB     #ifdef DEBUG_BUTTONS;
; 0000 01EC     lcd_putsf_row(0,"Up");
; 0000 01ED     #endif
; 0000 01EE     if(StandaloneMode!=IDLE && StandaloneMode!=SDFAIL){
	CALL SUBOPT_0xD
;	i -> R17
	BREQ _0x3C
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BRNE _0x3D
_0x3C:
	RJMP _0x3B
_0x3D:
; 0000 01EF      Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 01F0      return;
	RJMP _0x20C0031
; 0000 01F1     }
; 0000 01F2     if(SaveLockState!=0){
_0x3B:
	CALL SUBOPT_0x5
	CPI  R30,0
	BREQ _0x3E
; 0000 01F3         #ifdef PRINT_LCD
; 0000 01F4         lcd_putsf_row(1,"List Locked");
	CALL SUBOPT_0xF
; 0000 01F5         //delay_ms(500);
; 0000 01F6         #endif
; 0000 01F7         Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 01F8         return;
	RJMP _0x20C0031
; 0000 01F9     }
; 0000 01FA     for(i=NUM_OF_TICKS;i>0;i--){  //if up button pressed about 10 sec - unlock list function
_0x3E:
	LDI  R17,LOW(100)
_0x40:
	CPI  R17,1
	BRLT _0x41
; 0000 01FB         delay_ms(TICK_DELAY);
	CALL SUBOPT_0x10
; 0000 01FC         if(TestButton(BUTTON_UP)==FALSE)
	LDI  R30,LOW(3)
	CALL SUBOPT_0x11
	BREQ _0x41
; 0000 01FD             break;
; 0000 01FE         if(i==98)
	CPI  R17,98
	BRNE _0x43
; 0000 01FF             Beeps(1,1);
	CALL SUBOPT_0x12
; 0000 0200     }
_0x43:
	SUBI R17,1
	RJMP _0x40
_0x41:
; 0000 0201     if(i>98) //debounce
	CPI  R17,99
	BRLT _0x44
; 0000 0202         return;
	RJMP _0x20C0031
; 0000 0203     if(i==0){
_0x44:
	CPI  R17,0
	BRNE _0x45
; 0000 0204         Beeps(3,1);//
	CALL SUBOPT_0xE
; 0000 0205         return;
	RJMP _0x20C0031
; 0000 0206     }
; 0000 0207 
; 0000 0208     if(dirnum+g_UpSkip >= g_MaxFolders)
_0x45:
	LDS  R26,_dirnum
	CLR  R27
	LDS  R30,_g_UpSkip
	LDI  R31,0
	ADD  R26,R30
	ADC  R27,R31
	LDS  R30,_g_MaxFolders
	LDI  R31,0
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x46
; 0000 0209         dirnum=1;
	LDI  R30,LOW(1)
	RJMP _0xAF
; 0000 020A     else
_0x46:
; 0000 020B         dirnum+=g_UpSkip;
	LDS  R30,_g_UpSkip
	LDS  R26,_dirnum
	ADD  R30,R26
_0xAF:
	STS  _dirnum,R30
; 0000 020C     #ifdef PRINT_DEBUG
; 0000 020D     while(tx_counter);
_0x48:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x48
; 0000 020E     printf("Current Folder %d\r\n",dirnum);
	__POINTW1FN _0x0,77
	CALL SUBOPT_0x0
; 0000 020F     while(tx_counter);
_0x4B:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4B
; 0000 0210     #endif
; 0000 0211     #ifdef PRINT_LCD
; 0000 0212     if(lcd_GetProgName(0)==TRUE){
	CALL SUBOPT_0x6
	CPI  R30,LOW(0x1)
	BRNE _0x4E
; 0000 0213        Beeps(1,1);
	CALL SUBOPT_0x12
; 0000 0214     }
; 0000 0215     else{
	RJMP _0x4F
_0x4E:
; 0000 0216         StandaloneMode=SDFAIL;
	CALL SUBOPT_0x13
; 0000 0217         Beeps(2,1);
; 0000 0218         return;
	RJMP _0x20C0031
; 0000 0219     }
_0x4F:
; 0000 021A     #else
; 0000 021B     if(Call_GetDir()==TRUE){
; 0000 021C         Beeps(1,dirnum);
; 0000 021D     }
; 0000 021E     else{
; 0000 021F         StandaloneMode=SDFAIL;
; 0000 0220         return;
; 0000 0221     }
; 0000 0222     #endif
; 0000 0223     StandaloneMode=IDLE;
	LDI  R30,LOW(0)
	CALL SUBOPT_0x14
; 0000 0224     LEDS_OFF();
; 0000 0225 }
	RJMP _0x20C0031
; .FEND
;
;void StartButtonAction()
; 0000 0228 {
_StartButtonAction:
; .FSTART _StartButtonAction
; 0000 0229     char i;
; 0000 022A     #ifdef DEBUG_BUTTONS;
; 0000 022B     lcd_putsf_row(0,"Start");
; 0000 022C     #endif
; 0000 022D     if(StandaloneMode!=IDLE && StandaloneMode!=PASS){
	CALL SUBOPT_0xD
;	i -> R17
	BREQ _0x55
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x1)
	BRNE _0x56
_0x55:
	RJMP _0x54
_0x56:
; 0000 022E        Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 022F        return;
	RJMP _0x20C0031
; 0000 0230     }
; 0000 0231     for(i=NUM_OF_TICKS;i>0;i--){
_0x54:
	LDI  R17,LOW(100)
_0x58:
	CPI  R17,1
	BRLT _0x59
; 0000 0232         delay_ms(TICK_DELAY);
	CALL SUBOPT_0x10
; 0000 0233         if(TestButton(BUTTON_START)==FALSE)
	LDI  R30,LOW(1)
	CALL SUBOPT_0x11
	BREQ _0x59
; 0000 0234             break;
; 0000 0235         if(i==98)
	CPI  R17,98
	BRNE _0x5B
; 0000 0236             Beeps(1,1);// one short beep
	CALL SUBOPT_0x12
; 0000 0237     }
_0x5B:
	SUBI R17,1
	RJMP _0x58
_0x59:
; 0000 0238     if(i>98) //debounce
	CPI  R17,99
	BRLT _0x5C
; 0000 0239         return;
	RJMP _0x20C0031
; 0000 023A     SaveDirNum=dirnum;
_0x5C:
	CALL SUBOPT_0x15
; 0000 023B     if(i==0){// lock the list
	CPI  R17,0
	BRNE _0x5D
; 0000 023C         SaveLockState=1;
	LDI  R26,LOW(_SaveLockState)
	LDI  R27,HIGH(_SaveLockState)
	LDI  R30,LOW(1)
	CALL SUBOPT_0x16
; 0000 023D         Beeps(2,1);//one long beep
; 0000 023E         #ifdef PRINT_LCD
; 0000 023F         lcd_putsf_row(1,"List Locked");
	CALL SUBOPT_0xF
; 0000 0240         delay_ms(500);
	LDI  R30,LOW(500)
	LDI  R31,HIGH(500)
	CALL SUBOPT_0x17
; 0000 0241         #endif
; 0000 0242         return;
	RJMP _0x20C0031
; 0000 0243     }
; 0000 0244     #ifdef PRINT_LCD
; 0000 0245     itoa(dirnum,lcdnum);
_0x5D:
	CALL SUBOPT_0xA
; 0000 0246     lcd_puts_row(0,lcdnum);
; 0000 0247     lcd_putsf(".");
; 0000 0248     lcd_puts(tmpimage.progname);
	CALL SUBOPT_0xB
; 0000 0249     lcd_putsf_row(1,"Programming ....");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x0,97
	CALL SUBOPT_0xC
; 0000 024A     #else
; 0000 024B     putchar('S');
; 0000 024C     #endif
; 0000 024D     StandaloneMode=RUNNING;
	LDI  R30,LOW(3)
	CALL SUBOPT_0x14
; 0000 024E     LEDS_OFF();
; 0000 024F     StandalonProg();
	CALL _StandalonProg
; 0000 0250     #ifdef PRINT_LCD
; 0000 0251     //lcd_init(16);
; 0000 0252     #endif
; 0000 0253 }
	RJMP _0x20C0031
; .FEND
;
;void DownButtonAction()
; 0000 0256 {
_DownButtonAction:
; .FSTART _DownButtonAction
; 0000 0257    char i;
; 0000 0258    #ifdef DEBUG_BUTTONS;
; 0000 0259    lcd_putsf_row(0,"Down");
; 0000 025A    #endif
; 0000 025B    if(StandaloneMode!=IDLE && StandaloneMode!=SDFAIL){
	CALL SUBOPT_0xD
;	i -> R17
	BREQ _0x63
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BRNE _0x64
_0x63:
	RJMP _0x62
_0x64:
; 0000 025C      Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 025D      return;
	RJMP _0x20C0031
; 0000 025E    }
; 0000 025F    if(SaveLockState!=0){
_0x62:
	CALL SUBOPT_0x5
	CPI  R30,0
	BREQ _0x65
; 0000 0260         #ifdef PRINT_LCD
; 0000 0261         lcd_putsf_row(1,"List Locked");
	CALL SUBOPT_0xF
; 0000 0262         //delay_ms(500);
; 0000 0263         #endif
; 0000 0264         Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 0265         return;
	RJMP _0x20C0031
; 0000 0266    }
; 0000 0267    for(i=NUM_OF_TICKS;i>0;i--){  //if down button pressed about 10 sec - unlock list function
_0x65:
	LDI  R17,LOW(100)
_0x67:
	CPI  R17,1
	BRLT _0x68
; 0000 0268         delay_ms(TICK_DELAY);
	CALL SUBOPT_0x10
; 0000 0269         if(TestButton(BUTTON_DOWN)==FALSE)
	LDI  R30,LOW(4)
	CALL SUBOPT_0x11
	BREQ _0x68
; 0000 026A             break;
; 0000 026B         if(i==98)
	CPI  R17,98
	BRNE _0x6A
; 0000 026C             Beeps(1,1);
	CALL SUBOPT_0x12
; 0000 026D    }
_0x6A:
	SUBI R17,1
	RJMP _0x67
_0x68:
; 0000 026E    if(i==0){
	CPI  R17,0
	BRNE _0x6B
; 0000 026F         Beeps(3,1);//fail beep the button pressed too much time
	CALL SUBOPT_0xE
; 0000 0270         return;
	RJMP _0x20C0031
; 0000 0271    }
; 0000 0272    if(i>98){ //debounce
_0x6B:
	CPI  R17,99
	BRLT _0x6C
; 0000 0273         return;
	RJMP _0x20C0031
; 0000 0274    }
; 0000 0275 
; 0000 0276    if(dirnum){
_0x6C:
	LDS  R30,_dirnum
	CPI  R30,0
	BREQ _0x6D
; 0000 0277     if(dirnum <= g_DownSkip)
	LDS  R30,_g_DownSkip
	LDS  R26,_dirnum
	CP   R30,R26
	BRLO _0x6E
; 0000 0278         dirnum=g_MaxFolders-1;
	LDS  R30,_g_MaxFolders
	SUBI R30,LOW(1)
	RJMP _0xB0
; 0000 0279     else
_0x6E:
; 0000 027A         dirnum-=g_DownSkip;
	LDS  R26,_g_DownSkip
	LDS  R30,_dirnum
	SUB  R30,R26
_0xB0:
	STS  _dirnum,R30
; 0000 027B    }
; 0000 027C    #ifdef PRINT_DEBUG
; 0000 027D    while(tx_counter);
_0x6D:
_0x70:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x70
; 0000 027E    printf("Current Folder %d\r\n",dirnum);
	__POINTW1FN _0x0,77
	CALL SUBOPT_0x0
; 0000 027F    while(tx_counter);
_0x73:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x73
; 0000 0280    #endif
; 0000 0281    #ifdef PRINT_LCD
; 0000 0282    if(lcd_GetProgName(0)==TRUE){
	CALL SUBOPT_0x6
	CPI  R30,LOW(0x1)
	BRNE _0x76
; 0000 0283        Beeps(1,1);
	CALL SUBOPT_0x12
; 0000 0284    }
; 0000 0285    else{
	RJMP _0x77
_0x76:
; 0000 0286        Beeps(2,1);
	CALL SUBOPT_0x18
; 0000 0287        StandaloneMode=SDFAIL;
	LDI  R30,LOW(4)
	STS  _StandaloneMode,R30
; 0000 0288        return;
	RJMP _0x20C0031
; 0000 0289    }
_0x77:
; 0000 028A    #else
; 0000 028B    if(Call_GetDir()==TRUE){
; 0000 028C         Beeps(1,dirnum);
; 0000 028D    }
; 0000 028E    else{
; 0000 028F         StandaloneMode=SDFAIL;
; 0000 0290         Beeps(2,1);
; 0000 0291         return;
; 0000 0292    }
; 0000 0293    #endif
; 0000 0294    StandaloneMode=IDLE;
	LDI  R30,LOW(0)
	CALL SUBOPT_0x14
; 0000 0295    LEDS_OFF();
; 0000 0296 }
	RJMP _0x20C0031
; .FEND
;
;void StopButtonAction()
; 0000 0299 {
_StopButtonAction:
; .FSTART _StopButtonAction
; 0000 029A    char i;
; 0000 029B    #ifdef DEBUG_BUTTONS;
; 0000 029C    lcd_putsf_row(0,"Stop");
; 0000 029D    #endif
; 0000 029E    if(StandaloneMode==RUNNING){
	ST   -Y,R17
;	i -> R17
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x3)
	BRNE _0x7C
; 0000 029F      Beeps(3,1);
	CALL SUBOPT_0xE
; 0000 02A0      return;
	RJMP _0x20C0031
; 0000 02A1    }
; 0000 02A2    for(i=NUM_OF_TICKS;i>0;i--){  //if down button pressed about 10 sec - unlock list function
_0x7C:
	LDI  R17,LOW(100)
_0x7E:
	CPI  R17,1
	BRLT _0x7F
; 0000 02A3         delay_ms(TICK_DELAY);
	CALL SUBOPT_0x10
; 0000 02A4         if(TestButton(BUTTON_STOP)==FALSE)
	LDI  R30,LOW(2)
	CALL SUBOPT_0x11
	BREQ _0x7F
; 0000 02A5             break;
; 0000 02A6         if(i==98)
	CPI  R17,98
	BRNE _0x81
; 0000 02A7             Beeps(1,1);//short beep once
	CALL SUBOPT_0x12
; 0000 02A8    }
_0x81:
	SUBI R17,1
	RJMP _0x7E
_0x7F:
; 0000 02A9    if(i>98){ //debounce
	CPI  R17,99
	BRGE _0x20C0031
; 0000 02AA         return;
; 0000 02AB    }
; 0000 02AC    //if(StandaloneMode==IDLE || StandaloneMode==PASS){
; 0000 02AD        if(i==0){//unlock the listing
	CPI  R17,0
	BRNE _0x83
; 0000 02AE             SaveLockState=0;
	LDI  R26,LOW(_SaveLockState)
	LDI  R27,HIGH(_SaveLockState)
	LDI  R30,LOW(0)
	CALL SUBOPT_0x16
; 0000 02AF             Beeps(2,1);//long beep once
; 0000 02B0             #ifdef PRINT_LCD
; 0000 02B1             lcd_putsf_row(1,"List Unlocked");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x0,114
	CALL SUBOPT_0xC
; 0000 02B2             delay_ms(1000);
	LDI  R30,LOW(1000)
	LDI  R31,HIGH(1000)
	CALL SUBOPT_0x17
; 0000 02B3             #endif
; 0000 02B4        }
; 0000 02B5    //}
; 0000 02B6    LEDS_OFF();    //
_0x83:
	SBI  0x5,1
	SBI  0x5,0
; 0000 02B7    StandaloneMode=IDLE;
	LDI  R30,LOW(0)
	STS  _StandaloneMode,R30
; 0000 02B8    Call_GetConfig();
	CALL _Call_GetConfig
; 0000 02B9    if(lcd_GetProgName(0)==TRUE){//read dir again
	CALL SUBOPT_0x6
	CPI  R30,LOW(0x1)
	BRNE _0x88
; 0000 02BA 
; 0000 02BB         if(SaveDirNum!=dirnum)
	CALL SUBOPT_0x4
	MOV  R26,R30
	LDS  R30,_dirnum
	CP   R30,R26
	BREQ _0x89
; 0000 02BC             SaveDirNum = dirnum;
	CALL SUBOPT_0x15
; 0000 02BD    }
_0x89:
; 0000 02BE    else{
	RJMP _0x8A
_0x88:
; 0000 02BF      StandaloneMode=SDFAIL;
	CALL SUBOPT_0x13
; 0000 02C0      Beeps(2,1);
; 0000 02C1    }
_0x8A:
; 0000 02C2 }
_0x20C0031:
	LD   R17,Y+
	RET
; .FEND
;
;#ifdef PRINT_LCD
;UCHAR lcd_GetProgName(UCHAR row)
; 0000 02C6 {
_lcd_GetProgName:
; .FSTART _lcd_GetProgName
; 0000 02C7    char num1[6],num2[6] ;
; 0000 02C8    itoa(dirnum,num1);
	SBIW R28,12
;	row -> Y+12
;	num1 -> Y+6
;	num2 -> Y+0
	CALL SUBOPT_0x19
; 0000 02C9    if(row>1)
	LDD  R26,Y+12
	CPI  R26,LOW(0x2)
	BRLO _0x8B
; 0000 02CA         return FALSE;
	RJMP _0x20C0030
; 0000 02CB    lcd_clear();
_0x8B:
	CALL _lcd_clear
; 0000 02CC    lcd_putsf_row(row,"Read folder ");
	LDD  R30,Y+12
	ST   -Y,R30
	__POINTW1FN _0x0,128
	CALL SUBOPT_0xC
; 0000 02CD    lcd_puts(num1);
	CALL SUBOPT_0x1A
; 0000 02CE    //lcd_putchar(dirnum+'0');
; 0000 02CF    lcd_gotoxy(0,1);
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _lcd_gotoxy
; 0000 02D0    delay_ms(10);
	CALL SUBOPT_0x8
; 0000 02D1    if(Call_GetDir()==TRUE){
	CALL _Call_GetDir
	CPI  R30,LOW(0x1)
	BRNE _0x8C
; 0000 02D2 
; 0000 02D3         if(num1){
	MOVW R30,R28
	ADIW R30,6
	SBIW R30,0
	BREQ _0x8D
; 0000 02D4             ltoa(tmpimage.ProgCounterDone,num1);
	CALL SUBOPT_0x1B
	MOVW R30,R28
	ADIW R30,10
	ST   -Y,R31
	ST   -Y,R30
	CALL _ltoa
; 0000 02D5             lcd_puts(num1);
	CALL SUBOPT_0x1A
; 0000 02D6         }else
	RJMP _0x8E
_0x8D:
; 0000 02D7             lcd_putsf("0");
	__POINTW1FN _0x0,141
	CALL SUBOPT_0x2
; 0000 02D8         lcd_putsf(" of ");
_0x8E:
	__POINTW1FN _0x0,143
	CALL SUBOPT_0x2
; 0000 02D9         if(num2){
	MOVW R30,R28
	SBIW R30,0
	BREQ _0x8F
; 0000 02DA             ltoa(tmpimage.ProgCounterTotal,num2);
	CALL SUBOPT_0x1C
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	CALL _ltoa
; 0000 02DB             lcd_puts(num2);
	MOVW R30,R28
	CALL SUBOPT_0x1D
; 0000 02DC         }else
	RJMP _0x90
_0x8F:
; 0000 02DD             lcd_putsf("0");
	__POINTW1FN _0x0,141
	CALL SUBOPT_0x2
; 0000 02DE         return TRUE;
_0x90:
	LDI  R30,LOW(1)
	RJMP _0x20C002F
; 0000 02DF    }
; 0000 02E0    else{
_0x8C:
; 0000 02E1         lcd_putsf_row(1,"File ");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x0,148
	CALL SUBOPT_0xC
; 0000 02E2         itoa(dirnum,num1);
	CALL SUBOPT_0x19
; 0000 02E3         lcd_puts(num1);
	CALL SUBOPT_0x1A
; 0000 02E4         lcd_putsf(" error.");
	__POINTW1FN _0x0,154
	CALL SUBOPT_0x2
; 0000 02E5    }
; 0000 02E6    return FALSE;
_0x20C0030:
	LDI  R30,LOW(0)
_0x20C002F:
	ADIW R28,13
	RET
; 0000 02E7 }
; .FEND
;void lcd_putsf_row(UCHAR row,flash char *str)
; 0000 02E9 {
_lcd_putsf_row:
; .FSTART _lcd_putsf_row
; 0000 02EA    if(row>1)
;	row -> Y+2
;	*str -> Y+0
	LDD  R26,Y+2
	CPI  R26,LOW(0x2)
	BRLO _0x92
; 0000 02EB         return;
	RJMP _0x20C002C
; 0000 02EC    lcd_gotoxy(0,row);
_0x92:
	CALL SUBOPT_0x1E
; 0000 02ED    lcd_putsf("                ");
	__POINTW1FN _0x0,162
	CALL SUBOPT_0x2
; 0000 02EE    lcd_gotoxy(0,row);
	CALL SUBOPT_0x1E
; 0000 02EF    lcd_putsf(str);
	LD   R30,Y
	LDD  R31,Y+1
	CALL SUBOPT_0x2
; 0000 02F0    delay_ms(50);
	CALL SUBOPT_0x10
; 0000 02F1 }
	RJMP _0x20C002C
; .FEND
;void lcd_puts_row(UCHAR row,char *str)
; 0000 02F3 {
_lcd_puts_row:
; .FSTART _lcd_puts_row
; 0000 02F4    if(row>1)
;	row -> Y+2
;	*str -> Y+0
	LDD  R26,Y+2
	CPI  R26,LOW(0x2)
	BRLO _0x93
; 0000 02F5         return;
	RJMP _0x20C002C
; 0000 02F6    lcd_gotoxy(0,row);
_0x93:
	CALL SUBOPT_0x1E
; 0000 02F7    lcd_putsf("                ");
	__POINTW1FN _0x0,162
	CALL SUBOPT_0x2
; 0000 02F8    lcd_gotoxy(0,row);
	CALL SUBOPT_0x1E
; 0000 02F9    lcd_puts(str);
	LD   R30,Y
	LDD  R31,Y+1
	CALL SUBOPT_0x1D
; 0000 02FA    delay_ms(50);
	CALL SUBOPT_0x10
; 0000 02FB }
	RJMP _0x20C002C
; .FEND
;#endif
;
;
;unsigned char TestButton(UCHAR bt)
; 0000 0300 {
_TestButton:
; .FSTART _TestButton
; 0000 0301     if(TestADCs()==(1<<bt))
;	bt -> Y+0
	RCALL _TestADCs
	MOV  R1,R30
	LD   R30,Y
	LDI  R26,LOW(1)
	LDI  R27,HIGH(1)
	CALL __LSLW12
	MOV  R26,R1
	LDI  R27,0
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x94
; 0000 0302         return TRUE;
	LDI  R30,LOW(1)
	RJMP _0x20C002E
; 0000 0303     else
_0x94:
; 0000 0304         return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C002E
; 0000 0305 }
; .FEND
;
;unsigned char TestADCs()
; 0000 0308 {
_TestADCs:
; .FSTART _TestADCs
; 0000 0309     unsigned char StateOfButtons=0;
; 0000 030A     ADC_DONE=FALSE;
	ST   -Y,R17
;	StateOfButtons -> R17
	LDI  R17,0
	LDI  R30,LOW(0)
	STS  _ADC_DONE,R30
; 0000 030B     ADMUX=(6 | (ADC_VREF_TYPE & 0xff)); //ADC6 ch=6, ADC7 ch=7
	LDI  R30,LOW(38)
	CALL SUBOPT_0x1F
; 0000 030C     // Delay needed for the stabilization of the ADC input voltage
; 0000 030D     delay_us(20);
; 0000 030E     // Start the AD conversion
; 0000 030F     ADCSRA|=0x40;
; 0000 0310     while(ADC_DONE==FALSE);
_0x96:
	LDS  R30,_ADC_DONE
	CPI  R30,0
	BREQ _0x96
; 0000 0311     if(adc_data<50)
	LDS  R26,_adc_data
	CPI  R26,LOW(0x32)
	BRSH _0x99
; 0000 0312         StateOfButtons|=1<<BUTTON_DOWN;
	ORI  R17,LOW(16)
; 0000 0313     else if(adc_data<150)
	RJMP _0x9A
_0x99:
	LDS  R26,_adc_data
	CPI  R26,LOW(0x96)
	BRSH _0x9B
; 0000 0314         StateOfButtons|=1<<BUTTON_STOP;
	ORI  R17,LOW(4)
; 0000 0315     ADC_DONE=FALSE;
_0x9B:
_0x9A:
	LDI  R30,LOW(0)
	STS  _ADC_DONE,R30
; 0000 0316     ADMUX=(7 | (ADC_VREF_TYPE & 0xff)); //ADC6 ch=6, ADC7 ch=7
	LDI  R30,LOW(39)
	CALL SUBOPT_0x1F
; 0000 0317     // Delay needed for the stabilization of the ADC input voltage
; 0000 0318     delay_us(20);
; 0000 0319     // Start the AD conversion
; 0000 031A     ADCSRA|=0x40;
; 0000 031B     while(ADC_DONE==FALSE);
_0x9C:
	LDS  R30,_ADC_DONE
	CPI  R30,0
	BREQ _0x9C
; 0000 031C     if(adc_data<50)
	LDS  R26,_adc_data
	CPI  R26,LOW(0x32)
	BRSH _0x9F
; 0000 031D         StateOfButtons|=1<<BUTTON_UP;
	ORI  R17,LOW(8)
; 0000 031E     else if(adc_data<150)
	RJMP _0xA0
_0x9F:
	LDS  R26,_adc_data
	CPI  R26,LOW(0x96)
	BRSH _0xA1
; 0000 031F         StateOfButtons|=1<<BUTTON_START;
	ORI  R17,LOW(2)
; 0000 0320     if(StateOfButtons)
_0xA1:
_0xA0:
	CPI  R17,0
	BREQ _0xA2
; 0000 0321         return StateOfButtons;
	MOV  R30,R17
	JMP  _0x20C0029
; 0000 0322     return (1<<BUTTONS_RELEASED);
_0xA2:
	LDI  R30,LOW(1)
	JMP  _0x20C0029
; 0000 0323 }
; .FEND
;
;void StartADC(unsigned char ch)
; 0000 0326 {
; 0000 0327     char num1[3];
; 0000 0328     unsigned char chan=ch;
; 0000 0329     ADC_DONE=FALSE;
;	ch -> Y+4
;	num1 -> Y+1
;	chan -> R17
; 0000 032A     ADMUX=(ch | (ADC_VREF_TYPE & 0xff)); //ADC6 ch=6, ADC7 ch=7
; 0000 032B     // Delay needed for the stabilization of the ADC input voltage
; 0000 032C     delay_us(20);
; 0000 032D     // Start the AD conversion
; 0000 032E     ADCSRA|=0x40;
; 0000 032F     while(ADC_DONE==FALSE);
; 0000 0330 #ifdef DEBUG_BUTTONS
; 0000 0331     if(adc_data>150)
; 0000 0332         return;
; 0000 0333     lcd_clear();
; 0000 0334     lcd_putsf_row(0,"ADC");
; 0000 0335     itoa(ch,num1);
; 0000 0336     lcd_puts(num1);
; 0000 0337     lcd_putchar(' ');
; 0000 0338     itoa(adc_data,num1);
; 0000 0339     lcd_puts(num1);
; 0000 033A     if(chan==6){
; 0000 033B         if(adc_data<50)
; 0000 033C             lcd_putsf(" Down");
; 0000 033D         else if(adc_data<150)
; 0000 033E             lcd_putsf(" Stop");
; 0000 033F     }
; 0000 0340     else if(chan==7){
; 0000 0341         if(adc_data<50)
; 0000 0342             lcd_putsf(" Up");
; 0000 0343         else if(adc_data<150)
; 0000 0344             lcd_putsf(" Start");
; 0000 0345     }
; 0000 0346 #endif
; 0000 0347 }
;#define BEEP_ON_TIME_MS 100
;#define BEEP_OFF_TIME_MS 100
;#define TYPE_1  1
;#define TYPE_2  2
;
;void Beeps(UCHAR tone,UCHAR times)
; 0000 034E {
_Beeps:
; .FSTART _Beeps
; 0000 034F 
; 0000 0350     UINT beep_ms;
; 0000 0351     for(;times>0;times--)
	ST   -Y,R17
	ST   -Y,R16
;	tone -> Y+3
;	times -> Y+2
;	beep_ms -> R16,R17
_0xA7:
	LDD  R26,Y+2
	CPI  R26,LOW(0x1)
	BRLO _0xA8
; 0000 0352     {
; 0000 0353         for(beep_ms=BEEP_ON_TIME_MS;beep_ms>0;beep_ms--)
	__GETWRN 16,17,100
_0xAA:
	CLR  R0
	CP   R0,R16
	CPC  R0,R17
	BRSH _0xAB
; 0000 0354         {
; 0000 0355            BUZ_TGL();
	SBIS 0xB,6
	RJMP _0xAC
	CBI  0xB,6
	RJMP _0xAD
_0xAC:
	SBI  0xB,6
_0xAD:
; 0000 0356            delay_ms(tone);
	LDD  R30,Y+3
	LDI  R31,0
	CALL SUBOPT_0x17
; 0000 0357         }
	__SUBWRN 16,17,1
	RJMP _0xAA
_0xAB:
; 0000 0358         delay_ms(BEEP_OFF_TIME_MS);
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	CALL SUBOPT_0x17
; 0000 0359     }
	LDD  R30,Y+2
	SUBI R30,LOW(1)
	STD  Y+2,R30
	RJMP _0xA7
_0xA8:
; 0000 035A }
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,4
	RET
; .FEND
;/*****************************************************************************
;Ôàéë: avr910.ñ
;
;Creted by PROTTOSS
;Mail to PROTTOSS@mail.ru
;
;Ýìóëÿòîð AVR910
;
;16.12.2006
;******************************************************************************/
;//#include "usbdrv.h"
;
;#include "common.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif
;#include "avr910.h"
;#include "avr910devices.h"
;//#include <stdlib.h>
;#include <string.h>
;#include <delay.h>
;#include <stdio.h>
;/*****************************************************************************
;Óñòàíîâêè ïðîãðàììàòîðà
;******************************************************************************/
;
;
;
;//#define LOW_SCK_DELEY()	delay_us(tmpimage.spidiv)//#asm("nop")//			//300 // êîëè÷åñòâî òàêòîâ ÌÊ äëÿ ÷àñòîòû 20 êÃö (2 ...
;#define FUSE_SCK_DELEY  delay_us(250)   // Fuse write clock low freq 100us+100us=200us 5kHz
;//#define SPI_ON()	//SPCR = ((0 << SPR1) | (1 << SPR0) | (1 << SPE)| (1 << MSTR) )   //250kHz
;//#define SPI_OFF()	//SPCR = 0
;
;void LOW_SCK_DELEY()
; 0001 0020 {

	.CSEG
_LOW_SCK_DELEY:
; .FSTART _LOW_SCK_DELEY
; 0001 0021 	unsigned char us_cnt = tmpimage.spidiv;
; 0001 0022     if (us_cnt==0)
	ST   -Y,R17
;	us_cnt -> R17
	__GETB1MN _tmpimage,93
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x20003
; 0001 0023         us_cnt=1;
	LDI  R17,LOW(1)
; 0001 0024     while(us_cnt){
_0x20003:
_0x20004:
	CPI  R17,0
	BREQ _0x20006
; 0001 0025         us_cnt--;
	SUBI R17,1
; 0001 0026         delay_us(2);
	__DELAY_USB 8
; 0001 0027     }
	RJMP _0x20004
_0x20006:
; 0001 0028 }
	RJMP _0x20C0029
; .FEND
;
;
;/*****************************************************************************
;Ãëîáàëüíûå ïåðåìåííûå
;******************************************************************************/
;BOOL    g_IsFuseClock;
;UCHAR	g_DeviceType;		// òèï âûáðàííîãî ÌÊ
;
;UCHAR	g_DeviceCode;
;UCHAR	g_DevicePollCode;	// êîä ïîëëèíãà èëè ðàçìåð áóôåðà ñòðàíèö óñòðîéñòâà
;UINT 	g_Addr; 			// àäðåñ ïàìÿòè â óñòðîéñòâå
;
;// ñòðóêòóðà áóôåðà ïðèíèìàåìûõ îò USB äàííûõ
;BOOL	g_BlockMode;		// ôëàã çàïèñè/÷òåíèÿ â áëî÷íîì ðåæèìå
;ULONG	g_BlockSize;		// îñòàòî÷íûé ðàçìåð áëîêà //support 64k...
;UCHAR	g_MemType;			// òèï ïàìÿòè â áëî÷íîì ðåæèìå
;UCHAR	g_WordCount;		// êîëè÷åñòâî çàãðóæåííûõ â ÌÊ áàéò/ñëîâ â áëî÷íîì ðåæèìå
;UCHAR	g_Operation;		// òèï âûïîëíÿåìîé áëî÷íîé îïåðàöèè
;UCHAR	g_Command;			// èñïîëíÿåìàÿ â òåêóùèé ìîìåíò êîìàíäà
;BOOL	g_NeedParams;		// ôëàã îæèäàíèÿ ïàðàìåòðîâ êîìàíäû
;
;// ñòðóêòóðà FIFO áóôåðà êîìàíä/äàííûõ
;UCHAR	g_FIFO[AVR910_FIFO_SIZE]; // ñîáñòâåííî áóôåð
;UCHAR	g_wrI;			// èíäåêñ äëÿ çàïèñè â áóôåð
;UCHAR	g_rdI;			// èíäåêñ äëÿ ÷òåíèÿ èç áóôåðà
;UCHAR	g_FIFODataSize; // ðàçìåð äàííûõ â áóôåðå
;
;// ñòðóêòóðà ïåðåäàâàåìûõ â USB äàííûõ
;UCHAR	g_txBuf[AVR910_TX_DATA_SIZE];	// áóôåð ïåðåäàâàåìûõ äàííûõ
;UCHAR 	g_txWR;			// èíäåêñ íà÷àëà çàïèñûâàåìûõ äàííûõ
;UCHAR	g_txRD;			// èíäåêñ íà÷àëà ÷èòàåìûõ äàííûõ
;
;// ñòðîêà èäåíòèôèêàòîðà
;flash UCHAR SwID[] =
;{
;  	'A', 'V', 'R', ' ', 'I', 'S', 'P', 0 ,
;};
;
;/*****************************************************************************
;Ïðîòîòèïû ôóíêöèé
;******************************************************************************/
;
;// êîìàíäû SPI-èíñòðóêöèé AVR
;#define AVR_L_BYTE					0x00
;#define AVR_H_BYTE					0x08
;#define AVR_RD_BYTE					0x20
;#define AVR_WR_BYTE					0x40
;#define AVR_PROG_EN()				Write123(0xAC, 0x53, 0x00)
;#define AVR_CHIP_ERASE()			Write1234(0xAC, 0x80, 0x00, 0x00)
;#define AVR_POLL_READY()			Write1234(0xF0, 0x00, 0x00, 0x00)
;#define AVR_RD_FLASH_LB(addr)		Write1234(0x20, HIBYTE(addr), LOBYTE(addr), 0x00)
;#define AVR_RD_FLASH_HB(addr)		Write1234(0x28, HIBYTE(addr), LOBYTE(addr), 0x00)
;#define AVR_WR_FLASH_LB(addr, data)	Write1234(0x40, HIBYTE(addr), LOBYTE(addr), data)
;#define AVR_WR_FLASH_HB(addr, data)	Write1234(0x48, HIBYTE(addr), LOBYTE(addr), data)
;#define AVR_WR_FLASH_PAGE(addr)		Write1234(0x4C, HIBYTE(addr), LOBYTE(addr), 0x00)
;#define AVR_RD_EEPROM(addr)			Write1234(0xA0, HIBYTE(addr), LOBYTE(addr), 0x00)
;#define AVR_WR_EEPROM(addr, data)	Write1234(0xC0, HIBYTE(addr), LOBYTE(addr), data)
;#define AVR_RD_LOCK()				Write1234(0x58, 0x00, 0x00, 0x00)
;#define AVR_WR_LOCK(data)			Write1234(0xAC, data | 0xF9, 0x00, data)
;#define AVR_RD_SIGN(addr)			Write1234(0x30, 0x00, addr, 0x00)
;#define AVR_RD_FUSE()				Write1234(0x50, 0x00, 0x00, 0x00)
;#define AVR_WR_FUSE(data)			Write1234(0xAC, 0xA0, 0x00, data)
;#define AVR_RD_FUSE_H()				Write1234(0x58, 0x08, 0x00, 0x00)
;#define AVR_WR_FUSE_H(data)			Write1234(0xAC, 0xA8, 0x00, data)
;#define AVR_RD_FUSE_EXT()			Write1234(0x50, 0x08, 0x00, 0x00)
;#define AVR_WR_FUSE_EXT(data)		Write1234(0xAC, 0xA4, 0x00, data)
;#define AVR_RD_CALIBR(addr)			Write1234(0x38, 0xA8, addr, 0x00)
;
;// êîìàíäû SPI-èíñòðóêöèé 89S
;#define S89_ADDR_HBYTE(h_addr)		((h_addr << 3) | ((h_addr >> 3) & 0x04))
;#define S89_PROG_EN()				Write123(0xAC, 0x53, 0x00)
;#define S89_CHIP_ERASE()			Write123(0xAC, 0x04, 0x00)
;#define S89_RD_FLASH(addr)			Write123(S89_ADDR_HBYTE(HIBYTE(addr)) | 0x01, LOBYTE(addr), 0x00)
;#define S89_WR_FLASH(addr, data)	Write123(S89_ADDR_HBYTE(HIBYTE(addr)) | 0x02, LOBYTE(addr), data)
;#define S89_RD_EEPROM(addr)			Write123(S89_ADDR_HBYTE(HIBYTE(addr)) | 0x05, LOBYTE(addr), 0x00)
;#define S89_WR_EEPROM(addr, data)	Write123(S89_ADDR_HBYTE(HIBYTE(addr)) | 0x06, LOBYTE(addr), 0x00)
;#define S89_WR_LOCK(data)			Write123(0xAC, (data & 0xE0) | 0x07, 0x00)
;
;// òàéìèíãè äëÿ îïåðàöèé çàïèñè AVR
;#define AVR_DELAY_RESET()		delay_ms(20)//__delay_cycles(300000) // > 20 ms
;#define AVR_DELAY_WR_FUSE()		delay_ms(10)//__delay_cycles(150000)	// > 10 ms
;#define AVR_DELAY_WR_FLASH()	delay_ms(10)//__delay_cycles(150000)	// > 5 ms
;#define AVR_DELAY_WR_EEPROM()	delay_ms(10)//__delay_cycles(150000)	// > 10 mñ
;#define AVR_DELAY_ERASE()		delay_ms(20)//__delay_cycles(300000)	// > 20 mñ
;
;// òàéìèíãè äëÿ îïåðàöèé çàïèñè 89S
;#define S89_DELAY_RESET()		delay_ms(10)//__delay_cycles(150000)	// > 10 ms
;#define S89_DELAY_WR_FUSE()		delay_ms(10)//__delay_cycles(150000)	// > 10 ms
;#define S89_DELAY_WR_FLASH()	delay_us(2500)//__delay_cycles(30000)	// > 2,5 ms
;#define S89_DELAY_WR_EEPROM()	delay_us(2500)//__delay_cycles(30000)	// > 2,5 ms
;#define S89_DELAY_ERASE()		delay_ms(10)//__delay_cycles(150000)	// > 10 ms
;
;#define DELAY_RESET()			delay_ms(20)//__delay_cycles(300000)  // > 20 ms
;#define DELAY_WR_FUSE()			delay_ms(10)//__delay_cycles(150000) 	// > 10 ms
;#define DELAY_WR_FLASH()		delay_ms(10)//__delay_cycles(150000)	// > 10 ms
;#define DELAY_WR_EEPROM()		delay_ms(10)//__delay_cycles(150000)	// > 10 mñ
;#define DELAY_ERASE()			delay_ms(20)//__delay_cycles(300000)	// > 20 mñ
;
;//void AVR910_Init(void);
;//void AVR910_Command(UCHAR *data, UCHAR len);
;//UCHAR AVR910_IsRxData(UCHAR **data);
;//void AVR910_ClearTXData(UCHAR bytesRead);
;UCHAR ExSPI(UCHAR wr_data);
;void CatchPorts(void);
;void ReleasePorts(void);
;UCHAR GetOneChar(void);
;void PutOneChar(UCHAR data);
;UCHAR Write123(UCHAR byte1, UCHAR byte2, UCHAR byte3);
;UCHAR Write1234(UCHAR byte1, UCHAR byte2, UCHAR byte3, UCHAR byte4);
;void PollData(UCHAR command, UCHAR data);
;
;
;
;void CheckCommParams(UCHAR req_bytes);
;
;void SetProgMode(void);
;void GetDevCodes(void);
;void SetDevType(void);
;void SetLED(void);
;void ClrLED(void);
;void tx123rx4(void);
;void tx1234rx4(void);
;void GetBlockMode(void);
;void GetSWID(void);
;void GetSWVer(void);
;void GetHWVer(void);
;void GetAutoIncAddr(void);
;void SetAddr(void);
;void GetPROGType(void);
;void ChipErase(void);
;void WriteFuse(void);
;void WriteHFuse(void);
;void WriteEXTFuse(void);
;void WriteLock(void);
;void ReadLock(void);
;void ReadFuse(void);
;void ReadHFuse(void);
;void ReadEXTFuse(void);
;void ReadSignature(void);
;void LeaveProgMode(void);
;
;void WriteProgLB(void);
;void WriteProgHB(void);
;void WriteProgOneLB(void);
;void WriteProgOneHB(void);
;void WritePage(void);
;void ReadProg(UCHAR com_byte1, UCHAR com_byte2);
;void WriteData(void);
;void WriteOneData(void);
;void ReadData(void);
;void ReadBlockCommand(void);
;void WriteBlockCommand(void);
;void ReadBlock(void);
;void WriteBlock(void);
;/**********************
;Standalone addons
;***********************/
;void ReBoot(void);
;
;void AVR910_Standalone(flash char *commands)
; 0001 00C9 {
_AVR910_Standalone:
; .FSTART _AVR910_Standalone
; 0001 00CA    UCHAR i;
; 0001 00CB //   #ifdef PRINT_DEBUG
; 0001 00CC //   printf("\r\n Commands is: %p",commands);
; 0001 00CD //   while(tx_counter);
; 0001 00CE //   #endif
; 0001 00CF    AVR910_SendRxToUart();//clear send to uart tx buffer
	ST   -Y,R17
;	*commands -> Y+1
;	i -> R17
	RCALL _AVR910_SendRxToUart
; 0001 00D0    FIFO_Reset();
	RCALL _FIFO_Reset
; 0001 00D1    for(i=0;i<strlenf(commands);i++)
	LDI  R17,LOW(0)
_0x20008:
	CALL SUBOPT_0x20
	CALL _strlenf
	MOV  R26,R17
	LDI  R27,0
	CP   R26,R30
	CPC  R27,R31
	BRSH _0x20009
; 0001 00D2         FIFO_Write(commands[i]);
	MOV  R30,R17
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	LPM  R30,Z
	ST   -Y,R30
	RCALL _FIFO_Write
	SUBI R17,-1
	RJMP _0x20008
_0x20009:
; 0001 00D3 AVR910_Command();
	RCALL _AVR910_Command
; 0001 00D4 //   #ifdef PRINT_DEBUG
; 0001 00D5 //   printf("\r\n Response is: %c",g_txBuf[0]);
; 0001 00D6 //   while(tx_counter);
; 0001 00D7 //   #endif
; 0001 00D8 }
	LDD  R17,Y+0
	RJMP _0x20C002C
; .FEND
;/*****************************************************************************
;Èíèöèàëèçàöèÿ
;******************************************************************************/
;void AVR910_Init(void)
; 0001 00DD {
_AVR910_Init:
; .FSTART _AVR910_Init
; 0001 00DE   	// êîíôèãóðèðóåì âûâîäû ñâåòîäèîäîâ
; 0001 00DF   	//LED_DDR 	|= (1 << PIN_LED_WR) | (1 << PIN_LED_RD)| (1 << PIN_LED_PASS);
; 0001 00E0     //LED_PORT	&= ~((1 << PIN_LED_WR) | (1 << PIN_LED_RD)| (1 << PIN_LED_PASS));
; 0001 00E1     LED_OK_INIT();
	SBI  0x4,1
	SBI  0x5,1
; 0001 00E2     LED_ERR_INIT();
	SBI  0x4,0
	SBI  0x5,0
; 0001 00E3     MUX_SEL_INIT();
	SBI  0xA,7
	CBI  0xB,7
; 0001 00E4     ReleasePorts();
	RCALL _ReleasePorts
; 0001 00E5     // êîíôèãóðèðóåì âõîä low_sck
; 0001 00E6     //ISP_PORT	|= (1 << PIN_LOW_SCK); // ïîäòÿãèâàåì êî âõîäó ïóëëàï
; 0001 00E7     //ISP_DDR		&= ~(1 << PIN_LOW_SCK);	// êîíôèãóðèðóåì êàê âõîä
; 0001 00E8     //ISP_PORT	|= (1 << PIN_SS); // ïîäòÿãèâàåì êî âõîäó ïóëëàï
; 0001 00E9     //ISP_DDR		|= (1 << PIN_SS);	// êîíôèãóðèðóåì êàê âõîä
; 0001 00EA     // êîíôèãóðèðóåì òàéìåð-ñ÷åò÷èê TC1
; 0001 00EB //    TCCR1A = (0 << WGM11)| (0 << WGM10)|			   // CTC
; 0001 00EC //      		 (0 << COM1A1) | (1 << COM1A0);			   // Toggle OC1A on Compare Match
; 0001 00ED //	TCCR1B = (0 << CS12) | (0 << CS11) | (1 << CS10) | // clkIO /1 (No prescaling)
; 0001 00EE //      		 (0 << WGM13)| (1 << WGM12);			   // CTC
; 0001 00EF //    OCR1A  = (UINT)5;
; 0001 00F0 //
; 0001 00F1 //    // âûâîäèì ìåàíäð
; 0001 00F2 //	//ISP_DDR |= (1 << PIN_CLOCK);
; 0001 00F3 //    CLOCK_DDR |= (1 << PIN_CLOCK);
; 0001 00F4     // êîíôèãóðèðóåì SPI ïîðò
; 0001 00F5     //SPSR = 0x00; // î÷èùàåì SPI2X
; 0001 00F6 
; 0001 00F7     // èíèöèàëèçèðóåì AVR910 ãëîáàëüíûå ïåðåìåííûå
; 0001 00F8   	g_Addr = 0;
	LDI  R30,LOW(0)
	STS  _g_Addr,R30
	STS  _g_Addr+1,R30
; 0001 00F9     g_BlockMode = FALSE;
	STS  _g_BlockMode,R30
; 0001 00FA     g_NeedParams = FALSE;
	STS  _g_NeedParams,R30
; 0001 00FB     FIFO_Reset();
	RCALL _FIFO_Reset
; 0001 00FC     g_IsFuseClock=FALSE;
	RJMP _0x20C002B
; 0001 00FD     //ReleasePorts();
; 0001 00FE     //initBTN;
; 0001 00FF }
; .FEND
;
;/*****************************************************************************
;Ïðèåì ñîîáùåíèÿ
;******************************************************************************/
;//void AVR910_Command(UCHAR *data, UCHAR len)
;void AVR910_Command(void)
; 0001 0106 {
_AVR910_Command:
; .FSTART _AVR910_Command
; 0001 0107 	g_txWR = g_txRD = 0;	// ñáðàñûâàåì áóôåð ïåðåäà÷è
	LDI  R30,LOW(0)
	STS  _g_txRD,R30
	STS  _g_txWR,R30
; 0001 0108 
; 0001 0109     // êîïèðóåì äàííûå èç áóôåðà USB â FIFO ïðîãðàììàòîðà
; 0001 010A     //while(len--)
; 0001 010B     	//FIFO_Write(*data++);
; 0001 010C 
; 0001 010D 
; 0001 010E     // ñ÷èòûâàåì ïðèíÿòûå èç USB äàííûå
; 0001 010F 	while(0 < g_FIFODataSize)
_0x20016:
	LDS  R30,_g_FIFODataSize
	CPI  R30,LOW(0x1)
	BRSH PC+2
	RJMP _0x20018
; 0001 0110     {
; 0001 0111       	// ïðîâåðêà áëî÷íîãî ðåæèìà ðàáîòû
; 0001 0112       	if(TRUE == g_BlockMode)
	LDS  R30,_g_BlockMode
	CPI  R30,LOW(0x1)
	BRNE _0x20019
; 0001 0113     	{
; 0001 0114           	// ïðîâåðêà îïåðàöèè (çàïèñü, ÷òåíèå)
; 0001 0115           	if(OPERATION_WRITE == g_Operation)
	LDS  R30,_g_Operation
	CPI  R30,LOW(0x1)
	BRNE _0x2001A
; 0001 0116             {
; 0001 0117               	// áëî÷íàÿ îïåðàöèÿ çàïèñè
; 0001 0118               	WriteBlock();
	RCALL _WriteBlock
; 0001 0119             	continue;
	RJMP _0x20016
; 0001 011A             }
; 0001 011B             else
_0x2001A:
; 0001 011C             {
; 0001 011D               	// îïåðàöèÿ ÷òåíèÿ åùå íå çàêîí÷èëàñü
; 0001 011E               	// à ìû ïîëó÷èëè äàííûå - ïðåðûâàåì îïåðàöèþ ÷òåíèÿ è áëî÷íûé ðåæèì
; 0001 011F               	g_BlockMode = FALSE;
	LDI  R30,LOW(0)
	STS  _g_BlockMode,R30
; 0001 0120             }
; 0001 0121    		}
; 0001 0122 
; 0001 0123         // Ïðîâåðÿåì, îáðàáàòûâàåì ëè ìû êîìàíäó
; 0001 0124         if(FALSE == g_NeedParams)
_0x20019:
	LDS  R30,_g_NeedParams
	CPI  R30,0
	BRNE _0x2001C
; 0001 0125         	g_Command = GetOneChar();
	RCALL _GetOneChar
	STS  _g_Command,R30
; 0001 0126 
; 0001 0127 
; 0001 0128       	// Àíàëèçèðóåì êîìàíäó
; 0001 0129       	switch(g_Command)
_0x2001C:
	LDS  R30,_g_Command
	LDI  R31,0
; 0001 012A     	{
; 0001 012B         	case ESC:
	CPI  R30,LOW(0x1B)
	LDI  R26,HIGH(0x1B)
	CPC  R31,R26
	BRNE _0x20020
; 0001 012C             break;
	RJMP _0x2001F
; 0001 012D 			case 'P': SetProgMode();
_0x20020:
	CPI  R30,LOW(0x50)
	LDI  R26,HIGH(0x50)
	CPC  R31,R26
	BRNE _0x20021
	RCALL _SetProgMode
; 0001 012E       		break;
	RJMP _0x2001F
; 0001 012F 			case 'a': GetAutoIncAddr();
_0x20021:
	CPI  R30,LOW(0x61)
	LDI  R26,HIGH(0x61)
	CPC  R31,R26
	BRNE _0x20022
	RCALL _GetAutoIncAddr
; 0001 0130 			break;
	RJMP _0x2001F
; 0001 0131 			case 'A': SetAddr();
_0x20022:
	CPI  R30,LOW(0x41)
	LDI  R26,HIGH(0x41)
	CPC  R31,R26
	BRNE _0x20023
	RCALL _SetAddr
; 0001 0132 			break;
	RJMP _0x2001F
; 0001 0133 			case 'S': GetSWID();
_0x20023:
	CPI  R30,LOW(0x53)
	LDI  R26,HIGH(0x53)
	CPC  R31,R26
	BRNE _0x20024
	RCALL _GetSWID
; 0001 0134         	break;
	RJMP _0x2001F
; 0001 0135 			case 'V': GetSWVer();
_0x20024:
	CPI  R30,LOW(0x56)
	LDI  R26,HIGH(0x56)
	CPC  R31,R26
	BRNE _0x20025
	RCALL _GetSWVer
; 0001 0136         	break;
	RJMP _0x2001F
; 0001 0137 			case 'v': GetHWVer();
_0x20025:
	CPI  R30,LOW(0x76)
	LDI  R26,HIGH(0x76)
	CPC  R31,R26
	BRNE _0x20026
	RCALL _GetHWVer
; 0001 0138         	break;
	RJMP _0x2001F
; 0001 0139 			case 'p': GetPROGType();
_0x20026:
	CPI  R30,LOW(0x70)
	LDI  R26,HIGH(0x70)
	CPC  R31,R26
	BRNE _0x20027
	RCALL _GetPROGType
; 0001 013A         	break;
	RJMP _0x2001F
; 0001 013B             case 'T': SetDevType();
_0x20027:
	CPI  R30,LOW(0x54)
	LDI  R26,HIGH(0x54)
	CPC  R31,R26
	BRNE _0x20028
	RCALL _SetDevType
; 0001 013C         	break;
	RJMP _0x2001F
; 0001 013D             case 't': GetDevCodes();
_0x20028:
	CPI  R30,LOW(0x74)
	LDI  R26,HIGH(0x74)
	CPC  R31,R26
	BRNE _0x20029
	RCALL _GetDevCodes
; 0001 013E         	break;
	RJMP _0x2001F
; 0001 013F             case 'x': SetLED();
_0x20029:
	CPI  R30,LOW(0x78)
	LDI  R26,HIGH(0x78)
	CPC  R31,R26
	BRNE _0x2002A
	RCALL _SetLED
; 0001 0140         	break;
	RJMP _0x2001F
; 0001 0141 			case 'y': ClrLED();
_0x2002A:
	CPI  R30,LOW(0x79)
	LDI  R26,HIGH(0x79)
	CPC  R31,R26
	BRNE _0x2002B
	RCALL _ClrLED
; 0001 0142         	break;
	RJMP _0x2001F
; 0001 0143 			case ':': tx123rx4();
_0x2002B:
	CPI  R30,LOW(0x3A)
	LDI  R26,HIGH(0x3A)
	CPC  R31,R26
	BRNE _0x2002C
	RCALL _tx123rx4
; 0001 0144         	break;
	RJMP _0x2001F
; 0001 0145 			case '.': tx1234rx4();
_0x2002C:
	CPI  R30,LOW(0x2E)
	LDI  R26,HIGH(0x2E)
	CPC  R31,R26
	BRNE _0x2002D
	RCALL _tx1234rx4
; 0001 0146         	break;
	RJMP _0x2001F
; 0001 0147 			case 'b': GetBlockMode();
_0x2002D:
	CPI  R30,LOW(0x62)
	LDI  R26,HIGH(0x62)
	CPC  R31,R26
	BRNE _0x2002E
	RCALL _GetBlockMode
; 0001 0148 			break;
	RJMP _0x2001F
; 0001 0149         	case 'e': ChipErase();
_0x2002E:
	CPI  R30,LOW(0x65)
	LDI  R26,HIGH(0x65)
	CPC  R31,R26
	BRNE _0x2002F
	RCALL _ChipErase
; 0001 014A         	break;
	RJMP _0x2001F
; 0001 014B             case 'E': ReBoot(); // External commands
_0x2002F:
	CPI  R30,LOW(0x45)
	LDI  R26,HIGH(0x45)
	CPC  R31,R26
	BRNE _0x20030
	RCALL _ReBoot
; 0001 014C         	break;
	RJMP _0x2001F
; 0001 014D             case 'L': LeaveProgMode();
_0x20030:
	CPI  R30,LOW(0x4C)
	LDI  R26,HIGH(0x4C)
	CPC  R31,R26
	BRNE _0x20031
	RCALL _LeaveProgMode
; 0001 014E         	break;
	RJMP _0x2001F
; 0001 014F         	case 'l': WriteLock();
_0x20031:
	CPI  R30,LOW(0x6C)
	LDI  R26,HIGH(0x6C)
	CPC  R31,R26
	BRNE _0x20032
	RCALL _WriteLock
; 0001 0150         	break;
	RJMP _0x2001F
; 0001 0151 			case 'f': WriteFuse();
_0x20032:
	CPI  R30,LOW(0x66)
	LDI  R26,HIGH(0x66)
	CPC  R31,R26
	BRNE _0x20033
	RCALL _WriteFuse
; 0001 0152         	break;
	RJMP _0x2001F
; 0001 0153 			case 'Q': ReadLock();
_0x20033:
	CPI  R30,LOW(0x51)
	LDI  R26,HIGH(0x51)
	CPC  R31,R26
	BRNE _0x20034
	RCALL _ReadLock
; 0001 0154        		break;
	RJMP _0x2001F
; 0001 0155             case 'F': ReadFuse();
_0x20034:
	CPI  R30,LOW(0x46)
	LDI  R26,HIGH(0x46)
	CPC  R31,R26
	BRNE _0x20035
	RCALL _ReadFuse
; 0001 0156        		break;
	RJMP _0x2001F
; 0001 0157 			case 'n': WriteHFuse();
_0x20035:
	CPI  R30,LOW(0x6E)
	LDI  R26,HIGH(0x6E)
	CPC  R31,R26
	BRNE _0x20036
	RCALL _WriteHFuse
; 0001 0158        		break;
	RJMP _0x2001F
; 0001 0159             case 'N': ReadHFuse();
_0x20036:
	CPI  R30,LOW(0x4E)
	LDI  R26,HIGH(0x4E)
	CPC  R31,R26
	BRNE _0x20037
	RCALL _ReadHFuse
; 0001 015A        		break;
	RJMP _0x2001F
; 0001 015B             case 'o': WriteEXTFuse();
_0x20037:
	CPI  R30,LOW(0x6F)
	LDI  R26,HIGH(0x6F)
	CPC  R31,R26
	BRNE _0x20038
	RCALL _WriteEXTFuse
; 0001 015C        		break;
	RJMP _0x2001F
; 0001 015D             case 'O': ReadEXTFuse();
_0x20038:
	CPI  R30,LOW(0x4F)
	LDI  R26,HIGH(0x4F)
	CPC  R31,R26
	BRNE _0x20039
	RCALL _ReadEXTFuse
; 0001 015E        		break;
	RJMP _0x2001F
; 0001 015F             case 's': ReadSignature();
_0x20039:
	CPI  R30,LOW(0x73)
	LDI  R26,HIGH(0x73)
	CPC  R31,R26
	BRNE _0x2003A
	RCALL _ReadSignature
; 0001 0160         	break;
	RJMP _0x2001F
; 0001 0161             case 'd': ReadData();
_0x2003A:
	CPI  R30,LOW(0x64)
	LDI  R26,HIGH(0x64)
	CPC  R31,R26
	BRNE _0x2003B
	RCALL _ReadData
; 0001 0162         	break;
	RJMP _0x2001F
; 0001 0163 			case 'g': ReadBlockCommand();
_0x2003B:
	CPI  R30,LOW(0x67)
	LDI  R26,HIGH(0x67)
	CPC  R31,R26
	BRNE _0x2003C
	RCALL _ReadBlockCommand
; 0001 0164 			break;
	RJMP _0x2001F
; 0001 0165 			case 'B': WriteBlockCommand();
_0x2003C:
	CPI  R30,LOW(0x42)
	LDI  R26,HIGH(0x42)
	CPC  R31,R26
	BRNE _0x2003D
	RCALL _WriteBlockCommand
; 0001 0166 			break;
	RJMP _0x2001F
; 0001 0167             case 'R': ReadProg(0x28, 0x20);
_0x2003D:
	CPI  R30,LOW(0x52)
	LDI  R26,HIGH(0x52)
	CPC  R31,R26
	BRNE _0x2003E
	LDI  R30,LOW(40)
	ST   -Y,R30
	LDI  R30,LOW(32)
	ST   -Y,R30
	RCALL _ReadProg
; 0001 0168         	break;
	RJMP _0x2001F
; 0001 0169         	case 'c': WriteProgOneLB();
_0x2003E:
	CPI  R30,LOW(0x63)
	LDI  R26,HIGH(0x63)
	CPC  R31,R26
	BRNE _0x2003F
	RCALL _WriteProgOneLB
; 0001 016A             break;
	RJMP _0x2001F
; 0001 016B 			case 'C': WriteProgOneHB();
_0x2003F:
	CPI  R30,LOW(0x43)
	LDI  R26,HIGH(0x43)
	CPC  R31,R26
	BRNE _0x20040
	RCALL _WriteProgOneHB
; 0001 016C             break;
	RJMP _0x2001F
; 0001 016D 			case 'm': WritePage(); PutOneChar(ACK);// OK
_0x20040:
	CPI  R30,LOW(0x6D)
	LDI  R26,HIGH(0x6D)
	CPC  R31,R26
	BRNE _0x20041
	RCALL _WritePage
	LDI  R30,LOW(13)
	RJMP _0x20164
; 0001 016E         	break;
; 0001 016F 			case 'D': WriteOneData();
_0x20041:
	CPI  R30,LOW(0x44)
	LDI  R26,HIGH(0x44)
	CPC  R31,R26
	BRNE _0x20043
	RCALL _WriteOneData
; 0001 0170        		break;
	RJMP _0x2001F
; 0001 0171 			default: PutOneChar(NACK);
_0x20043:
	LDI  R30,LOW(63)
_0x20164:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 0172           	break;
; 0001 0173     	}
_0x2001F:
; 0001 0174 
; 0001 0175         // åñëè áàéò ïàðàìåòðîâ êîìàíäû íå õâàòàåò, æäåì
; 0001 0176         if(TRUE == g_NeedParams)
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	BREQ _0x20018
; 0001 0177           	break;
; 0001 0178     }
	RJMP _0x20016
_0x20018:
; 0001 0179 }
	RET
; .FEND
;void ReBoot(void)
; 0001 017B {
_ReBoot:
; .FSTART _ReBoot
; 0001 017C     CHAR param;
; 0001 017D     CheckCommParams(1);
	CALL SUBOPT_0x21
;	param -> R17
; 0001 017E     if(TRUE == g_NeedParams)
	BRNE _0x20045
; 0001 017F       	return;
	RJMP _0x20C0029
; 0001 0180 
; 0001 0181     param = GetOneChar();
_0x20045:
	RCALL _GetOneChar
	MOV  R17,R30
; 0001 0182     switch(param){
	LDI  R31,0
	SBRC R30,7
	SER  R31
; 0001 0183        case 'D':PrintImage();
	CPI  R30,LOW(0x44)
	LDI  R26,HIGH(0x44)
	CPC  R31,R26
	BRNE _0x20049
	CALL _PrintImage
; 0001 0184             break;
	RJMP _0x20048
; 0001 0185        case 'R':SetValueReady("ready",'0');
_0x20049:
	CPI  R30,LOW(0x52)
	LDI  R26,HIGH(0x52)
	CPC  R31,R26
	BRNE _0x2004A
	__POINTW1FN _0x20000,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(48)
	ST   -Y,R30
	CALL _SetValueReady
; 0001 0186                 Call_GetDir();
	CALL _Call_GetDir
; 0001 0187             break;
	RJMP _0x20048
; 0001 0188        case '.':
_0x2004A:
	CPI  R30,LOW(0x2E)
	LDI  R26,HIGH(0x2E)
	CPC  R31,R26
	BRNE _0x2004D
; 0001 0189        {
; 0001 018A            #asm("WDR")
	WDR
; 0001 018B             WDTCSR=0x18;
	LDI  R30,LOW(24)
	STS  96,R30
; 0001 018C             WDTCSR=0x08|0x07;//2sec
	LDI  R30,LOW(15)
	STS  96,R30
; 0001 018D             #ifdef  PRINT_DEBUG
; 0001 018E             if(debug)printf("\r\nRebooting to bootlader...");
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x2004C
	__POINTW1FN _0x20000,6
	CALL SUBOPT_0x22
; 0001 018F             #endif
; 0001 0190             //delay_ms(1000);
; 0001 0191             //((void(*)(void))(char *)0x3C00)(); // jump to 0x0000
; 0001 0192        }
_0x2004C:
; 0001 0193             break;
; 0001 0194        default:
_0x2004D:
; 0001 0195             break;
; 0001 0196     }
_0x20048:
; 0001 0197 
; 0001 0198 }
	RJMP _0x20C0029
; .FEND
;/*****************************************************************************
;Çàïèñûâàåò â ïåðåìåííóþ data àäðåñ íà÷àëà äàííûõ è âîçâðàùàåò â ïåðåìåííîé
;g_txLen êîëè÷åñòâî äàííûõ
;******************************************************************************/
;UCHAR AVR910_IsRxData(UCHAR **data)
; 0001 019E {
_AVR910_IsRxData:
; .FSTART _AVR910_IsRxData
; 0001 019F   	*data = &g_txBuf[g_txRD]; // óñòàíàâëèâàåì àäðåñ íà÷àëà ÷èòàåìûõ äàííûõ
;	*data -> Y+0
	LDS  R30,_g_txRD
	LDI  R31,0
	SUBI R30,LOW(-_g_txBuf)
	SBCI R31,HIGH(-_g_txBuf)
	LD   R26,Y
	LDD  R27,Y+1
	ST   X+,R30
	ST   X,R31
; 0001 01A0   	return (g_txWR - g_txRD); // âîçâðàùàåì äëèíó äàííûõ
	LDS  R26,_g_txRD
	LDS  R30,_g_txWR
	SUB  R30,R26
	RJMP _0x20C002D
; 0001 01A1 }
; .FEND
;
;/*****************************************************************************
;Îñâîáîæäàåò áóôåð äàííûõ îò ïåðåäàííûõ â USB äàííûõ
;â ïåðåìåííîé bytesRead ñîäåðæèòñÿ êîëè÷åñòâî ïðî÷èòàííûõ äàííûõ èç áóôåðà
;äàííûõ.
;******************************************************************************/
;void AVR910_ResetTXData(void)
; 0001 01A9 {
_AVR910_ResetTXData:
; .FSTART _AVR910_ResetTXData
; 0001 01AA    g_txRD = g_txWR = 0;
	LDI  R30,LOW(0)
	STS  _g_txWR,R30
	STS  _g_txRD,R30
; 0001 01AB }
	RET
; .FEND
;void AVR910_ClearTXData(UCHAR bytesRead)
; 0001 01AD {
_AVR910_ClearTXData:
; .FSTART _AVR910_ClearTXData
; 0001 01AE   	// î÷èùàåì áóôåð îò ïðî÷èòàííûõ äàííûõ è
; 0001 01AF     // âû÷èñëÿåì íîâûé óêàçàòåëü äàííûõ
; 0001 01B0     g_txRD += bytesRead;
;	bytesRead -> Y+0
	LD   R30,Y
	LDS  R26,_g_txRD
	ADD  R30,R26
	STS  _g_txRD,R30
; 0001 01B1 
; 0001 01B2     // ïðîâåðÿåì, ïóñò ëè áóôåð
; 0001 01B3     if(g_txRD == g_txWR)
	LDS  R30,_g_txWR
	LDS  R26,_g_txRD
	CP   R30,R26
	BRNE _0x2004E
; 0001 01B4     {
; 0001 01B5       	// åñëè äà, òî ñáðàñûâàåì áóôåð â íîëü è
; 0001 01B6     	// ïðîâåðÿåì áëî÷íûé ðåæèì ðàáîòû è îïåðàöèþ ÷òåíèÿ
; 0001 01B7     	g_txRD = g_txWR = 0;
	LDI  R30,LOW(0)
	STS  _g_txWR,R30
	STS  _g_txRD,R30
; 0001 01B8 		if((TRUE == g_BlockMode) &&
; 0001 01B9            (OPERATION_READ == g_Operation))
	LDS  R30,_g_BlockMode
	CPI  R30,LOW(0x1)
	BRNE _0x20050
	LDS  R30,_g_Operation
	CPI  R30,0
	BREQ _0x20051
_0x20050:
	RJMP _0x2004F
_0x20051:
; 0001 01BA     		ReadBlock();
	RCALL _ReadBlock
; 0001 01BB     }
_0x2004F:
; 0001 01BC }
_0x2004E:
_0x20C002E:
	ADIW R28,1
	RET
; .FEND
;void AVR910_SendRxToUart(void)
; 0001 01BE {
_AVR910_SendRxToUart:
; .FSTART _AVR910_SendRxToUart
; 0001 01BF     UCHAR *data;
; 0001 01C0     UCHAR bytesRead;
; 0001 01C1     while((bytesRead = AVR910_IsRxData(&data)) > 0){
	CALL __SAVELOCR4
;	*data -> R16,R17
;	bytesRead -> R19
_0x20052:
	IN   R30,SPL
	IN   R31,SPH
	SBIW R30,1
	ST   -Y,R31
	ST   -Y,R30
	PUSH R17
	PUSH R16
	RCALL _AVR910_IsRxData
	POP  R16
	POP  R17
	MOV  R19,R30
	CPI  R30,LOW(0x1)
	BRLO _0x20054
; 0001 01C2        AVR910_ClearTXData(bytesRead);
	ST   -Y,R19
	RCALL _AVR910_ClearTXData
; 0001 01C3        while(bytesRead--)
_0x20055:
	MOV  R30,R19
	SUBI R19,1
	CPI  R30,0
	BREQ _0x20057
; 0001 01C4             putchar(*data++);
	MOVW R26,R16
	__ADDWRN 16,17,1
	LD   R30,X
	ST   -Y,R30
	CALL _putchar
	RJMP _0x20055
_0x20057:
; 0001 01C7 }
	RJMP _0x20052
_0x20054:
; 0001 01C8 }
	RJMP _0x20C0023
; .FEND
;/*****************************************************************************
;Îáìåí äàííûìè ïî SPI
;çàïèñûâàåò â SPI ïîðò äàííûå wr_data è âîçâðàùàåò ïðî÷èòàííûå ïðè îáìåíå äàííûå
;******************************************************************************/
;UCHAR ExSPI(UCHAR wr_data)
; 0001 01CE {
_ExSPI:
; .FSTART _ExSPI
; 0001 01CF   	UCHAR i;
; 0001 01D0     // ïðîâåðÿåì äæàìïåð low_sck
; 0001 01D1 //  	if(ISP_PIN & (1 << PIN_LOW_SCK)) // íå çàìêíóò, àïïàðàòíûé SPI
; 0001 01D2 //	{
; 0001 01D3 //        SPI_ON();	// âêëþ÷àåì SPI
; 0001 01D4 //        SPDR = wr_data;	// çàãðóæàåì SPI äàííûìè
; 0001 01D5 //        while(!(SPSR & (1<<SPIF))){};	// æäåì îêîí÷àíèÿ ïåðåäà÷è
; 0001 01D6 //		return SPDR;	// âîçâðàùàåì ïðèíÿòûå äàííûå
; 0001 01D7 //    }
; 0001 01D8 //    else // èíà÷å ñîôòâåðíûé SPI
; 0001 01D9     {
	ST   -Y,R17
;	wr_data -> Y+1
;	i -> R17
; 0001 01DA       	UCHAR rd_data=0;
; 0001 01DB         //SPI_OFF();	// âûêëþ÷àåì àïïàðàòíûé SPI
; 0001 01DC       	for(i = 0; i < 8; i++)
	SBIW R28,1
	LDI  R30,LOW(0)
	ST   Y,R30
;	wr_data -> Y+2
;	rd_data -> Y+0
	LDI  R17,LOW(0)
_0x20059:
	CPI  R17,8
	BRSH _0x2005A
; 0001 01DD         {
; 0001 01DE           	// îòïðàâëÿåì ñòàðøèé áèò îòïðàâëÿåìîãî áàéòà
; 0001 01DF           	if(0 != (wr_data & 0x80))
	LDD  R30,Y+2
	ANDI R30,LOW(0x80)
	BREQ _0x2005B
; 0001 01E0             	SET_MOSI();//ISP_PORT |= (1 << PIN_MOSI); // = 1
	SBI  0xB,3
; 0001 01E1             else
	RJMP _0x2005E
_0x2005B:
; 0001 01E2             	CLR_MOSI();//ISP_PORT &= ~(1 << PIN_MOSI);	// = 0
	CBI  0xB,3
; 0001 01E3 
; 0001 01E4             // ïîäãîòàâëèâàåì ñëåäóþùèé áèò
; 0001 01E5         	wr_data <<=1;
_0x2005E:
	LDD  R30,Y+2
	LSL  R30
	STD  Y+2,R30
; 0001 01E6 
; 0001 01E7             // ïðèíèìàåì î÷åðåäíîé (íà÷èíàÿ ñî ñòàðøåãî) áèò
; 0001 01E8             // ïðèíèìàåìîãî áàéòà
; 0001 01E9             rd_data <<= 1;
	LD   R30,Y
	LSL  R30
	ST   Y,R30
; 0001 01EA             if(0 != READ_MISO())//(ISP_PIN & (1 << PIN_MISO)))
	SBIS 0x9,2
	RJMP _0x20061
; 0001 01EB             	rd_data++; // óñòàíàâëèâàåì åäèíè÷íûé áèò, åñëè âûñîêèé ïðèíèìàåìûé óðîâåíü
	LD   R30,Y
	SUBI R30,-LOW(1)
	ST   Y,R30
; 0001 01EC 
; 0001 01ED 			// ôîðìèðóåì èìïóëüñ íà âûâîäå SCK ÌÊ
; 0001 01EE             SET_SCK();//ISP_PORT |= (1 << PIN_SCK);	// âûñîêèé
_0x20061:
	SBI  0xB,7
; 0001 01EF             if(g_IsFuseClock==TRUE)
	LDI  R30,LOW(1)
	CP   R30,R10
	BRNE _0x20064
; 0001 01F0                 FUSE_SCK_DELEY;
	__DELAY_USW 750
; 0001 01F1             else
	RJMP _0x20065
_0x20064:
; 0001 01F2                 LOW_SCK_DELEY(); // çàäåðæêà
	RCALL _LOW_SCK_DELEY
; 0001 01F3             CLR_SCK();//ISP_PORT &= ~(1 << PIN_SCK);	// íèçêèé
_0x20065:
	CBI  0xB,7
; 0001 01F4             if(g_IsFuseClock==TRUE)
	LDI  R30,LOW(1)
	CP   R30,R10
	BRNE _0x20068
; 0001 01F5                 FUSE_SCK_DELEY;
	__DELAY_USW 750
; 0001 01F6             else
	RJMP _0x20069
_0x20068:
; 0001 01F7                 LOW_SCK_DELEY(); // çàäåðæêà
	RCALL _LOW_SCK_DELEY
; 0001 01F8     	}
_0x20069:
	SUBI R17,-1
	RJMP _0x20059
_0x2005A:
; 0001 01F9 
; 0001 01FA         return rd_data;
	LD   R30,Y
	ADIW R28,1
	LDD  R17,Y+0
_0x20C002D:
	ADIW R28,2
	RET
; 0001 01FB     }
	ADIW R28,1
; 0001 01FC }
; .FEND
;
;/*****************************************************************************
;Óñòàíîâèòü ïîðòû â ðàáî÷åå ñîñòîÿíèå
;******************************************************************************/
;void CatchPorts(void)
; 0001 0202 {
_CatchPorts:
; .FSTART _CatchPorts
; 0001 0203   	// ïîäêëþ÷àåì âûâîäû SPI ê ISP ðàçúåìó
; 0001 0204   	//ISP_DDR  |= (1 << PIN_SCK) | (1 << PIN_MOSI) | (1 << PIN_RESET);
; 0001 0205 
; 0001 0206     // ïîäòÿãèâàåì ïóëëàï ê âûâîäó MISO
; 0001 0207     //ISP_PORT |= (1 << PIN_MISO);
; 0001 0208     ISP_ON();
	SBI  0xA,5
	CBI  0xB,5
	SBI  0xA,3
	CBI  0xB,3
	CBI  0xA,2
	SBI  0xB,2
	SBI  0xA,7
	CBI  0xB,7
; 0001 0209     // ðàçðåøàåì SPI è óñòàíàâëèâàåì ñêîðîñòü
; 0001 020A     //SPI_ON();
; 0001 020B 
; 0001 020C     // ïåðåâîäèì RESET â àêòèâíîå ñîñòîÿíèå
; 0001 020D     if(g_DeviceType == S89)
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	BRNE _0x2007A
; 0001 020E       	SET_RESET();
	CBI  0xB,5
; 0001 020F     else
	RJMP _0x2007D
_0x2007A:
; 0001 0210       	CLR_RESET();
	SBI  0xB,5
; 0001 0211 }
_0x2007D:
	RET
; .FEND
;
;/*****************************************************************************
;Îòêëþ÷èòü ïîðòû
;******************************************************************************/
;void ReleasePorts(void)
; 0001 0217 {
_ReleasePorts:
; .FSTART _ReleasePorts
; 0001 0218   	// çàïðåùàåì SPI
; 0001 0219   	//SPI_OFF();
; 0001 021A     ISP_OFF();
	CBI  0xA,5
	CBI  0xB,5
	CBI  0xA,3
	CBI  0xB,3
	CBI  0xB,2
	CBI  0xA,7
	CBI  0xB,7
; 0001 021B     #ifdef PRINT_LCD
; 0001 021C     PORTC&=~0x3F;
	IN   R30,0x8
	ANDI R30,LOW(0xC0)
	OUT  0x8,R30
; 0001 021D     DDRC|=0x3F; //enable lcd control
	IN   R30,0x7
	ORI  R30,LOW(0x3F)
	OUT  0x7,R30
; 0001 021E     #endif
; 0001 021F     // îòêëþ÷àåì âûâîäû SPI îò ISP ðàçúåìà
; 0001 0220   	//ISP_DDR &=  ~((1 << PIN_SCK) | (1 << PIN_MISO) | (1 << PIN_MOSI) | (1 << PIN_RESET));
; 0001 0221     //ISP_PORT &= ~((1 << PIN_SCK) | (1 << PIN_MISO) | (1 << PIN_MOSI) | (1 << PIN_RESET));
; 0001 0222 }
	RET
; .FEND
;
;/*****************************************************************************
;Âîçâðàùàåò äàííûå èç áóôåðà ïðèåìíèêà USB
;******************************************************************************/
;UCHAR GetOneChar(void)
; 0001 0228 {
_GetOneChar:
; .FSTART _GetOneChar
; 0001 0229   	/*if(g_rxLen > 0)
; 0001 022A     {
; 0001 022B       	g_rxLen--;
; 0001 022C     	return *g_rxBuf++;
; 0001 022D     }
; 0001 022E 
; 0001 022F     return 0;*/
; 0001 0230  	return FIFO_Read();
	RCALL _FIFO_Read
	RET
; 0001 0231 }
; .FEND
;
;/*****************************************************************************
;Âîçâðàùàåò äàííûå â áóôåð ïåðåäàò÷èêà USB
;******************************************************************************/
;
;void PutOneChar(UCHAR data)
; 0001 0238 {
_PutOneChar:
; .FSTART _PutOneChar
; 0001 0239   	if(g_txWR < AVR910_TX_DATA_SIZE)
;	data -> Y+0
	LDS  R26,_g_txWR
	CPI  R26,LOW(0x80)
	BRSH _0x2008E
; 0001 023A       	g_txBuf[g_txWR++] = data;
	LDS  R30,_g_txWR
	SUBI R30,-LOW(1)
	STS  _g_txWR,R30
	SUBI R30,LOW(1)
	LDI  R31,0
	SUBI R30,LOW(-_g_txBuf)
	SBCI R31,HIGH(-_g_txBuf)
	LD   R26,Y
	STD  Z+0,R26
; 0001 023B }
_0x2008E:
	JMP  _0x20C0022
; .FEND
;
;/*****************************************************************************
;Çàïèñûâàåò ïîñëåäîâàòåëüíî 3 áàéòà â SPI è âîçâðàùàåò ðåçóëüòàò îò çàïèñè 3-ãî
;******************************************************************************/
;UCHAR Write123(UCHAR byte1, UCHAR byte2, UCHAR byte3)
; 0001 0241 {
_Write123:
; .FSTART _Write123
; 0001 0242   	ExSPI(byte1);
;	byte1 -> Y+2
;	byte2 -> Y+1
;	byte3 -> Y+0
	CALL SUBOPT_0x23
; 0001 0243     ExSPI(byte2);
; 0001 0244     return ExSPI(byte3);
_0x20C002C:
	ADIW R28,3
	RET
; 0001 0245 }
; .FEND
;
;/*****************************************************************************
;Çàïèñûâàåò ïîñëåäîâàòåëüíî 4 áàéòà â SPI è âîçâðàùàåò ðåçóëüòàò îò çàïèñè 4-ãî
;******************************************************************************/
;UCHAR Write1234(UCHAR byte1, UCHAR byte2, UCHAR byte3, UCHAR byte4)
; 0001 024B {
_Write1234:
; .FSTART _Write1234
; 0001 024C   	ExSPI(byte1);
;	byte1 -> Y+3
;	byte2 -> Y+2
;	byte3 -> Y+1
;	byte4 -> Y+0
	LDD  R30,Y+3
	ST   -Y,R30
	RCALL _ExSPI
; 0001 024D     ExSPI(byte2);
	CALL SUBOPT_0x23
; 0001 024E     ExSPI(byte3);
; 0001 024F     return ExSPI(byte4);
	RJMP _0x20C0024
; 0001 0250 }
; .FEND
;
;/*****************************************************************************
;Âõîä â ðåæèì ïðîãðàììèðîâàíèÿ
;******************************************************************************/
;void SetProgMode(void)
; 0001 0256 {
_SetProgMode:
; .FSTART _SetProgMode
; 0001 0257     UCHAR progOK=0;
; 0001 0258     UCHAR c;
; 0001 0259     UCHAR err = ACK;
; 0001 025A     LED_RD_ON();
	CALL __SAVELOCR4
;	progOK -> R17
;	c -> R16
;	err -> R19
	LDI  R17,0
	LDI  R19,13
	CBI  0x5,1
; 0001 025B     LED_WR_ON();
	CBI  0x5,1
; 0001 025C     g_IsFuseClock=TRUE;
	LDI  R30,LOW(1)
	MOV  R10,R30
; 0001 025D     // ïðîâåðÿåì êîä óñòðîéñòâà
; 0001 025E     if(S89 == g_DeviceType) //89S
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BRNE _0x20093
; 0001 025F     {
; 0001 0260       	ReleasePorts(); // îòêëþ÷àåì ïîðòû
	RCALL _ReleasePorts
; 0001 0261 		CatchPorts();	// ïîäêëþ÷àåì ïîðòû ê ISP
	RCALL _CatchPorts
; 0001 0262    		S89_DELAY_RESET();	// çàäåðæêà
	CALL SUBOPT_0x8
; 0001 0263 
; 0001 0264         // ïîñûëàåì êîìàíäó âõîäà â ðåæèì ïðîãðàììèðîâàíèÿ
; 0001 0265         S89_PROG_EN();
	CALL SUBOPT_0x24
; 0001 0266         progOK=1;
	LDI  R17,LOW(1)
; 0001 0267     }
; 0001 0268     else
	RJMP _0x20094
_0x20093:
; 0001 0269     {
; 0001 026A       	// ñèíõðîíèçèðóåìñÿ ñ ïîäêëþ÷åííûì ÷èïîì
; 0001 026B         ReleasePorts(); 	// îòêëþ÷àåì ïîðòû
	RCALL _ReleasePorts
; 0001 026C 		CatchPorts();		// ïîäêëþ÷àåì ïîðòû ê ISP
	RCALL _CatchPorts
; 0001 026D    		AVR_DELAY_RESET();	// çàäåðæêà
	CALL SUBOPT_0x25
; 0001 026E 
; 0001 026F         // 32 öèêëà ïîïûòîê çàñèíõðîíèçèðîâàòüñÿ ñ ïðîãðàììèðóåìûì ÌÊ
; 0001 0270         for(c = 0; c < 32; c++)
	LDI  R16,LOW(0)
_0x20096:
	CPI  R16,32
	BRSH _0x20097
; 0001 0271         {
; 0001 0272            	// ïûòàåìñÿ âûâåñòè ÷èï â ðåæèì ïðîãðàììèðîâàíèÿ
; 0001 0273 			// ïðè ïîñûëêå 3-ãî áàéòà â SPI ÷èï äîëæåí âåðíóòü êîä ïðåäûäóùåé ïîñûëêè
; 0001 0274           	UCHAR ctrl_byte = AVR_PROG_EN();
; 0001 0275             ExSPI(0x00);
	SBIW R28,1
;	ctrl_byte -> Y+0
	CALL SUBOPT_0x24
	ST   Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _ExSPI
; 0001 0276 
; 0001 0277             // ïîëó÷èëè âåðíûé êîíòðîëüíûé áàéò - ñèíõðîíèçàöèÿ âûïîëíåíà
; 0001 0278             if(0x53 == ctrl_byte){
	LD   R30,Y
	CPI  R30,LOW(0x53)
	BRNE _0x20098
; 0001 0279            		progOK=1;
	LDI  R17,LOW(1)
; 0001 027A                 break;//goto m1;
	ADIW R28,1
	RJMP _0x20097
; 0001 027B            	}
; 0001 027C             // åñëè íåò âàëèäíîãî âîçâðàòà, òî ñäâèãàåì ïðè êàæäîé ïîïûòêå ñòðîá
; 0001 027D           	SET_SCK();
_0x20098:
	SBI  0xB,7
; 0001 027E     		delay_us(50);//__delay_cycles(600); // çàäåðæêà 50 ìêñ
	__DELAY_USB 200
; 0001 027F 			CLR_SCK();
	CBI  0xB,7
; 0001 0280     		delay_us(50);//__delay_cycles(600);
	__DELAY_USB 200
; 0001 0281         }
	ADIW R28,1
	SUBI R16,-1
	RJMP _0x20096
_0x20097:
; 0001 0282 
; 0001 0283         // åñëè ìû íå çàñèíõðîíèçèðîâàëèñü,
; 0001 0284         // ñ÷èòàåì, ÷òî óñòðîéñòâî íå íàéäåíî
; 0001 0285         if(progOK==0){
	CPI  R17,0
	BRNE _0x2009D
; 0001 0286             ReleasePorts(); // îòêëþ÷àåì ïîðòû
	RCALL _ReleasePorts
; 0001 0287             err = NACK; // ïîñûëàåì êîä îøèáêè
	LDI  R19,LOW(63)
; 0001 0288         }
; 0001 0289     }
_0x2009D:
_0x20094:
; 0001 028A //:m1
; 0001 028B     PutOneChar(err);
	ST   -Y,R19
	RCALL _PutOneChar
; 0001 028C     if(progOK==0){
	CPI  R17,0
	BRNE _0x2009E
; 0001 028D         LED_WR_OFF();//CLR_LED_WR();
	SBI  0x5,1
; 0001 028E         LED_RD_OFF();//CLR_LED_RD();
	SBI  0x5,1
; 0001 028F     }
; 0001 0290     g_IsFuseClock=FALSE;
_0x2009E:
	CLR  R10
; 0001 0291 }
	RJMP _0x20C0023
; .FEND
;
;/*****************************************************************************
;Âîçâðàùàåò êîäû ïîääåðæèâàåìûõ óñòðîéñòâ
;******************************************************************************/
;void GetDevCodes(void)
; 0001 0297 {
_GetDevCodes:
; .FSTART _GetDevCodes
; 0001 0298   	UCHAR code, i = 0;
; 0001 0299     do
	ST   -Y,R17
	ST   -Y,R16
;	code -> R17
;	i -> R16
	LDI  R16,0
_0x200A4:
; 0001 029A     {
; 0001 029B       	code = DeviceDesc[i];
	MOV  R30,R16
	LDI  R31,0
	SUBI R30,LOW(-_DeviceDesc*2)
	SBCI R31,HIGH(-_DeviceDesc*2)
	LPM  R17,Z
; 0001 029C       	PutOneChar(code);
	ST   -Y,R17
	RCALL _PutOneChar
; 0001 029D       	i += 2;
	SUBI R16,-LOW(2)
; 0001 029E 	}
; 0001 029F     while(0!= code);
	CPI  R17,0
	BRNE _0x200A4
; 0001 02A0 }
	RJMP _0x20C0025
; .FEND
;
;/*****************************************************************************
;Âûáîð òèïà ïîäêëþ÷åííîãî ìèêðîêîíòðîëëåðà
;Óñòàíàâëèâàåò èíäåêñ â ìàññèâå îïèñàòåëåé óñòðîéñòâ, åñëè ïîëó÷åííûé êîä
;êîíòðîëëåðà îò õîñòà âåðíûé
;******************************************************************************/
;void SetDevType(void)
; 0001 02A8 {
_SetDevType:
; .FSTART _SetDevType
; 0001 02A9   	UCHAR code, err = NACK, i = 0, request;
; 0001 02AA 
; 0001 02AB     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 02AC     CheckCommParams(1);
	CALL __SAVELOCR4
;	code -> R17
;	err -> R16
;	i -> R19
;	request -> R18
	LDI  R16,63
	LDI  R19,0
	CALL SUBOPT_0x26
; 0001 02AD     if(TRUE == g_NeedParams)
	BRNE _0x200A6
; 0001 02AE       	return;
	RJMP _0x20C0023
; 0001 02AF 
; 0001 02B0     request = GetOneChar();
_0x200A6:
	RCALL _GetOneChar
	MOV  R18,R30
; 0001 02B1 
; 0001 02B2     // ñðàâíèâàåì âñå êîäû ÌÊ â òàáëèöå óñòðîéñòâ ñ ïîëó÷åííûì
; 0001 02B3     // ïîêà êîä ÌÊ íå ðàâåí 0
; 0001 02B4 	while(0 != (code = DeviceDesc[i]))
_0x200A7:
	MOV  R30,R19
	LDI  R31,0
	SUBI R30,LOW(-_DeviceDesc*2)
	SBCI R31,HIGH(-_DeviceDesc*2)
	LPM  R30,Z
	MOV  R17,R30
	CPI  R30,0
	BREQ _0x200A9
; 0001 02B5     {
; 0001 02B6       	// åñëè êîä ñîâïàë, åñòü ïîääåðæèâàåìîå óñòðîéñòâî,
; 0001 02B7       	// ôîðìèðóåì äàííûå äëÿ óñòðîéñòâà
; 0001 02B8       	if(request == code)
	CP   R17,R18
	BRNE _0x200AA
; 0001 02B9         {
; 0001 02BA           	// óñòàíàâëèâàåì òèï ÌÊ
; 0001 02BB           	g_DeviceCode = DeviceDesc[i];
	MOV  R30,R19
	LDI  R31,0
	SUBI R30,LOW(-_DeviceDesc*2)
	SBCI R31,HIGH(-_DeviceDesc*2)
	LPM  R13,Z
; 0001 02BC           	g_DevicePollCode = DeviceDesc[i + 1];
	MOV  R30,R19
	LDI  R31,0
	__ADDW1FN _DeviceDesc,1
	LPM  R0,Z
	STS  _g_DevicePollCode,R0
; 0001 02BD             err = ACK;
	LDI  R16,LOW(13)
; 0001 02BE             if(0x7F < g_DeviceCode)
	LDI  R26,LOW(127)
	CP   R26,R13
	BRSH _0x200AB
; 0001 02BF             	g_DeviceType = S89;
	LDI  R30,LOW(2)
	RJMP _0x20165
; 0001 02C0             else
_0x200AB:
; 0001 02C1               	if((g_DevicePollCode == 0x7F) ||
; 0001 02C2                    (g_DevicePollCode == 0xFF))
	LDS  R26,_g_DevicePollCode
	CPI  R26,LOW(0x7F)
	BREQ _0x200AE
	CPI  R26,LOW(0xFF)
	BRNE _0x200AD
_0x200AE:
; 0001 02C3                 	g_DeviceType = CLASSIC;
	LDI  R30,LOW(1)
	RJMP _0x20165
; 0001 02C4                 else
_0x200AD:
; 0001 02C5                   	g_DeviceType = MEGA;
	LDI  R30,LOW(0)
_0x20165:
	STS  _g_DeviceType,R30
; 0001 02C6         }
; 0001 02C7 
; 0001 02C8         i += 2;
_0x200AA:
	SUBI R19,-LOW(2)
; 0001 02C9     }
	RJMP _0x200A7
_0x200A9:
; 0001 02CA 
; 0001 02CB     PutOneChar(err);
	ST   -Y,R16
	RCALL _PutOneChar
; 0001 02CC }
	RJMP _0x20C0023
; .FEND
;
;/*****************************************************************************
;Çàæå÷ü èíäèêàòîð ïðîãðàììèðîâàíèÿ
;êîìàíäà èãíîðèðóåòñÿ
;******************************************************************************/
;void SetLED(void)
; 0001 02D3 {
_SetLED:
; .FSTART _SetLED
; 0001 02D4   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 02D5     CheckCommParams(1);
	CALL SUBOPT_0x26
; 0001 02D6     if(TRUE == g_NeedParams)
	BRNE _0x200B1
; 0001 02D7       	return;
	RET
; 0001 02D8 
; 0001 02D9   	GetOneChar();
_0x200B1:
	RCALL _GetOneChar
; 0001 02DA 	PutOneChar(ACK);
	RJMP _0x20C0027
; 0001 02DB }
; .FEND
;
;/*****************************************************************************
;Ïîãàñèòü èíäèêàòîð ïðîãðàììèðîâàíèÿ
;êîìàíäà èãíîðèðóåòñÿ
;******************************************************************************/
;void ClrLED(void)
; 0001 02E2 {
_ClrLED:
; .FSTART _ClrLED
; 0001 02E3   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 02E4     CheckCommParams(1);
	CALL SUBOPT_0x26
; 0001 02E5     if(TRUE == g_NeedParams)
	BRNE _0x200B2
; 0001 02E6       	return;
	RET
; 0001 02E7 
; 0001 02E8   	GetOneChar();
_0x200B2:
	RCALL _GetOneChar
; 0001 02E9 	PutOneChar(ACK);
	RJMP _0x20C0027
; 0001 02EA }
; .FEND
;
;/*****************************************************************************
;Óíèâåðñàëüíàÿ êîìàíäà: ïèøåò â SPI 3 áàéòà äàííûõ è âîçâðàùàåò â áóôåð
;ïåðåäà÷è ðåçóëüòàò îò çàïèñè 4-ãî (0x00)
;******************************************************************************/
;void tx123rx4(void)
; 0001 02F1 {
_tx123rx4:
; .FSTART _tx123rx4
; 0001 02F2   	UCHAR b1,b2,b3;
; 0001 02F3     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 02F4     CheckCommParams(3);
	CALL __SAVELOCR4
;	b1 -> R17
;	b2 -> R16
;	b3 -> R19
	CALL SUBOPT_0x27
; 0001 02F5     if(TRUE == g_NeedParams)
	BRNE _0x200B3
; 0001 02F6       	return;
	RJMP _0x20C0023
; 0001 02F7 
; 0001 02F8     LED_RD_ON();
_0x200B3:
	CALL SUBOPT_0x28
; 0001 02F9     LED_WR_ON();
; 0001 02FA 
; 0001 02FB     b1 = GetOneChar();
; 0001 02FC     b2 = GetOneChar();
; 0001 02FD     b3 = GetOneChar();
; 0001 02FE   	PutOneChar(Write1234(b1, b2, b3, 0x00));
	ST   -Y,R17
	ST   -Y,R16
	ST   -Y,R19
	CALL SUBOPT_0x29
	CALL SUBOPT_0x2A
; 0001 02FF     PutOneChar(ACK);
; 0001 0300     DELAY_WR_FLASH();
; 0001 0301 
; 0001 0302     LED_RD_OFF();
	SBI  0x5,1
; 0001 0303     LED_WR_OFF();
	SBI  0x5,1
; 0001 0304 }
	RJMP _0x20C0023
; .FEND
;
;/*****************************************************************************
;Óíèâåðñàëüíàÿ êîìàíäà: ïèøåò â SPI 3 áàéòà äàííûõ è âîçâðàùàåò â áóôåð
;ïåðåäà÷è ðåçóëüòàò îò çàïèñè 4-ãî (d4)
;******************************************************************************/
;void tx1234rx4(void)
; 0001 030B {
_tx1234rx4:
; .FSTART _tx1234rx4
; 0001 030C   	UCHAR b1,b2,b3,b4;
; 0001 030D     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 030E     CheckCommParams(4);
	CALL __SAVELOCR4
;	b1 -> R17
;	b2 -> R16
;	b3 -> R19
;	b4 -> R18
	CALL SUBOPT_0x2B
; 0001 030F     if(TRUE == g_NeedParams)
	BRNE _0x200BC
; 0001 0310       	return;
	RJMP _0x20C0023
; 0001 0311 
; 0001 0312     LED_RD_ON();
_0x200BC:
	CALL SUBOPT_0x28
; 0001 0313     LED_WR_ON();
; 0001 0314 
; 0001 0315     b1 = GetOneChar();
; 0001 0316     b2 = GetOneChar();
; 0001 0317     b3 = GetOneChar();
; 0001 0318     b4 = GetOneChar();
	RCALL _GetOneChar
	MOV  R18,R30
; 0001 0319     PutOneChar(Write1234(b1, b2, b3, b4));
	ST   -Y,R17
	ST   -Y,R16
	ST   -Y,R19
	ST   -Y,R18
	RCALL _Write1234
	CALL SUBOPT_0x2A
; 0001 031A   	PutOneChar(ACK);
; 0001 031B     DELAY_WR_FLASH();
; 0001 031C 
; 0001 031D     LED_RD_OFF();
	SBI  0x5,1
; 0001 031E     LED_WR_OFF();
	SBI  0x5,1
; 0001 031F }
	RJMP _0x20C0023
; .FEND
;
;/*****************************************************************************
;Çàïèñü â ïàìÿòü ïðîãðàìì, ìëàäøèé áàéò
;******************************************************************************/
;void WriteProgLB(void)
; 0001 0325 {
_WriteProgLB:
; .FSTART _WriteProgLB
; 0001 0326   	UCHAR data;
; 0001 0327     // çàæèãàåì èíäèêàòîð çàïèñè
; 0001 0328   	LED_WR_ON();
	ST   -Y,R17
;	data -> R17
	CALL SUBOPT_0x2C
; 0001 0329 
; 0001 032A   	// ïîëó÷àåì áàéò äàííûõ
; 0001 032B 	data = GetOneChar();
; 0001 032C 
; 0001 032D     // ïèøåì áàéò
; 0001 032E     if(g_DeviceType == S89)
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	BRNE _0x200C7
; 0001 032F     	S89_WR_FLASH(g_Addr, data);
	CALL SUBOPT_0x2D
	ORI  R30,2
	CALL SUBOPT_0x2E
	RCALL _Write123
; 0001 0330     else
	RJMP _0x200C8
_0x200C7:
; 0001 0331     	AVR_WR_FLASH_LB(g_Addr, data);
	LDI  R30,LOW(64)
	CALL SUBOPT_0x2F
	RCALL _Write1234
; 0001 0332 
; 0001 0333     // ïðîâåðÿåì çàïèñü áàéòà
; 0001 0334 	PollData(0x20, data);
_0x200C8:
	LDI  R30,LOW(32)
	ST   -Y,R30
	ST   -Y,R17
	RCALL _PollData
; 0001 0335 
; 0001 0336     // èíêðåìåíòèðóåì àäðåñ, åñëè 89S
; 0001 0337     if(S89 == g_DeviceType)
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BRNE _0x200C9
; 0001 0338       	g_Addr++;
	CALL SUBOPT_0x30
; 0001 0339 
; 0001 033A     // ãàñèì èíäèêàòîð çàïèñè
; 0001 033B     LED_WR_OFF();
_0x200C9:
	SBI  0x5,1
; 0001 033C }
	RJMP _0x20C0029
; .FEND
;
;/*****************************************************************************
;Çàïèñü â ïàìÿòü ïðîãðàìì, ñòàðøèé áàéò
;******************************************************************************/
;void WriteProgHB(void)
; 0001 0342 {
_WriteProgHB:
; .FSTART _WriteProgHB
; 0001 0343   	UCHAR data;
; 0001 0344     if(S89 != g_DeviceType)
	ST   -Y,R17
;	data -> R17
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x200CC
; 0001 0345     {
; 0001 0346       	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 0347   		LED_WR_ON();
	CALL SUBOPT_0x2C
; 0001 0348 
; 0001 0349       	// ïîëó÷àåì ñòàðøèé áàéò äàííûõ
; 0001 034A 		data = GetOneChar();
; 0001 034B 
; 0001 034C       	// ïèøåì â SPI ñòàðøèé áàéò
; 0001 034D         AVR_WR_FLASH_HB(g_Addr, data);
	LDI  R30,LOW(72)
	CALL SUBOPT_0x2F
	RCALL _Write1234
; 0001 034E 
; 0001 034F     	// ïðîâåðÿåì çàïèñü áàéòà
; 0001 0350 		PollData(0x28, data);
	LDI  R30,LOW(40)
	ST   -Y,R30
	ST   -Y,R17
	RCALL _PollData
; 0001 0351 
; 0001 0352     	// èíêðåìåíòèðóåì àäðåñ
; 0001 0353     	g_Addr++;
	CALL SUBOPT_0x30
; 0001 0354 
; 0001 0355         // ãàñèì èíäèêàòîð çàïèñè
; 0001 0356     	LED_WR_OFF();
	SBI  0x5,1
; 0001 0357     }
; 0001 0358 }
_0x200CC:
	RJMP _0x20C0029
; .FEND
;
;/*****************************************************************************
;Îäèíî÷íàÿ çàïèñü â ïàìÿòü ïðîãðàìì, ìëàäøèé áàéò
;******************************************************************************/
;void WriteProgOneLB(void)
; 0001 035E {
_WriteProgOneLB:
; .FSTART _WriteProgOneLB
; 0001 035F   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 0360     CheckCommParams(1);
	CALL SUBOPT_0x26
; 0001 0361     if(TRUE == g_NeedParams)
	BRNE _0x200D1
; 0001 0362       	return;
	RET
; 0001 0363 
; 0001 0364   	WriteProgLB();
_0x200D1:
	RCALL _WriteProgLB
; 0001 0365     PutOneChar(ACK); // OK
	RJMP _0x20C0027
; 0001 0366 }
; .FEND
;
;/*****************************************************************************
;Îäèíî÷íàÿ çàïèñü â ïàìÿòü ïðîãðàìì, ñòàðøèé áàéò
;******************************************************************************/
;void WriteProgOneHB(void)
; 0001 036C {
_WriteProgOneHB:
; .FSTART _WriteProgOneHB
; 0001 036D   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 036E     CheckCommParams(1);
	CALL SUBOPT_0x26
; 0001 036F     if(TRUE == g_NeedParams)
	BRNE _0x200D2
; 0001 0370       	return;
	RET
; 0001 0371 
; 0001 0372   	WriteProgHB();
_0x200D2:
	RCALL _WriteProgHB
; 0001 0373     PutOneChar(ACK); // OK
	RJMP _0x20C0027
; 0001 0374 }
; .FEND
;
;/*****************************************************************************
;Îäèíî÷íàÿ çàïèñü â ïàìÿòü äàííûõ
;******************************************************************************/
;void WriteOneData(void)
; 0001 037A {
_WriteOneData:
; .FSTART _WriteOneData
; 0001 037B   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 037C     CheckCommParams(1);
	CALL SUBOPT_0x26
; 0001 037D     if(TRUE == g_NeedParams)
	BRNE _0x200D3
; 0001 037E       	return;
	RET
; 0001 037F 
; 0001 0380   	WriteData();
_0x200D3:
	RCALL _WriteData
; 0001 0381     PutOneChar(ACK); // OK
	RJMP _0x20C0027
; 0001 0382 }
; .FEND
;
;/*****************************************************************************
;Ïðîâåðêà ïîëëèíãà è ñòðàíè÷íîãî ðåæèìà ïðîãðàììèðîâàíèÿ
;******************************************************************************/
;void PollData(UCHAR command, UCHAR data)
; 0001 0388 {
_PollData:
; .FSTART _PollData
; 0001 0389   	// ïðîâåðÿåì ïîëëèíã
; 0001 038A   	if(g_DevicePollCode & 0x0F)
;	command -> Y+1
;	data -> Y+0
	LDS  R30,_g_DevicePollCode
	ANDI R30,LOW(0xF)
	BREQ _0x200D4
; 0001 038B     {
; 0001 038C       	// åñëè äàííûå ñîâïàäàþò ñ êîäîì ïîëëèíãà, ìû íå ìîæåì ïðîâåðèòü çàïèñü
; 0001 038D       	if(g_DevicePollCode == data)
	LD   R30,Y
	LDS  R26,_g_DevicePollCode
	CP   R30,R26
	BRNE _0x200D5
; 0001 038E         	DELAY_WR_FLASH();
	CALL SUBOPT_0x8
; 0001 038F 
; 0001 0390         else
	RJMP _0x200D6
_0x200D5:
; 0001 0391         {
; 0001 0392           	// 256 öèêëîâ ïîëëèíãà
; 0001 0393           	UCHAR cycle = 0xFF;
; 0001 0394           	do
	SBIW R28,1
	LDI  R30,LOW(255)
	ST   Y,R30
;	command -> Y+2
;	data -> Y+1
;	cycle -> Y+0
_0x200D8:
; 0001 0395             {
; 0001 0396               	// ÷èòàåì çàïèñàííûå
; 0001 0397               	if(S89 == g_DeviceType) // 89S
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BRNE _0x200DA
; 0001 0398                 {
; 0001 0399                   	if(data == S89_RD_FLASH(g_Addr))
	CALL SUBOPT_0x2D
	CALL SUBOPT_0x31
	LDD  R26,Y+1
	CP   R30,R26
	BREQ _0x200D9
; 0001 039A                     	break; // OK
; 0001 039B                 }
; 0001 039C                 else // AVR
	RJMP _0x200DC
_0x200DA:
; 0001 039D                 {
; 0001 039E                   	if(data == Write1234(command, HIBYTE(g_Addr), LOBYTE(g_Addr), 0x00))
	LDD  R30,Y+2
	CALL SUBOPT_0x32
	LDD  R26,Y+1
	CP   R30,R26
	BREQ _0x200D9
; 0001 039F                 		break; // OK
; 0001 03A0                 }
_0x200DC:
; 0001 03A1             }
; 0001 03A2             while(--cycle);
	LD   R30,Y
	SUBI R30,LOW(1)
	ST   Y,R30
	BRNE _0x200D8
_0x200D9:
; 0001 03A3 
; 0001 03A4             // åñëè âàëèäíûé êîä òàê è íå ïîëó÷åí (((
; 0001 03A5             if(0 == cycle)
	LD   R30,Y
	CPI  R30,0
	BRNE _0x200DE
; 0001 03A6             	DELAY_WR_FLASH();
	CALL SUBOPT_0x8
; 0001 03A7         }
_0x200DE:
	ADIW R28,1
_0x200D6:
; 0001 03A8     }
; 0001 03A9 }
_0x200D4:
	RJMP _0x20C0021
; .FEND
;
;/*****************************************************************************
;Çàïèñü ñòðàíèöû â ïàìÿòü ïðîãðàìì
;******************************************************************************/
;void WritePage(void)
; 0001 03AF {
_WritePage:
; .FSTART _WritePage
; 0001 03B0   	// çàãðóæàåì êîìàíäó Write Programm Memory Page
; 0001 03B1   	if(MEGA == g_DeviceType) //mega/tiny AVR
	LDS  R30,_g_DeviceType
	CPI  R30,0
	BRNE _0x200DF
; 0001 03B2     {
; 0001 03B3       	UINT page_addr = g_Addr;
; 0001 03B4         if(TRUE == g_BlockMode)
	SBIW R28,2
;	page_addr -> Y+0
	LDS  R30,_g_Addr
	LDS  R31,_g_Addr+1
	ST   Y,R30
	STD  Y+1,R31
	LDS  R30,_g_BlockMode
	CPI  R30,LOW(0x1)
	BRNE _0x200E0
; 0001 03B5         	page_addr--;
	LD   R30,Y
	LDD  R31,Y+1
	SBIW R30,1
	ST   Y,R30
	STD  Y+1,R31
; 0001 03B6   		Write1234(0x4C, HIBYTE(page_addr), LOBYTE(page_addr), 0x00);
_0x200E0:
	LDI  R30,LOW(76)
	ST   -Y,R30
	LDD  R30,Y+2
	ANDI R31,HIGH(0x0)
	ST   -Y,R30
	LDD  R30,Y+2
	ST   -Y,R30
	CALL SUBOPT_0x29
; 0001 03B7 		DELAY_WR_FLASH();
	CALL SUBOPT_0x8
; 0001 03B8     }
	ADIW R28,2
; 0001 03B9 }
_0x200DF:
	RET
; .FEND
;
;/*****************************************************************************
;×òåíèå ïàìÿòè ïðîãðàìì
;******************************************************************************/
;void ReadProg(UCHAR com_byte1, UCHAR com_byte2)
; 0001 03BF {
_ReadProg:
; .FSTART _ReadProg
; 0001 03C0   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 03C1   	LED_RD_ON();
;	com_byte1 -> Y+1
;	com_byte2 -> Y+0
	CBI  0x5,1
; 0001 03C2 
; 0001 03C3   	if(S89 != g_DeviceType)// AVR - ÷èòàåì ñëîâî
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x200E3
; 0001 03C4     {
; 0001 03C5       	PutOneChar(Write1234(com_byte1, HIBYTE(g_Addr), LOBYTE(g_Addr), 0x00));
	LDD  R30,Y+1
	CALL SUBOPT_0x32
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 03C6         PutOneChar(Write1234(com_byte2, HIBYTE(g_Addr), LOBYTE(g_Addr), 0x00));
	LD   R30,Y
	CALL SUBOPT_0x32
	RJMP _0x20166
; 0001 03C7     }
; 0001 03C8     else//S89 - ÷èòàåì áàéò
_0x200E3:
; 0001 03C9     {
; 0001 03CA       	PutOneChar(S89_RD_FLASH(g_Addr));
	CALL SUBOPT_0x2D
	CALL SUBOPT_0x31
_0x20166:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 03CB     }
; 0001 03CC 
; 0001 03CD     // èíêðåìåíèðóåì àäðåñ
; 0001 03CE 	g_Addr++;
	CALL SUBOPT_0x30
; 0001 03CF 
; 0001 03D0     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 03D1   	LED_RD_OFF();
	SBI  0x5,1
; 0001 03D2 }
	RJMP _0x20C0021
; .FEND
;
;/*****************************************************************************
;Çàïèñü â ïàìÿòü äàííûõ (EEPROM)
;******************************************************************************/
;void WriteData(void)
; 0001 03D8 {
_WriteData:
; .FSTART _WriteData
; 0001 03D9   	UCHAR data;
; 0001 03DA     // çàæèãàåì èíäèêàòîð çàïèñè
; 0001 03DB   	LED_WR_ON();
	ST   -Y,R17
;	data -> R17
	CALL SUBOPT_0x2C
; 0001 03DC 
; 0001 03DD 	// ïîëó÷àåì áàéò äàííûõ
; 0001 03DE 	data = GetOneChar();
; 0001 03DF 
; 0001 03E0     // ïðîâåðÿåì òèï óñòðîéñòâà
; 0001 03E1     if(S89 != g_DeviceType) // AVR
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x200E9
; 0001 03E2     	AVR_WR_EEPROM(g_Addr, data);
	LDI  R30,LOW(192)
	CALL SUBOPT_0x2F
	RCALL _Write1234
; 0001 03E3     else // 89S
	RJMP _0x200EA
_0x200E9:
; 0001 03E4     	if(0x86 == g_DeviceCode)// EEPROM åñòü òîëüêî ó 8252
	LDI  R26,LOW(134)
	CP   R13,R26
	BRNE _0x200EB
; 0001 03E5            	S89_WR_EEPROM(g_Addr, data);
	CALL SUBOPT_0x2D
	ORI  R30,LOW(0x6)
	CALL SUBOPT_0x33
; 0001 03E6 
; 0001 03E7     DELAY_WR_EEPROM();
_0x200EB:
_0x200EA:
	CALL SUBOPT_0x8
; 0001 03E8 
; 0001 03E9     // èíêðåìåíòèðóåì àäðåñ
; 0001 03EA     g_Addr++;
	CALL SUBOPT_0x30
; 0001 03EB 
; 0001 03EC     // ãàñèì èíäèêàòîð çàïèñè
; 0001 03ED     LED_WR_OFF();
	SBI  0x5,1
; 0001 03EE }
	RJMP _0x20C0029
; .FEND
;
;/*****************************************************************************
;×òåíèå ïàìÿòè äàííûõ (EEPROM)
;******************************************************************************/
;void ReadData(void)
; 0001 03F4 {
_ReadData:
; .FSTART _ReadData
; 0001 03F5   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 03F6   	LED_RD_ON();
	CBI  0x5,1
; 0001 03F7 
; 0001 03F8   	// ïðîâåðÿåì òèï óñòðîéñòâà
; 0001 03F9     if(S89 != g_DeviceType)// AVR
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x200F0
; 0001 03FA     	PutOneChar(Write1234(0xA0, HIBYTE(g_Addr), LOBYTE(g_Addr), 0x00));
	LDI  R30,LOW(160)
	CALL SUBOPT_0x32
	RJMP _0x20167
; 0001 03FB 	else
_0x200F0:
; 0001 03FC     	if(0x86 == g_DeviceCode)//S89 EEPROM èìååòñÿ òîëüêî ó 8252
	LDI  R26,LOW(134)
	CP   R13,R26
	BRNE _0x200F2
; 0001 03FD         	PutOneChar(Write123(((HIBYTE(g_Addr) << 3) | 0x05), LOBYTE(g_Addr), 0x00));
	LDS  R30,_g_Addr+1
	ANDI R31,HIGH(0x0)
	LSL  R30
	LSL  R30
	LSL  R30
	ORI  R30,LOW(0x5)
	CALL SUBOPT_0x33
_0x20167:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 03FE 
; 0001 03FF     // èíêðåìåíèðóåì àäðåñ
; 0001 0400 	g_Addr++;
_0x200F2:
	CALL SUBOPT_0x30
; 0001 0401 
; 0001 0402     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 0403   	LED_RD_OFF();
	SBI  0x5,1
; 0001 0404 }
	RET
; .FEND
;
;/*****************************************************************************
;Ñòåðåòü ïàìÿòü ïðîãðàìì è äàííûõ (EEPROM) ÷èïà
;******************************************************************************/
;void ChipErase(void)
; 0001 040A {
_ChipErase:
; .FSTART _ChipErase
; 0001 040B   	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 040C   	LED_WR_ON();
	CALL SUBOPT_0x34
; 0001 040D     g_IsFuseClock=TRUE;
; 0001 040E   	// ïîñûëàåì êîìàíäó Chip Erase, çàäåðæêà è OK
; 0001 040F   	if(g_DeviceType == S89)
	BRNE _0x200F7
; 0001 0410       	S89_CHIP_ERASE();
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(4)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _Write123
; 0001 0411     else
	RJMP _0x200F8
_0x200F7:
; 0001 0412       	AVR_CHIP_ERASE();
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(128)
	ST   -Y,R30
	CALL SUBOPT_0x1
	RCALL _Write1234
; 0001 0413 	DELAY_ERASE();
_0x200F8:
	CALL SUBOPT_0x25
; 0001 0414     PutOneChar(ACK);
	LDI  R30,LOW(13)
	RJMP _0x20C002A
; 0001 0415 
; 0001 0416     // ãàñèì èíäèêàòîð çàïèñè
; 0001 0417     LED_WR_OFF();
; 0001 0418     g_IsFuseClock=FALSE;
; 0001 0419 }
; .FEND
;
;/*****************************************************************************
;Çàïèñü áèòîâ áëîêèðîâêè
;******************************************************************************/
;void WriteLock(void)
; 0001 041F {
_WriteLock:
; .FSTART _WriteLock
; 0001 0420   	UCHAR data;
; 0001 0421     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 0422     CheckCommParams(1);
	CALL SUBOPT_0x21
;	data -> R17
; 0001 0423     if(TRUE == g_NeedParams)
	BRNE _0x200FB
; 0001 0424       	return;
	RJMP _0x20C0029
; 0001 0425 
; 0001 0426   	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 0427   	LED_WR_ON();
_0x200FB:
	CBI  0x5,1
; 0001 0428     g_IsFuseClock=TRUE;
	LDI  R30,LOW(1)
	MOV  R10,R30
; 0001 0429 
; 0001 042A 	// ïîëó÷àåì áàéò äàííûõ, ïèøåì lock bits, çàäåðæêà è OK
; 0001 042B 	data = GetOneChar();
	RCALL _GetOneChar
	MOV  R17,R30
; 0001 042C 	if(g_DeviceType == S89)
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	BRNE _0x200FE
; 0001 042D       	S89_WR_LOCK(data);
	LDI  R30,LOW(172)
	ST   -Y,R30
	MOV  R30,R17
	ANDI R30,LOW(0xE0)
	ORI  R30,LOW(0x7)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _Write123
; 0001 042E     else
	RJMP _0x200FF
_0x200FE:
; 0001 042F       	AVR_WR_LOCK(data);
	LDI  R30,LOW(172)
	ST   -Y,R30
	MOV  R30,R17
	ORI  R30,LOW(0xF9)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R17
	RCALL _Write1234
; 0001 0430 	DELAY_WR_FUSE();
_0x200FF:
	CALL SUBOPT_0x8
; 0001 0431     PutOneChar(ACK);
	LDI  R30,LOW(13)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 0432 
; 0001 0433     // ãàñèì èíäèêàòîð çàïèñè
; 0001 0434     LED_WR_OFF();
	RJMP _0x20C0028
; 0001 0435     g_IsFuseClock=FALSE;
; 0001 0436 }
; .FEND
;
;/*****************************************************************************
;Çàïèñü áèò óïðàâëåíèÿ
;******************************************************************************/
;void WriteFuse(void)
; 0001 043C {
_WriteFuse:
; .FSTART _WriteFuse
; 0001 043D   	UCHAR err,data;
; 0001 043E     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 043F     CheckCommParams(1);
	CALL SUBOPT_0x35
;	err -> R17
;	data -> R16
; 0001 0440     if(TRUE == g_NeedParams)
	BRNE _0x20102
; 0001 0441       	return;
	RJMP _0x20C0025
; 0001 0442 
; 0001 0443   	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 0444   	LED_WR_ON();
_0x20102:
	CALL SUBOPT_0x36
; 0001 0445     g_IsFuseClock=TRUE;
; 0001 0446 	// ïîëó÷àåì áàéò äàííûõ, ïèøåì fuse bits, çàäåðæêà è OK
; 0001 0447 	err = ACK, data = GetOneChar();
; 0001 0448     if(g_DeviceType == S89)
	BRNE _0x20105
; 0001 0449       	err = NACK;
	LDI  R17,LOW(63)
; 0001 044A     else
	RJMP _0x20106
_0x20105:
; 0001 044B     	AVR_WR_FUSE(data);
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(160)
	CALL SUBOPT_0x37
; 0001 044C     DELAY_WR_FUSE();
_0x20106:
	CALL SUBOPT_0x8
; 0001 044D     PutOneChar(err);
	CALL SUBOPT_0x38
; 0001 044E 
; 0001 044F     // ãàñèì èíäèêàòîð çàïèñè
; 0001 0450     LED_WR_OFF();
; 0001 0451     g_IsFuseClock=FALSE;
; 0001 0452 }
	RJMP _0x20C0025
; .FEND
;void WriteHFuse(void)
; 0001 0454 {
_WriteHFuse:
; .FSTART _WriteHFuse
; 0001 0455   	UCHAR err,data;
; 0001 0456     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 0457     CheckCommParams(1);
	CALL SUBOPT_0x35
;	err -> R17
;	data -> R16
; 0001 0458     if(TRUE == g_NeedParams)
	BRNE _0x20109
; 0001 0459       	return;
	RJMP _0x20C0025
; 0001 045A 
; 0001 045B   	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 045C   	LED_WR_ON();
_0x20109:
	CALL SUBOPT_0x36
; 0001 045D     g_IsFuseClock=TRUE;
; 0001 045E 	// ïîëó÷àåì áàéò äàííûõ, ïèøåì fuse bits, çàäåðæêà è OK
; 0001 045F 	err = ACK, data = GetOneChar();
; 0001 0460     if(g_DeviceType == S89)
	BRNE _0x2010C
; 0001 0461       	err = NACK;
	LDI  R17,LOW(63)
; 0001 0462     else
	RJMP _0x2010D
_0x2010C:
; 0001 0463     	AVR_WR_FUSE_H(data);
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(168)
	CALL SUBOPT_0x37
; 0001 0464     DELAY_WR_FUSE();
_0x2010D:
	CALL SUBOPT_0x8
; 0001 0465     PutOneChar(err);
	CALL SUBOPT_0x38
; 0001 0466 
; 0001 0467     // ãàñèì èíäèêàòîð çàïèñè
; 0001 0468     LED_WR_OFF();
; 0001 0469     g_IsFuseClock=FALSE;
; 0001 046A }
	RJMP _0x20C0025
; .FEND
;void WriteEXTFuse(void)
; 0001 046C {
_WriteEXTFuse:
; .FSTART _WriteEXTFuse
; 0001 046D   	UCHAR err,data;
; 0001 046E     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 046F     CheckCommParams(1);
	CALL SUBOPT_0x35
;	err -> R17
;	data -> R16
; 0001 0470     if(TRUE == g_NeedParams)
	BRNE _0x20110
; 0001 0471       	return;
	RJMP _0x20C0025
; 0001 0472 
; 0001 0473   	// çàæèãàåì èíäèêàòîð çàïèñè
; 0001 0474   	LED_WR_ON();
_0x20110:
	CALL SUBOPT_0x36
; 0001 0475     g_IsFuseClock=TRUE;
; 0001 0476 	// ïîëó÷àåì áàéò äàííûõ, ïèøåì fuse bits, çàäåðæêà è OK
; 0001 0477 	err = ACK, data = GetOneChar();
; 0001 0478     if(g_DeviceType == S89)
	BRNE _0x20113
; 0001 0479       	err = NACK;
	LDI  R17,LOW(63)
; 0001 047A     else
	RJMP _0x20114
_0x20113:
; 0001 047B     	AVR_WR_FUSE_EXT(data);
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(164)
	CALL SUBOPT_0x37
; 0001 047C     DELAY_WR_FUSE();
_0x20114:
	CALL SUBOPT_0x8
; 0001 047D     PutOneChar(err);
	CALL SUBOPT_0x38
; 0001 047E 
; 0001 047F     // ãàñèì èíäèêàòîð çàïèñè
; 0001 0480     LED_WR_OFF();
; 0001 0481     g_IsFuseClock=FALSE;
; 0001 0482 }
	RJMP _0x20C0025
; .FEND
;/*****************************************************************************
;×òåíèå áèòîâ óïðàâëåíèÿ è áëîêèðîâêè (ìëàäøèé áàéò)
;******************************************************************************/
;void ReadFuse(void)
; 0001 0487 {
_ReadFuse:
; .FSTART _ReadFuse
; 0001 0488   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 0489   	LED_RD_ON();
	CALL SUBOPT_0x34
; 0001 048A     g_IsFuseClock=TRUE;
; 0001 048B     // ÷èòàåì
; 0001 048C     PutOneChar((g_DeviceType == S89)? NACK: AVR_RD_FUSE());
	BRNE _0x20119
	LDI  R30,LOW(63)
	RJMP _0x2011A
_0x20119:
	LDI  R30,LOW(80)
	ST   -Y,R30
	CALL SUBOPT_0x1
	CALL SUBOPT_0x29
_0x2011A:
	RJMP _0x20C002A
; 0001 048D 
; 0001 048E     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 048F   	LED_RD_OFF();
; 0001 0490     g_IsFuseClock=FALSE;
; 0001 0491 }
; .FEND
;/*****************************************************************************
;×òåíèå áèòîâ óïðàâëåíèÿ è áëîêèðîâêè (ìëàäøèé áàéò)
;******************************************************************************/
;void ReadLock(void)
; 0001 0496 {
_ReadLock:
; .FSTART _ReadLock
; 0001 0497   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 0498   	LED_RD_ON();
	CALL SUBOPT_0x34
; 0001 0499     g_IsFuseClock=TRUE;
; 0001 049A     // ÷èòàåì
; 0001 049B     PutOneChar((g_DeviceType == S89)? NACK: AVR_RD_LOCK());
	BRNE _0x20120
	LDI  R30,LOW(63)
	RJMP _0x20121
_0x20120:
	LDI  R30,LOW(88)
	ST   -Y,R30
	CALL SUBOPT_0x1
	CALL SUBOPT_0x29
_0x20121:
	RJMP _0x20C002A
; 0001 049C 
; 0001 049D     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 049E   	LED_RD_OFF();
; 0001 049F     g_IsFuseClock=FALSE;
; 0001 04A0 }
; .FEND
;/*****************************************************************************
;×òåíèå áèòîâ óïðàâëåíèÿ è áëîêèðîâêè (ñòàðøèé áàéò)
;******************************************************************************/
;void ReadHFuse(void)
; 0001 04A5 {
_ReadHFuse:
; .FSTART _ReadHFuse
; 0001 04A6   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 04A7   	LED_RD_ON();
	CALL SUBOPT_0x34
; 0001 04A8     g_IsFuseClock=TRUE;
; 0001 04A9     // ÷èòàåì
; 0001 04AA     PutOneChar((g_DeviceType == S89)? NACK: AVR_RD_FUSE_H());
	BRNE _0x20127
	LDI  R30,LOW(63)
	RJMP _0x20128
_0x20127:
	LDI  R30,LOW(88)
	ST   -Y,R30
	LDI  R30,LOW(8)
	ST   -Y,R30
	CALL SUBOPT_0x1
	RCALL _Write1234
_0x20128:
	RJMP _0x20C002A
; 0001 04AB 
; 0001 04AC     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 04AD   	LED_RD_OFF();
; 0001 04AE     g_IsFuseClock=FALSE;
; 0001 04AF }
; .FEND
;/*****************************************************************************
;×òåíèå áèòîâ óïðàâëåíèÿ è áëîêèðîâêè (ñòàðøèé áàéò)
;******************************************************************************/
;void ReadEXTFuse(void)
; 0001 04B4 {
_ReadEXTFuse:
; .FSTART _ReadEXTFuse
; 0001 04B5   	// çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 04B6   	LED_RD_ON();
	CALL SUBOPT_0x34
; 0001 04B7     g_IsFuseClock=TRUE;
; 0001 04B8     // ÷èòàåì
; 0001 04B9     PutOneChar((g_DeviceType == S89)? NACK: AVR_RD_FUSE_EXT());
	BRNE _0x2012E
	LDI  R30,LOW(63)
	RJMP _0x2012F
_0x2012E:
	LDI  R30,LOW(80)
	ST   -Y,R30
	LDI  R30,LOW(8)
	ST   -Y,R30
	CALL SUBOPT_0x1
	RCALL _Write1234
_0x2012F:
_0x20C002A:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 04BA 
; 0001 04BB     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 04BC   	LED_RD_OFF();
	SBI  0x5,1
; 0001 04BD     g_IsFuseClock=FALSE;
_0x20C002B:
	CLR  R10
; 0001 04BE }
	RET
; .FEND
;/*****************************************************************************
;×òåíèå ñèãíàòóðû ÷èïà
;******************************************************************************/
;void ReadSignature(void)
; 0001 04C3 {
_ReadSignature:
; .FSTART _ReadSignature
; 0001 04C4   	UCHAR addr;
; 0001 04C5     // çàæèãàåì èíäèêàòîð ÷òåíèÿ
; 0001 04C6   	LED_RD_ON();
	ST   -Y,R17
;	addr -> R17
	CBI  0x5,1
; 0001 04C7     g_IsFuseClock=TRUE;
	LDI  R30,LOW(1)
	MOV  R10,R30
; 0001 04C8     // ÷èòàåì ïîñëåäîâàòåëüíî Vendor, Family, Number
; 0001 04C9     addr = 2;
	LDI  R17,LOW(2)
; 0001 04CA     do
_0x20136:
; 0001 04CB     {
; 0001 04CC     	PutOneChar((g_DeviceType == S89)?
; 0001 04CD 			0xFF:(AVR_RD_SIGN(addr)));
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	BRNE _0x20138
	LDI  R30,LOW(255)
	RJMP _0x20139
_0x20138:
	LDI  R30,LOW(48)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R17
	CALL SUBOPT_0x29
_0x20139:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 04CE     }
; 0001 04CF     while(addr--);
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BRNE _0x20136
; 0001 04D0 
; 0001 04D1     // ãàñèì èíäèêàòîð ÷òåíèÿ
; 0001 04D2   	LED_RD_OFF();
_0x20C0028:
	SBI  0x5,1
; 0001 04D3     g_IsFuseClock=FALSE;
	CLR  R10
; 0001 04D4 }
_0x20C0029:
	LD   R17,Y+
	RET
; .FEND
;
;/*****************************************************************************
;Âûõîä èç ðåæèìà ïðîãðàììèðîâàíèÿ
;******************************************************************************/
;void LeaveProgMode(void)
; 0001 04DA {
_LeaveProgMode:
; .FSTART _LeaveProgMode
; 0001 04DB     ReleasePorts();
	RCALL _ReleasePorts
; 0001 04DC   	PutOneChar(ACK);
	RJMP _0x20C0027
; 0001 04DD }
; .FEND
;
;/*****************************************************************************
;Ïðîâåðêà ïîääåðæêè áëî÷íîãî ðåæèìà çàïèñè/÷òåíèÿ
;******************************************************************************/
;void GetBlockMode(void)
; 0001 04E3 {
_GetBlockMode:
; .FSTART _GetBlockMode
; 0001 04E4   	PutOneChar(YES);
	LDI  R30,LOW(89)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 04E5     PutOneChar((UCHAR)(AVR910_REPORT_BLOCK_SIZE >> 8));
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 04E6     PutOneChar(AVR910_REPORT_BLOCK_SIZE & 0xFF);
	LDI  R30,LOW(128)
	RJMP _0x20C0026
; 0001 04E7 }
; .FEND
;
;/*****************************************************************************
;Âîçâðàùàåò èäåíòèôèêàòîð ÏÎ
;******************************************************************************/
;void GetSWID(void)
; 0001 04ED {
_GetSWID:
; .FSTART _GetSWID
; 0001 04EE 
; 0001 04EF     UCHAR flash *ptr = SwID;
; 0001 04F0   	while(0 != *ptr)
	ST   -Y,R17
	ST   -Y,R16
;	*ptr -> R16,R17
	__POINTWRFN 16,17,_SwID,0
_0x2013D:
	MOVW R30,R16
	LPM  R30,Z
	CPI  R30,0
	BREQ _0x2013F
; 0001 04F1       	PutOneChar(*ptr++);
	MOVW R30,R16
	__ADDWRN 16,17,1
	LPM  R30,Z
	ST   -Y,R30
	RCALL _PutOneChar
	RJMP _0x2013D
_0x2013F:
; 0001 04F2 }
	RJMP _0x20C0025
; .FEND
;
;/*****************************************************************************
;Âîçâðàòèòü âåðñèþ ÏÎ
;******************************************************************************/
;void GetSWVer(void)
; 0001 04F8 {
_GetSWVer:
; .FSTART _GetSWVer
; 0001 04F9   	PutOneChar(SOFTWARE_VER_1);
	LDI  R30,LOW(85)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 04FA     PutOneChar(SOFTWARE_VER_2);
	LDI  R30,LOW(50)
	RJMP _0x20C0026
; 0001 04FB }
; .FEND
;
;/*****************************************************************************
;Âîçâðàòèòü âåðñèþ ïëàòû
;******************************************************************************/
;void GetHWVer(void)
; 0001 0501 {
_GetHWVer:
; .FSTART _GetHWVer
; 0001 0502   	PutOneChar(HARDWARE_VER_1);
	LDI  R30,LOW(48)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 0503     PutOneChar(HARDWARE_VER_2);
	LDI  R30,LOW(50)
	RJMP _0x20C0026
; 0001 0504 }
; .FEND
;
;/*****************************************************************************
;Âîçâðàòèòü ïîääåðæêó àâòîïðèðàùåíèÿ àäðåñà
;******************************************************************************/
;void GetAutoIncAddr(void)
; 0001 050A {
_GetAutoIncAddr:
; .FSTART _GetAutoIncAddr
; 0001 050B   	PutOneChar(ACK);
	RJMP _0x20C0027
; 0001 050C }
; .FEND
;
;/*****************************************************************************
;Âîçâðàòèòü òèï ïðîãðàììàòîðà
;******************************************************************************/
;void GetPROGType(void)
; 0001 0512 {
_GetPROGType:
; .FSTART _GetPROGType
; 0001 0513   	PutOneChar(PROGRAMMER_TYPE);
	LDI  R30,LOW(83)
	RJMP _0x20C0026
; 0001 0514 }
; .FEND
;
;/*****************************************************************************
;Óñòàíîâèòü àäðåñ
;******************************************************************************/
;void SetAddr(void)
; 0001 051A {
_SetAddr:
; .FSTART _SetAddr
; 0001 051B   	// ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 051C     CheckCommParams(2);
	LDI  R30,LOW(2)
	ST   -Y,R30
	RCALL _CheckCommParams
; 0001 051D     if(TRUE == g_NeedParams)
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	BRNE _0x20140
; 0001 051E       	return;
	RET
; 0001 051F 
; 0001 0520   	g_Addr = MAKEUINT(GetOneChar(), GetOneChar());
_0x20140:
	RCALL _GetOneChar
	MOV  R31,R30
	LDI  R30,0
	PUSH R31
	PUSH R30
	RCALL _GetOneChar
	LDI  R31,0
	POP  R26
	POP  R27
	OR   R30,R26
	OR   R31,R27
	STS  _g_Addr,R30
	STS  _g_Addr+1,R31
; 0001 0521     PutOneChar(ACK);
_0x20C0027:
	LDI  R30,LOW(13)
_0x20C0026:
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 0522 }
	RET
; .FEND
;
;/*****************************************************************************
;Îáðàáîòêà êîìàíäû áëî÷íîãî ÷òåíèÿ
;******************************************************************************/
;void ReadBlockCommand(void)
; 0001 0528 {
_ReadBlockCommand:
; .FSTART _ReadBlockCommand
; 0001 0529   	UCHAR size_h,size_l;
; 0001 052A     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 052B     CheckCommParams(3);
	ST   -Y,R17
	ST   -Y,R16
;	size_h -> R17
;	size_l -> R16
	CALL SUBOPT_0x27
; 0001 052C     if(TRUE == g_NeedParams)
	BREQ _0x20C0025
; 0001 052D       	return;
; 0001 052E 
; 0001 052F   	// ïîëó÷àåì ðàçìåð áëîêà è òèï ïàìÿòè
; 0001 0530   	size_h = GetOneChar();
	CALL SUBOPT_0x39
; 0001 0531     size_l = GetOneChar();
; 0001 0532     g_BlockSize = ((UINT)(size_h << 8)) | ((UINT)(size_l));
	MOV  R31,R17
	LDI  R30,LOW(0)
	MOVW R26,R30
	MOV  R30,R16
	LDI  R31,0
	OR   R30,R26
	OR   R31,R27
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x3A
; 0001 0533 	g_MemType = GetOneChar();
	RCALL _GetOneChar
	MOV  R12,R30
; 0001 0534 
; 0001 0535     g_Operation = OPERATION_READ;
	LDI  R30,LOW(0)
	STS  _g_Operation,R30
; 0001 0536     g_BlockMode = TRUE;
	LDI  R30,LOW(1)
	STS  _g_BlockMode,R30
; 0001 0537 
; 0001 0538     // ïðîâåðÿåì êîä óñòðîéñòâà
; 0001 0539     if(S89 != g_DeviceType)
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x20142
; 0001 053A        	if('F' == g_MemType)// â ïàìÿòü ïðîãðàìì AVR ïèøåì ñëîâàìè
	LDI  R26,LOW(70)
	CP   R12,R26
	BRNE _0x20143
; 0001 053B       		g_BlockSize /= 2;
	CALL SUBOPT_0x3B
; 0001 053C 	ReadBlock();
_0x20143:
_0x20142:
	RCALL _ReadBlock
; 0001 053D }
_0x20C0025:
	LD   R16,Y+
	LD   R17,Y+
	RET
; .FEND
;
;/*****************************************************************************
;Áëî÷íîå ÷òåíèå äàííûõ
;******************************************************************************/
;void ReadBlock(void)
; 0001 0543 {
_ReadBlock:
; .FSTART _ReadBlock
; 0001 0544   	// ïðîâåðÿåì òèï ïàìÿòè
; 0001 0545     if('F' == g_MemType)//FLASH
	LDI  R26,LOW(70)
	CP   R12,R26
	BRNE _0x20144
; 0001 0546     {
; 0001 0547       	// çàïîëíÿåì áóôåð äàííûìè
; 0001 0548       	while(g_txWR < AVR910_TX_DATA_SIZE)
_0x20145:
	LDS  R26,_g_txWR
	CPI  R26,LOW(0x80)
	BRSH _0x20147
; 0001 0549         {
; 0001 054A           	ReadProg(0x20, 0x28);
	LDI  R30,LOW(32)
	ST   -Y,R30
	LDI  R30,LOW(40)
	ST   -Y,R30
	RCALL _ReadProg
; 0001 054B             if(0 == --g_BlockSize)
	CALL SUBOPT_0x3C
	BRNE _0x20148
; 0001 054C     		{
; 0001 054D       			g_BlockMode = FALSE;
	LDI  R30,LOW(0)
	STS  _g_BlockMode,R30
; 0001 054E                 break;
	RJMP _0x20147
; 0001 054F     		}
; 0001 0550         }
_0x20148:
	RJMP _0x20145
_0x20147:
; 0001 0551 
; 0001 0552     }
; 0001 0553     else// EEPROM
	RJMP _0x20149
_0x20144:
; 0001 0554     {
; 0001 0555       	// çàïîëíÿåì áóôåð äàííûìè
; 0001 0556       	while(g_txWR < AVR910_TX_DATA_SIZE)
_0x2014A:
	LDS  R26,_g_txWR
	CPI  R26,LOW(0x80)
	BRSH _0x2014C
; 0001 0557         {
; 0001 0558           	ReadData();
	RCALL _ReadData
; 0001 0559             if(0 == --g_BlockSize)
	CALL SUBOPT_0x3C
	BRNE _0x2014D
; 0001 055A     		{
; 0001 055B       			g_BlockMode = FALSE;
	LDI  R30,LOW(0)
	STS  _g_BlockMode,R30
; 0001 055C                 break;
	RJMP _0x2014C
; 0001 055D     		}
; 0001 055E         }
_0x2014D:
	RJMP _0x2014A
_0x2014C:
; 0001 055F     }
_0x20149:
; 0001 0560 }
	RET
; .FEND
;
;/*****************************************************************************
;Îáðàáîòêà êîìàíäû áëî÷íîé çàïèñè
;******************************************************************************/
;void WriteBlockCommand(void)
; 0001 0566 {
_WriteBlockCommand:
; .FSTART _WriteBlockCommand
; 0001 0567   	UCHAR size_h,size_l,size_e=1;
; 0001 0568     // ïðîâåðÿåì, åñòü ëè äàííûå äëÿ êîìàíäû
; 0001 0569     CheckCommParams(4);
	CALL __SAVELOCR4
;	size_h -> R17
;	size_l -> R16
;	size_e -> R19
	LDI  R19,1
	CALL SUBOPT_0x2B
; 0001 056A     if(TRUE == g_NeedParams){// if less than 4 bytes waiting==true -> for big size
	BRNE _0x2014E
; 0001 056B       CheckCommParams(3);
	LDI  R30,LOW(3)
	ST   -Y,R30
	RCALL _CheckCommParams
; 0001 056C       size_e=0;
	LDI  R19,LOW(0)
; 0001 056D       if(TRUE == g_NeedParams)
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	BREQ _0x20C0023
; 0001 056E         return;
; 0001 056F     }
; 0001 0570 
; 0001 0571   	// ïîëó÷àåì ðàçìåð áëîêà è òèï ïàìÿòè
; 0001 0572   	if(size_e)
_0x2014E:
	CPI  R19,0
	BREQ _0x20150
; 0001 0573         size_e = GetOneChar();
	RCALL _GetOneChar
	MOV  R19,R30
; 0001 0574     size_h	= GetOneChar();
_0x20150:
	CALL SUBOPT_0x39
; 0001 0575     size_l	= GetOneChar();
; 0001 0576     g_BlockSize		= ((ULONG)((ULONG)size_e << 16)) | ((UINT)(size_h << 8)) | ((UINT)(size_l));
	MOV  R30,R19
	LDI  R31,0
	CALL __CWD1
	CALL __LSLD16
	MOVW R26,R30
	MOVW R24,R22
	MOV  R31,R17
	LDI  R30,LOW(0)
	CALL SUBOPT_0x3D
	MOVW R26,R30
	MOVW R24,R22
	MOV  R30,R16
	LDI  R31,0
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x3A
; 0001 0577     g_MemType		= GetOneChar();
	RCALL _GetOneChar
	MOV  R12,R30
; 0001 0578 	g_BlockMode		= TRUE;
	LDI  R30,LOW(1)
	STS  _g_BlockMode,R30
; 0001 0579     g_Operation		= OPERATION_WRITE;
	STS  _g_Operation,R30
; 0001 057A     g_WordCount 	= 0;
	LDI  R30,LOW(0)
	STS  _g_WordCount,R30
; 0001 057B 
; 0001 057C     // ïðîâåðÿåì êîä óñòðîéñòâà
; 0001 057D     if(S89 != g_DeviceType)
	LDS  R30,_g_DeviceType
	CPI  R30,LOW(0x2)
	BREQ _0x20151
; 0001 057E        	if('F' == g_MemType)// â ïàìÿòü ïðîãðàìì AVR ïèøåì ñëîâàìè*/
	LDI  R26,LOW(70)
	CP   R12,R26
	BRNE _0x20152
; 0001 057F       		g_BlockSize /= 2;
	CALL SUBOPT_0x3B
; 0001 0580 }
_0x20152:
_0x20151:
_0x20C0023:
	CALL __LOADLOCR4
_0x20C0024:
	ADIW R28,4
	RET
; .FEND
;
;/*****************************************************************************
;Áëî÷íûé ðåæèì çàïèñè äàííûõ
;******************************************************************************/
;void WriteBlock(void)
; 0001 0586 {
_WriteBlock:
; .FSTART _WriteBlock
; 0001 0587   	// ïðîâåðÿåì òèï ïàìÿòè
; 0001 0588   	if('E' == g_MemType)// EEPROM
	LDI  R26,LOW(69)
	CP   R12,R26
	BRNE _0x20153
; 0001 0589     {
; 0001 058A     	//while(g_rxLen)
; 0001 058B       	while(0 < g_FIFODataSize)
_0x20154:
	LDS  R30,_g_FIFODataSize
	CPI  R30,LOW(0x1)
	BRLO _0x20156
; 0001 058C     	{
; 0001 058D     		WriteData();
	RCALL _WriteData
; 0001 058E             g_BlockSize--;
	CALL SUBOPT_0x3E
; 0001 058F 		}
	RJMP _0x20154
_0x20156:
; 0001 0590 	}
; 0001 0591 
; 0001 0592 	if('F' == g_MemType)//Flash
_0x20153:
	LDI  R26,LOW(70)
	CP   R12,R26
	BRNE _0x20157
; 0001 0593     {
; 0001 0594        	//while(g_rxLen)
; 0001 0595       	while(0 < g_FIFODataSize)
_0x20158:
	LDS  R30,_g_FIFODataSize
	CPI  R30,LOW(0x1)
	BRLO _0x2015A
; 0001 0596        	{
; 0001 0597        		WriteProgLB();
	RCALL _WriteProgLB
; 0001 0598      		WriteProgHB();
	RCALL _WriteProgHB
; 0001 0599             g_BlockSize--;
	CALL SUBOPT_0x3E
; 0001 059A 
; 0001 059B             // Ïðîâåðÿåì çàïîëíÿåìîñòü ñòðàíèöû
; 0001 059C             if(MEGA == g_DeviceType)
	LDS  R30,_g_DeviceType
	CPI  R30,0
	BRNE _0x2015B
; 0001 059D             {
; 0001 059E                	g_WordCount++;
	LDS  R30,_g_WordCount
	SUBI R30,-LOW(1)
	STS  _g_WordCount,R30
; 0001 059F               	if(g_WordCount == g_DevicePollCode)
	LDS  R30,_g_DevicePollCode
	LDS  R26,_g_WordCount
	CP   R30,R26
	BRNE _0x2015C
; 0001 05A0                 {
; 0001 05A1                   	WritePage();
	RCALL _WritePage
; 0001 05A2                     g_WordCount = 0;
	LDI  R30,LOW(0)
	STS  _g_WordCount,R30
; 0001 05A3                 }
; 0001 05A4             }
_0x2015C:
; 0001 05A5 		}
_0x2015B:
	RJMP _0x20158
_0x2015A:
; 0001 05A6 	}
; 0001 05A7 
; 0001 05A8     // åñëè áëîê êîí÷èëñÿ
; 0001 05A9     if(0 == g_BlockSize)
_0x20157:
	LDS  R30,_g_BlockSize
	LDS  R31,_g_BlockSize+1
	LDS  R22,_g_BlockSize+2
	LDS  R23,_g_BlockSize+3
	CALL __CPD10
	BRNE _0x2015D
; 0001 05AA     {
; 0001 05AB       	// à ñòðàíèöà íå äîãðóæåííà
; 0001 05AC       	if(g_WordCount != 0)
	LDS  R30,_g_WordCount
	CPI  R30,0
	BREQ _0x2015E
; 0001 05AD 
; 0001 05AE           	// çíà÷èò êîíåö çàïèñè äàííûõ,
; 0001 05AF           	// åñëè ïèñàëè â ïàìÿòü ïðîãðàìì òî äîãðóæàåì ñòðàíèöó
; 0001 05B0           	if('F' == g_MemType)//Flash
	LDI  R26,LOW(70)
	CP   R12,R26
	BRNE _0x2015F
; 0001 05B1       			WritePage();
	RCALL _WritePage
; 0001 05B2 
; 0001 05B3       	// îòìå÷àåì, ÷òî áëîê ïðèíÿò
; 0001 05B4       	g_BlockMode = FALSE;
_0x2015F:
_0x2015E:
	LDI  R30,LOW(0)
	STS  _g_BlockMode,R30
; 0001 05B5     	PutOneChar(ACK);
	LDI  R30,LOW(13)
	ST   -Y,R30
	RCALL _PutOneChar
; 0001 05B6     }
; 0001 05B7 }
_0x2015D:
	RET
; .FEND
;
;/*****************************************************************************
;Ñáðîñ áóôåðà
;******************************************************************************/
;void FIFO_Reset(void)
; 0001 05BD {
_FIFO_Reset:
; .FSTART _FIFO_Reset
; 0001 05BE   	g_wrI =
; 0001 05BF     g_rdI = 0;
	LDI  R30,LOW(0)
	STS  _g_rdI,R30
	STS  _g_wrI,R30
; 0001 05C0     g_FIFODataSize = 0;
	STS  _g_FIFODataSize,R30
; 0001 05C1 }
	RET
; .FEND
;
;/*****************************************************************************
;Çàïèñü â áóôåð
;******************************************************************************/
;void FIFO_Write(UCHAR data)
; 0001 05C7 {
_FIFO_Write:
; .FSTART _FIFO_Write
; 0001 05C8   	if(AVR910_FIFO_SIZE > g_FIFODataSize)
;	data -> Y+0
	LDS  R30,_g_FIFODataSize
	CPI  R30,LOW(0x10)
	BRSH _0x20160
; 0001 05C9     {
; 0001 05CA       	g_FIFO[g_wrI++] = data;
	LDS  R30,_g_wrI
	SUBI R30,-LOW(1)
	STS  _g_wrI,R30
	SUBI R30,LOW(1)
	LDI  R31,0
	SUBI R30,LOW(-_g_FIFO)
	SBCI R31,HIGH(-_g_FIFO)
	LD   R26,Y
	STD  Z+0,R26
; 0001 05CB     	g_wrI &= AVR910_FIFO_MASK;
	LDS  R30,_g_wrI
	ANDI R30,LOW(0xF)
	STS  _g_wrI,R30
; 0001 05CC         g_FIFODataSize++;
	LDS  R30,_g_FIFODataSize
	SUBI R30,-LOW(1)
	STS  _g_FIFODataSize,R30
; 0001 05CD     }
; 0001 05CE }
_0x20160:
	RJMP _0x20C0022
; .FEND
;
;/*****************************************************************************
;÷òåíèå èç áóôåðà
;******************************************************************************/
;UCHAR FIFO_Read(void)
; 0001 05D4 {
_FIFO_Read:
; .FSTART _FIFO_Read
; 0001 05D5   	if(0 < g_FIFODataSize)
	LDS  R30,_g_FIFODataSize
	CPI  R30,LOW(0x1)
	BRLO _0x20161
; 0001 05D6     {
; 0001 05D7       	UCHAR data = g_FIFO[g_rdI++];
; 0001 05D8     	g_rdI &= AVR910_FIFO_MASK;
	SBIW R28,1
;	data -> Y+0
	LDS  R30,_g_rdI
	SUBI R30,-LOW(1)
	STS  _g_rdI,R30
	SUBI R30,LOW(1)
	LDI  R31,0
	SUBI R30,LOW(-_g_FIFO)
	SBCI R31,HIGH(-_g_FIFO)
	LD   R30,Z
	ST   Y,R30
	LDS  R30,_g_rdI
	ANDI R30,LOW(0xF)
	STS  _g_rdI,R30
; 0001 05D9         g_FIFODataSize--;
	LDS  R30,_g_FIFODataSize
	SUBI R30,LOW(1)
	STS  _g_FIFODataSize,R30
; 0001 05DA         return data;
	LD   R30,Y
	RJMP _0x20C0022
; 0001 05DB     }
; 0001 05DC 
; 0001 05DD   	return 0;
_0x20161:
	LDI  R30,LOW(0)
	RET
; 0001 05DE }
; .FEND
;
;/*****************************************************************************
;Ïðîâåðÿåì, åñòü ëè â áóôåðå ïàðàìåòðû äëÿ êîìàíäû
;******************************************************************************/
;void CheckCommParams(UCHAR req_bytes)
; 0001 05E4 {
_CheckCommParams:
; .FSTART _CheckCommParams
; 0001 05E5   	// åñëè â FIFO ìåíüøå äàííûõ, ÷åì òðåáóåòñÿ äëÿ ïàðàìåòðîâ êîìàíäû
; 0001 05E6   	// óñòàíàâëèâàåì ôëàã îæèäàíèÿ ïðèõîäà ïàðàìåòðîâ
; 0001 05E7   	if(req_bytes > g_FIFODataSize)
;	req_bytes -> Y+0
	LDS  R30,_g_FIFODataSize
	LD   R26,Y
	CP   R30,R26
	BRSH _0x20162
; 0001 05E8     	g_NeedParams = TRUE;
	LDI  R30,LOW(1)
	RJMP _0x20168
; 0001 05E9     else
_0x20162:
; 0001 05EA       	g_NeedParams = FALSE;
	LDI  R30,LOW(0)
_0x20168:
	STS  _g_NeedParams,R30
; 0001 05EB }
	RJMP _0x20C0022
; .FEND
;
;
;#include "common.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif
;
;
;//Standalone globals
;//#define  FLASH_START_ADDR_WORD  15000
;//#define  FLASH_START_ADDR_BYTE  (FLASH_START_ADDR_WORD<<1)
;
;//UCHAR chipname[12]; // chip signature compare variable
;//UCHAR signature[3]; // chip signature compare variable
;
;//ULONG chipsize =0 ; //chip size in bytes
;//UINT pagesize;// target flash page size in bytes, i count bytes in page buffer
;//UCHAR progfuses[MAX_FUSES];	       /* fuses to set during programming */    //Lock,Low,High,Ext
;//UCHAR normfuses[MAX_FUSES];	       /* fuses to set after programming */
;//UCHAR maskfuses[MAX_FUSES];
;//UCHAR chipcode;                  /* device code ie m64 is 0x45 */
;UCHAR tmpbytes[32];//resetprogcounter=00000000h
;UCHAR g_UpSkip;
;UCHAR g_DownSkip;
;UCHAR g_MaxFolders;
;
;ULONG pageaddr = 0; //page address byte counter
;volatile STANDALONE_MODE StandaloneMode=IDLE;
;UCHAR pageBuffer[PAGE_SIZE_BYTES];		       /* One page of flash in bytes = words/2 */
;bit CanContinueRead=0;
;bit EndOfFile=0;
;ULONG OffsetX16=0;
;UCHAR Save_i;
;UCHAR Save_cksum = 0;
;UCHAR Save_len;
;bit blankpage; // flag is true if can skip page
;UCHAR debug=0;
;UCHAR *value;  //sdcard/tmpbytes[32] return string pointer if found
;//bit FromSD;
;//UCHAR *hextext;//
;UCHAR dirnum;//number of project directory
;eeprom  UCHAR   SaveDirNum  @5;  //eeprom cell to save last project directory number
;eeprom  UCHAR   SaveLockState  @6;  //eeprom to list folder prees Up 10 sec to lock press Start 10 sec
;char temptext[30];
;
;eeprom eeimage_t myimage[MAX_PROJECTS] @10;
;image_t tmpimage;
;//flash byte hextext[40000] ;//,*hextextpos;
;   //hextext =(byte flash  *)2000;
;
;//error function. print error
;void error(flash char *str)
; 0002 0030 {

	.CSEG
_error:
; .FSTART _error
; 0002 0031 #ifdef PRINT_DEBUG
; 0002 0032    if(debug){
;	*str -> Y+0
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40003
; 0002 0033    while(tx_counter);
_0x40004:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40004
; 0002 0034    printf("\r\nError.fptr=%u,buf[0]=%02x,buf[1]=%02x\r\n",(fs.fptr),buffer[0],buffer[1]);
	__POINTW1FN _0x40000,0
	ST   -Y,R31
	ST   -Y,R30
	__GETD1MN _fs,24
	CALL __PUTPARD1
	LDS  R30,_buffer
	CALL SUBOPT_0x3F
	__GETB1MN _buffer,1
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x40
; 0002 0035    printf(str);
	LD   R30,Y
	LDD  R31,Y+1
	CALL SUBOPT_0x22
; 0002 0036    while(tx_counter);}
_0x40007:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40007
; 0002 0037 #endif
; 0002 0038 #ifdef PRINT_LCD
; 0002 0039     //lcd_putsf_row(1,"Hex digit fail");
; 0002 003A #endif
; 0002 003B //while(1);
; 0002 003C }
_0x40003:
	RJMP _0x20C0021
; .FEND
;
;//read byte from byte prointer to SRAM
;UCHAR pgm_read_byte(UCHAR *addr)
; 0002 0040 {
_pgm_read_byte:
; .FSTART _pgm_read_byte
; 0002 0041     return *addr;
;	*addr -> Y+0
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	RJMP _0x20C0021
; 0002 0042 }
; .FEND
;
;//read byte from hextext byte pointer to SRAM then increment it
;UCHAR hextext_read_byte(void)
; 0002 0046 {
_hextext_read_byte:
; .FSTART _hextext_read_byte
; 0002 0047     #ifdef BOOTEEPROM
; 0002 0048     return *hextext++;
; 0002 0049     #else
; 0002 004A     return pgm_read_byte_sd();
	CALL _pgm_read_byte_sd
	RET
; 0002 004B     #endif
; 0002 004C }
; .FEND
;
;//convert char hex digit
;UCHAR hexton (UCHAR h)
; 0002 0050 {
_hexton:
; .FSTART _hexton
; 0002 0051   if (h >= '0' && h <= '9')
;	h -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0x30)
	BRLO _0x4000B
	CPI  R26,LOW(0x3A)
	BRLO _0x4000C
_0x4000B:
	RJMP _0x4000A
_0x4000C:
; 0002 0052     return(h - '0');
	LD   R30,Y
	SUBI R30,LOW(48)
	RJMP _0x20C0022
; 0002 0053   if (h >= 'A' && h <= 'F')
_0x4000A:
	LD   R26,Y
	CPI  R26,LOW(0x41)
	BRLO _0x4000E
	CPI  R26,LOW(0x47)
	BRLO _0x4000F
_0x4000E:
	RJMP _0x4000D
_0x4000F:
; 0002 0054     return((h - 'A') + 10);
	LD   R30,Y
	SUBI R30,LOW(55)
	RJMP _0x20C0022
; 0002 0055   #ifdef PRINT_DEBUG
; 0002 0056     if(debug){
_0x4000D:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40010
; 0002 0057     while(tx_counter);
_0x40011:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40011
; 0002 0058     printf("\r\nBad hex=%02x\r\n",h);
	__POINTW1FN _0x40000,42
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x41
; 0002 0059     while(tx_counter);}
_0x40014:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40014
; 0002 005A     #endif
; 0002 005B   error("Bad hex digit!");
_0x40010:
	__POINTW1FN _0x40000,59
	CALL SUBOPT_0x42
; 0002 005C }
_0x20C0022:
	ADIW R28,1
	RET
; .FEND
;
;
;//convert 2 first chars in string to 2 hex digits that represent UCHAR
;UCHAR hextobyte(char *str)
; 0002 0061 {
_hextobyte:
; .FSTART _hextobyte
; 0002 0062   return hexton(*str)<<4 | hexton(*(str+sizeof(UCHAR))); //read 0xFF  1=F, 1=F sizeof(UCHAR)=1 byte
;	*str -> Y+0
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	ST   -Y,R30
	RCALL _hexton
	SWAP R30
	ANDI R30,0xF0
	PUSH R30
	LD   R30,Y
	LDD  R31,Y+1
	LDD  R26,Z+1
	ST   -Y,R26
	RCALL _hexton
	POP  R26
	OR   R30,R26
_0x20C0021:
	ADIW R28,2
	RET
; 0002 0063 }
; .FEND
;
;//get bytes from string and put to array in eeprom. Exm: RAM str="76"(0x37,0x36) -> EEPROM arr[0]=0x76
;void hextobytese(char *str,eeprom UCHAR *arr,UCHAR len)
; 0002 0067 {
; 0002 0068   UCHAR i;
; 0002 0069   for(i=0;i<len;i++){
;	*str -> Y+4
;	*arr -> Y+2
;	len -> Y+1
;	i -> R17
; 0002 006A    arr[i]=hextobyte(str+(i*2*sizeof(UCHAR)));
; 0002 006B   }
; 0002 006C }
;
;//get bytes from string and put to array in SRAM. Exm: RAM str="76"(0x37,0x36) -> SRAM arr[0]=0x76
;void hextobytes(char *str,UCHAR *arr,UCHAR len)
; 0002 0070 {
_hextobytes:
; .FSTART _hextobytes
; 0002 0071   UCHAR i;
; 0002 0072   for(i=0;i<len;i++){
	ST   -Y,R17
;	*str -> Y+4
;	*arr -> Y+2
;	len -> Y+1
;	i -> R17
	LDI  R17,LOW(0)
_0x4001B:
	LDD  R30,Y+1
	CP   R17,R30
	BRSH _0x4001C
; 0002 0073    arr[i]=hextobyte(str+(i*2*sizeof(UCHAR)));
	MOV  R30,R17
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	LDI  R30,LOW(2)
	MUL  R30,R17
	MOVW R30,R0
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADD  R30,R26
	ADC  R31,R27
	ST   -Y,R31
	ST   -Y,R30
	RCALL _hextobyte
	POP  R26
	POP  R27
	ST   X,R30
; 0002 0074   }
	SUBI R17,-1
	RJMP _0x4001B
_0x4001C:
; 0002 0075 }
	LDD  R17,Y+0
	ADIW R28,6
	RET
; .FEND
;
;//convert 4 first chars in string to 4 hex digits that represent UINT
;UINT hextouint(char *str)
; 0002 0079 {
; 0002 007A   return (UINT)((UINT)hextobyte(str)<<8 | (UINT)hextobyte(str+2*sizeof(UCHAR))); //read 0xFFFF 1=F 2=F, 1=F 2=F   sizeof ...
;	*str -> Y+0
; 0002 007B }
;
;//convert 8 first chars in string to 8 hex digits that represent ULONG
;ULONG hextoulong(char *str)
; 0002 007F {
; 0002 0080   return (ULONG)((ULONG)hextouint(str)<<16 | (ULONG)hextouint(str+2*sizeof(UINT)));//read 0xFFFFFFFF 1=F 2=F 3=F 4=F, 1= ...
;	*str -> Y+0
; 0002 0081 }
;
;/*Copy null terminated string, from pointer to SRAM to pointer to eeprom*/
;void strcpye(eeprom char *str1,char *str2)
; 0002 0085 {
; 0002 0086    while(*str2){
;	*str1 -> Y+2
;	*str2 -> Y+0
; 0002 0087       *str1= *str2;
; 0002 0088       str1++;str2++;
; 0002 0089    }
; 0002 008A    str1=0;
; 0002 008B }
;
;/*Copy number of bytes, from pointer to SRAM to pointer to eeprom*/
;void memcpye(eeprom UCHAR *str1,UCHAR *str2,UCHAR len)
; 0002 008F {
; 0002 0090    while(len){
;	*str1 -> Y+3
;	*str2 -> Y+1
;	len -> Y+0
; 0002 0091       *str1= *str2;
; 0002 0092       str1++;str2++;
; 0002 0093       len--;
; 0002 0094    }
; 0002 0095 }
;
;/*Copy null terminated string, from pointer to eeprom -> to pointer to SRAM*/
;void strecpy(char *str1,eeprom char *str2)
; 0002 0099 {
; 0002 009A    while(*str2){
;	*str1 -> Y+2
;	*str2 -> Y+0
; 0002 009B       *str1= *str2;
; 0002 009C       str1++;str2++;
; 0002 009D    }
; 0002 009E    str2=0;
; 0002 009F }
;/*Copy null terminated string, from pointer to eeprom -> to pointer to SRAM n chars*/
;void strencpy(char *str1,eeprom char *str2,char num)
; 0002 00A2 {
; 0002 00A3    while(*str2 && num){
;	*str1 -> Y+3
;	*str2 -> Y+1
;	num -> Y+0
; 0002 00A4       *str1= *str2;
; 0002 00A5       str1++;str2++;
; 0002 00A6       num--;
; 0002 00A7    }
; 0002 00A8    str2=0;
; 0002 00A9 }
;/*Copy number of bytes, from pointer to eeprom -> to pointer to SRAM*/
;void memecpy(UCHAR *str1,eeprom UCHAR *str2,UCHAR len)
; 0002 00AC {
; 0002 00AD    while(len){
;	*str1 -> Y+3
;	*str2 -> Y+1
;	len -> Y+0
; 0002 00AE       *str1= *str2;
; 0002 00AF       str1++;str2++;
; 0002 00B0       len--;
; 0002 00B1    }
; 0002 00B2 }
;
;/* compare RAM string with EEPROM string. If RAM > EEPROM return 1*/
;signed char strcmpe(char *str1,eeprom char *str2)
; 0002 00B6 {
; 0002 00B7    while(*str1 && *str2){
;	*str1 -> Y+2
;	*str2 -> Y+0
; 0002 00B8       if(*str1> *str2)return 1;
; 0002 00B9       if(*str1< *str2)return -1;
; 0002 00BA       str1++;str2++;
; 0002 00BB    }
; 0002 00BC    return 0;
; 0002 00BD }
;
;void PrintImage(void){
; 0002 00BF void PrintImage(void){
_PrintImage:
; .FSTART _PrintImage
; 0002 00C0 #ifdef PRINT_DEBUG
; 0002 00C1         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BRNE PC+2
	RJMP _0x40035
; 0002 00C2         printf("\r\ndebug=%d",tmpimage.debug);
	__POINTW1FN _0x40000,74
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,91
	CALL SUBOPT_0x43
	CALL SUBOPT_0x41
; 0002 00C3         while(tx_counter);
_0x40036:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40036
; 0002 00C4         printf("\r\nfilename = %s",tmpimage.hexfile);
	__POINTW1FN _0x40000,85
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_tmpimage)
	LDI  R31,HIGH(_tmpimage)
	CALL SUBOPT_0x44
; 0002 00C5         while(tx_counter);
_0x40039:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40039
; 0002 00C6         printf("\r\nfw_ver = %s",tmpimage.fw_ver);
	__POINTW1FN _0x40000,101
	CALL SUBOPT_0x45
; 0002 00C7         while(tx_counter);
_0x4003C:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4003C
; 0002 00C8         printf("\r\nchipname = %s",tmpimage.chipname);
	__POINTW1FN _0x40000,115
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _tmpimage,32
	CALL SUBOPT_0x44
; 0002 00C9         while(tx_counter);
_0x4003F:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4003F
; 0002 00CA         printf("\r\nchipcode = 0x%x",tmpimage.chipcode);
	__POINTW1FN _0x40000,131
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,48
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x41
; 0002 00CB         while(tx_counter);
_0x40042:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40042
; 0002 00CC         printf("\r\nsignature = %02x %02x %02x",tmpimage.signature[0],tmpimage.signature[1],tmpimage.signature[2]);
	__POINTW1FN _0x40000,149
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,49
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,50
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,51
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x40
; 0002 00CD         while(tx_counter);
_0x40045:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40045
; 0002 00CE         printf("\r\nprogfuses = %02x %02x %02x %02x",tmpimage.progfuses[0],tmpimage.progfuses[1],tmpimage.progfuses[2],t ...
	__POINTW1FN _0x40000,178
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,52
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,53
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,54
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,55
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x46
; 0002 00CF         while(tx_counter);
_0x40048:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40048
; 0002 00D0         //memecpy(normfuses,myimage.normfuses,4);
; 0002 00D1         printf("\r\nnormfuses = %02x %02x %02x %02x",tmpimage.normfuses[0],tmpimage.normfuses[1],tmpimage.normfuses[2],t ...
	__POINTW1FN _0x40000,212
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,56
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,57
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,58
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,59
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x46
; 0002 00D2         while(tx_counter);
_0x4004B:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4004B
; 0002 00D3         //memecpy(maskfuses,myimage.maskfuses,4);
; 0002 00D4         printf("\r\nmaskfuses = %02x %02x %02x %02x",tmpimage.maskfuses[0],tmpimage.maskfuses[1],tmpimage.maskfuses[2],t ...
	__POINTW1FN _0x40000,246
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,60
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,61
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,62
	CALL SUBOPT_0x3F
	__GETB1MN _tmpimage,63
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x46
; 0002 00D5         while(tx_counter);
_0x4004E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4004E
; 0002 00D6         printf("\r\nchipsize = %lu",tmpimage.chipsize);
	__POINTW1FN _0x40000,280
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x47
	CALL SUBOPT_0x48
; 0002 00D7         while(tx_counter);
_0x40051:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40051
; 0002 00D8         printf("\r\npagesize = %u",tmpimage.pagesize);
	__POINTW1FN _0x40000,297
	CALL SUBOPT_0x49
	CALL SUBOPT_0x44
; 0002 00D9         while(tx_counter);
_0x40054:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40054
; 0002 00DA         printf("\r\nProgramming Done = %lu",myimage[dirnum].ProgCounterDone);
	__POINTW1FN _0x40000,313
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
	CALL SUBOPT_0x48
; 0002 00DB         while(tx_counter);
_0x40057:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40057
; 0002 00DC         printf("\r\nProgramming Available = %lu",tmpimage.ProgCounterTotal);
	__POINTW1FN _0x40000,338
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x1C
	CALL SUBOPT_0x41
; 0002 00DD         while(tx_counter);
_0x4005A:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4005A
; 0002 00DE         }
; 0002 00DF #endif
; 0002 00E0 }
_0x40035:
	RET
; .FEND
;
;
;/*Function for Boot From EEPROM version (SDCARD hex copied to FLASH).
;    Copy the project definitions from eeprom to SRAM*/
;#ifdef BOOTEEPROM
;void CopyEepromToRam(void)
;{
;    strecpy(tmpimage.chipname,myimage[dirnum].chipname);
;    tmpimage.chipcode=myimage[dirnum].chipcode;
;    memecpy(tmpimage.signature,myimage[dirnum].signature,3);
;    memecpy(tmpimage.progfuses,myimage[dirnum].progfuses,MAX_FUSES);
;    memecpy(tmpimage.normfuses,myimage[dirnum].normfuses,MAX_FUSES);
;    memecpy(tmpimage.maskfuses,myimage[dirnum].maskfuses,MAX_FUSES);
;}
;#endif
;UCHAR Call_EnterProgMode(void)
; 0002 00F1 {
_Call_EnterProgMode:
; .FSTART _Call_EnterProgMode
; 0002 00F2     #ifdef PRINT_DEBUG
; 0002 00F3     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4005D
; 0002 00F4     printf("\r\nStarting Program Mode... ");
	__POINTW1FN _0x40000,368
	CALL SUBOPT_0x22
; 0002 00F5     while(tx_counter);}
_0x4005E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4005E
; 0002 00F6     #endif
; 0002 00F7     #ifdef PRINT_LCD
; 0002 00F8     lcd_putsf_row(1,"Prog Mode ");
_0x4005D:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,396
	CALL SUBOPT_0xC
; 0002 00F9     #endif
; 0002 00FA     AVR910_Standalone("P");//send enter to prog mode -> should answer 0x0D=ACK  /* Turn on target power */
	__POINTW1FN _0x40000,407
	CALL SUBOPT_0x4C
; 0002 00FB     if(g_txBuf[0]!=ACK){
	LDS  R26,_g_txBuf
	CPI  R26,LOW(0xD)
	BREQ _0x40061
; 0002 00FC         #ifdef PRINT_DEBUG
; 0002 00FD         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40062
; 0002 00FE         printf("FAIL");
	__POINTW1FN _0x40000,409
	CALL SUBOPT_0x22
; 0002 00FF         while(tx_counter);}
_0x40063:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40063
; 0002 0100         #endif
; 0002 0101         #ifdef PRINT_LCD
; 0002 0102         lcd_putsf_row(1,"No target");
_0x40062:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,414
	CALL SUBOPT_0xC
; 0002 0103         #endif
; 0002 0104         return FALSE;
	RJMP _0x20C0020
; 0002 0105     }
; 0002 0106     #ifdef PRINT_DEBUG
; 0002 0107     if(debug){
_0x40061:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40066
; 0002 0108     printf(" OK.");
	__POINTW1FN _0x40000,424
	CALL SUBOPT_0x22
; 0002 0109     while(tx_counter);}
_0x40067:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40067
; 0002 010A     #endif
; 0002 010B     #ifdef PRINT_LCD
; 0002 010C     lcd_putsf("Done");
_0x40066:
	__POINTW1FN _0x40000,429
	CALL SUBOPT_0x2
; 0002 010D     #endif
; 0002 010E     return TRUE;
	RJMP _0x20C001E
; 0002 010F }
; .FEND
;UCHAR Call_GetConfig(void){
; 0002 0110 UCHAR Call_GetConfig(void){
_Call_GetConfig:
; .FSTART _Call_GetConfig
; 0002 0111     if(sd_mount()==FALSE){// if sdcard is missing
	CALL _sd_mount
	CPI  R30,0
	BRNE _0x4006A
; 0002 0112         #ifdef PRINT_DEBUG
; 0002 0113         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4006B
; 0002 0114         printf("\r\nCall sd_mount func failed \r\n");
	__POINTW1FN _0x40000,434
	CALL SUBOPT_0x22
; 0002 0115         while(tx_counter);}
_0x4006C:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4006C
; 0002 0116         #endif
; 0002 0117         Beeps(2,1);
_0x4006B:
	CALL SUBOPT_0x18
; 0002 0118         goto print_error;
	RJMP _0x4006F
; 0002 0119     }
; 0002 011A     else{//try to copy image definitions from sdcard to eeprom and reset to bootloader to load hex to flash
_0x4006A:
; 0002 011B         #ifdef PRINT_DEBUG
; 0002 011C         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40071
; 0002 011D         while(tx_counter);
_0x40072:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40072
; 0002 011E         printf("\r\nCall sd_mount func ok \r\n");
	__POINTW1FN _0x40000,465
	CALL SUBOPT_0x22
; 0002 011F         while(tx_counter);}
_0x40075:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40075
; 0002 0120         #endif
; 0002 0121         if((value=GetConfigValue("up"))==NULL)
_0x40071:
	__POINTW1FN _0x40000,492
	CALL SUBOPT_0x4D
	BREQ _0x4006F
; 0002 0122               goto print_error;
; 0002 0123         g_UpSkip=atoi(value);
	CALL SUBOPT_0x4E
	STS  _g_UpSkip,R30
; 0002 0124         if((value=GetConfigValue("down"))==NULL)
	__POINTW1FN _0x40000,495
	CALL SUBOPT_0x4D
	BREQ _0x4006F
; 0002 0125               goto print_error;
; 0002 0126         g_DownSkip=atoi(value);
	CALL SUBOPT_0x4E
	STS  _g_DownSkip,R30
; 0002 0127         if((value=GetConfigValue("maxfolders"))==NULL)
	__POINTW1FN _0x40000,500
	CALL SUBOPT_0x4D
	BREQ _0x4006F
; 0002 0128               goto print_error;
; 0002 0129         g_MaxFolders=atoi(value);
	CALL SUBOPT_0x4E
	STS  _g_MaxFolders,R30
; 0002 012A         return TRUE;
	RJMP _0x20C001E
; 0002 012B     }
; 0002 012C     #ifdef PRINT_DEBUG
; 0002 012D     if(debug){
; 0002 012E     while(tx_counter);
_0x4007C:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4007C
; 0002 012F     printf("\r\nconfig: Up=%d Down=%d MaxFolders=%d",g_UpSkip,g_DownSkip,g_MaxFolders);
	__POINTW1FN _0x40000,511
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_g_UpSkip
	CALL SUBOPT_0x3F
	LDS  R30,_g_DownSkip
	CALL SUBOPT_0x3F
	LDS  R30,_g_MaxFolders
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x40
; 0002 0130     while(tx_counter);}
_0x4007F:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4007F
; 0002 0131     #endif
; 0002 0132 print_error:
_0x4006F:
; 0002 0133     return FALSE;
	RJMP _0x20C0020
; 0002 0134 }
; .FEND
;
;UCHAR Call_GetDir(void){
; 0002 0136 UCHAR Call_GetDir(void){
_Call_GetDir:
; .FSTART _Call_GetDir
; 0002 0137     if(sd_mount()==FALSE){// if sdcard is missing
	CALL _sd_mount
	CPI  R30,0
	BRNE _0x40082
; 0002 0138         #ifdef PRINT_DEBUG
; 0002 0139         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40083
; 0002 013A         printf("\r\nCall sd_mount func failed \r\n");
	__POINTW1FN _0x40000,434
	CALL SUBOPT_0x22
; 0002 013B         while(tx_counter);}
_0x40084:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40084
; 0002 013C         #endif
; 0002 013D         Beeps(2,1);
_0x40083:
	CALL SUBOPT_0x18
; 0002 013E         return FALSE;
	RJMP _0x20C0020
; 0002 013F     }
; 0002 0140     else{//try to copy image definitions from sdcard to eeprom and reset to bootloader to load hex to flash
_0x40082:
; 0002 0141         #ifdef PRINT_DEBUG
; 0002 0142         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40088
; 0002 0143         while(tx_counter);
_0x40089:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40089
; 0002 0144         printf("\r\nCall sd_mount func ok \r\n");
	__POINTW1FN _0x40000,465
	CALL SUBOPT_0x22
; 0002 0145         while(tx_counter);}
_0x4008C:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4008C
; 0002 0146         #endif
; 0002 0147        //myimage[dirnum].RollCounter=63;//test case
; 0002 0148        tmpimage.RollCounter=myimage[dirnum].RollCounter; //63
_0x40088:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4F
	__PUTB1MN _tmpimage,92
; 0002 0149        if( GetRollCounter("rollcounter")==NULL)
	__POINTW1FN _0x40000,549
	ST   -Y,R31
	ST   -Y,R30
	CALL _GetRollCounter
	SBIW R30,0
	BRNE _0x4008F
; 0002 014A               return FALSE;
	RJMP _0x20C0020
; 0002 014B        #ifdef PRINT_DEBUG
; 0002 014C         if(debug){
_0x4008F:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40090
; 0002 014D         while(tx_counter);
_0x40091:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40091
; 0002 014E         printf("\r\nbuffer\r\n%s",buffer);
	__POINTW1FN _0x40000,561
	CALL SUBOPT_0x50
	CALL SUBOPT_0x44
; 0002 014F         while(tx_counter);}
_0x40094:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40094
; 0002 0150         #endif
; 0002 0151        if(tmpimage.RollCounter > myimage[dirnum].RollCounter || (myimage[dirnum].RollCounter>(ROLL_SIZE-ROLL_WINDOW))){/ ...
_0x40090:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4F
	__GETB2MN _tmpimage,92
	CP   R30,R26
	BRLO _0x40098
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4F
	CPI  R30,LOW(0x3C)
	BRLO _0x40097
_0x40098:
; 0002 0152              myimage[dirnum].RollCounter = tmpimage.RollCounter ;//save new roll number
	CALL SUBOPT_0x4A
	__ADDW1MN _myimage,4
	MOVW R26,R30
	__GETB1MN _tmpimage,92
	CALL __EEPROMWRB
; 0002 0153              if((value=GetValue("progcounterreset"))==NULL)
	__POINTW1FN _0x40000,574
	CALL SUBOPT_0x51
	BRNE _0x4009A
; 0002 0154                   return FALSE;
	RJMP _0x20C0020
; 0002 0155              if(atoi(value)==1){//reset prog counter case
_0x4009A:
	CALL SUBOPT_0x4E
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x4009B
; 0002 0156                 myimage[dirnum].ProgCounterDone=0;
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x52
; 0002 0157                 #ifdef PRINT_DEBUG
; 0002 0158                 if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4009C
; 0002 0159                 while(tx_counter);
_0x4009D:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4009D
; 0002 015A                 printf("\r\nReset prog counter done.\r\n");
	__POINTW1FN _0x40000,591
	CALL SUBOPT_0x22
; 0002 015B                 while(tx_counter);}
_0x400A0:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400A0
; 0002 015C                 #endif
; 0002 015D              }
_0x4009C:
; 0002 015E        }
_0x4009B:
; 0002 015F        if(myimage[dirnum].ProgCounterDone>0xf0000001)
_0x40097:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
	__CPD1N 0xF0000002
	BRLO _0x400A3
; 0002 0160             myimage[dirnum].ProgCounterDone=0;
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x52
; 0002 0161        tmpimage.ProgCounterDone=myimage[dirnum].ProgCounterDone;
_0x400A3:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x53
; 0002 0162        if((value=GetValue("maxprogs"))==NULL)
	__POINTW1FN _0x40000,620
	CALL SUBOPT_0x51
	BRNE _0x400A4
; 0002 0163             return FALSE;
	RJMP _0x20C0020
; 0002 0164        tmpimage.ProgCounterTotal=atol(value);
_0x400A4:
	CALL SUBOPT_0x54
	__PUTW1MN _tmpimage,72
; 0002 0165        //tmpimage.ProgCounterTotal=hextoulong(value);
; 0002 0166        if((value=GetValue("pagesize"))==NULL)
	__POINTW1FN _0x40000,629
	CALL SUBOPT_0x51
	BRNE _0x400A5
; 0002 0167             return FALSE;
	RJMP _0x20C0020
; 0002 0168        tmpimage.pagesize=atoi(value);
_0x400A5:
	CALL SUBOPT_0x4E
	__PUTW1MN _tmpimage,68
; 0002 0169        //tmpimage.pagesize=hextouint(value);
; 0002 016A        if((value=GetValue("chipsize"))==NULL)
	__POINTW1FN _0x40000,638
	CALL SUBOPT_0x51
	BRNE _0x400A6
; 0002 016B             return FALSE;
	RJMP _0x20C0020
; 0002 016C        tmpimage.chipsize=atol(value);
_0x400A6:
	CALL SUBOPT_0x54
	__PUTD1MN _tmpimage,64
; 0002 016D        //tmpimage.chipsize=hextoulong(value);
; 0002 016E        if((value=GetValue("maskfuses"))==NULL)
	__POINTW1FN _0x40000,647
	CALL SUBOPT_0x51
	BRNE _0x400A7
; 0002 016F             return FALSE;
	RJMP _0x20C0020
; 0002 0170        hextobytes(value,tmpimage.maskfuses,MAX_FUSES);
_0x400A7:
	CALL SUBOPT_0x55
	CALL SUBOPT_0x56
	CALL SUBOPT_0x57
; 0002 0171        if((value=GetValue("normfuses"))==NULL)
	__POINTW1FN _0x40000,657
	CALL SUBOPT_0x51
	BRNE _0x400A8
; 0002 0172             return FALSE;
	RJMP _0x20C0020
; 0002 0173        hextobytes(value,tmpimage.normfuses,MAX_FUSES);
_0x400A8:
	CALL SUBOPT_0x55
	CALL SUBOPT_0x58
	CALL SUBOPT_0x57
; 0002 0174        if((value=GetValue("progfuses"))==NULL)
	__POINTW1FN _0x40000,667
	CALL SUBOPT_0x51
	BRNE _0x400A9
; 0002 0175             return FALSE;
	RJMP _0x20C0020
; 0002 0176        hextobytes(value,tmpimage.progfuses,MAX_FUSES);
_0x400A9:
	CALL SUBOPT_0x55
	CALL SUBOPT_0x59
	CALL SUBOPT_0x57
; 0002 0177        if((value=GetValue("signature"))==NULL)
	__POINTW1FN _0x40000,677
	CALL SUBOPT_0x51
	BRNE _0x400AA
; 0002 0178             return FALSE;
	RJMP _0x20C0020
; 0002 0179        hextobytes(value,tmpimage.signature,3);
_0x400AA:
	CALL SUBOPT_0x55
	__POINTW1MN _tmpimage,49
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(3)
	ST   -Y,R30
	RCALL _hextobytes
; 0002 017A        tmpimage.spidiv=1;
	LDI  R30,LOW(1)
	__PUTB1MN _tmpimage,93
; 0002 017B        if((value=GetValue("spidiv"))!=NULL)
	__POINTW1FN _0x40000,687
	CALL SUBOPT_0x51
	BREQ _0x400AB
; 0002 017C        {
; 0002 017D             tmpimage.spidiv=atoi(value);
	CALL SUBOPT_0x4E
	__PUTB1MN _tmpimage,93
; 0002 017E             //tmpimage.spidiv=hextobyte(value);
; 0002 017F        }
; 0002 0180        if(tmpimage.spidiv>7)
_0x400AB:
	__GETB2MN _tmpimage,93
	CPI  R26,LOW(0x8)
	BRLO _0x400AC
; 0002 0181             tmpimage.spidiv=1;
	LDI  R30,LOW(1)
	__PUTB1MN _tmpimage,93
; 0002 0182        tmpimage.spidiv=1<<tmpimage.spidiv;
_0x400AC:
	__GETB1MN _tmpimage,93
	LDI  R26,LOW(1)
	CALL __LSLB12
	__PUTB1MN _tmpimage,93
; 0002 0183 
; 0002 0184        strncpy(tmpimage.fw_ver,value=GetValue("proginfo"),16);
	__POINTW1MN _tmpimage,75
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0x40000,694
	CALL SUBOPT_0x5A
	LDI  R30,LOW(16)
	ST   -Y,R30
	CALL _strncpy
; 0002 0185        strncpy(tmpimage.progname,value=GetValue("progname"),12);
	__POINTW1MN _tmpimage,16
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0x40000,703
	CALL SUBOPT_0x5A
	LDI  R30,LOW(12)
	ST   -Y,R30
	CALL _strncpy
; 0002 0186        #ifdef PRINT_DEBUG
; 0002 0187        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400AD
; 0002 0188        while(tx_counter);
_0x400AE:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400AE
; 0002 0189        printf("\r\nproginfo=%s",tmpimage.fw_ver);
	__POINTW1FN _0x40000,712
	CALL SUBOPT_0x45
; 0002 018A        printf("\r\nspidiv=%d",tmpimage.spidiv);
	__POINTW1FN _0x40000,726
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,93
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x41
; 0002 018B        while(tx_counter);}
_0x400B1:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400B1
; 0002 018C        #endif
; 0002 018D print_image:
_0x400AD:
; 0002 018E        #ifdef BOOTEEPROM
; 0002 018F        CopyEepromToRam();
; 0002 0190        #endif
; 0002 0191        #ifdef PRINT_DEBUG
; 0002 0192        PrintImage();
	RCALL _PrintImage
; 0002 0193        #endif
; 0002 0194        #ifdef BOOTEEPROM
; 0002 0195        myimage.FlashStartAddrByte=FLASH_START_ADDR_WORD<<1;
; 0002 0196        AVR910_Standalone("E");//reboot  to bootloader
; 0002 0197        #endif
; 0002 0198    }
; 0002 0199    return TRUE;
	RJMP _0x20C001E
; 0002 019A }
; .FEND
;void ResetGlobals(void)
; 0002 019C {
_ResetGlobals:
; .FSTART _ResetGlobals
; 0002 019D    CanContinueRead=0;
	CBI  0x1E,1
; 0002 019E    EndOfFile=0;
	CBI  0x1E,2
; 0002 019F    g_Operation = OPERATION_READ;
	LDI  R30,LOW(0)
	STS  _g_Operation,R30
; 0002 01A0    g_BlockMode = FALSE;
	STS  _g_BlockMode,R30
; 0002 01A1    OffsetX16=0;
	STS  _OffsetX16,R30
	STS  _OffsetX16+1,R30
	STS  _OffsetX16+2,R30
	STS  _OffsetX16+3,R30
; 0002 01A2    blankpage=FALSE;
	CBI  0x1E,3
; 0002 01A3    pageaddr=0;//reset address byte counter
	STS  _pageaddr,R30
	STS  _pageaddr+1,R30
	STS  _pageaddr+2,R30
	STS  _pageaddr+3,R30
; 0002 01A4 }
	RET
; .FEND
;UCHAR Call_ReadSignature(void)
; 0002 01A6 {
_Call_ReadSignature:
; .FSTART _Call_ReadSignature
; 0002 01A7    AVR910_Standalone("s");//send read signature -> Figure out what kind of CPU
	__POINTW1FN _0x40000,99
	CALL SUBOPT_0x4C
; 0002 01A8    #ifdef PRINT_DEBUG
; 0002 01A9    if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400BB
; 0002 01AA    printf("\r\nTarget signature is: %02x %02x %02x",g_txBuf[2],g_txBuf[1],g_txBuf[0]);
	__POINTW1FN _0x40000,738
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _g_txBuf,2
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x40
; 0002 01AB    while(tx_counter);}
_0x400BC:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400BC
; 0002 01AC    #endif
; 0002 01AD    //AVR910 ReadSignature order is 02(3) 97(2) 1E(1) so need to reverse it
; 0002 01AE    if((tmpimage.signature[1]!=g_txBuf[1])||(tmpimage.signature[2]!=g_txBuf[0])){
_0x400BB:
	__GETB2MN _tmpimage,50
	__GETB1MN _g_txBuf,1
	CP   R30,R26
	BRNE _0x400C0
	__GETB2MN _tmpimage,51
	LDS  R30,_g_txBuf
	CP   R30,R26
	BREQ _0x400BF
_0x400C0:
; 0002 01AF        #ifdef PRINT_DEBUG
; 0002 01B0        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400C2
; 0002 01B1        printf(" target not connected\r\n");
	__POINTW1FN _0x40000,776
	CALL SUBOPT_0x22
; 0002 01B2        while(tx_counter);}
_0x400C3:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400C3
; 0002 01B3        #endif
; 0002 01B4        #ifdef PRINT_LCD
; 0002 01B5        lcd_putsf_row(1,"Wrong target");
_0x400C2:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,800
	CALL SUBOPT_0xC
; 0002 01B6        #endif
; 0002 01B7        return FALSE;
	RJMP _0x20C0020
; 0002 01B8    }
; 0002 01B9    #ifdef PRINT_DEBUG
; 0002 01BA    if(debug){
_0x400BF:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400C6
; 0002 01BB    printf("\r\nReading signature: OK.");
	__POINTW1FN _0x40000,813
	CALL SUBOPT_0x22
; 0002 01BC    while(tx_counter);}
_0x400C7:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400C7
; 0002 01BD    #endif
; 0002 01BE    #ifdef PRINT_LCD
; 0002 01BF    lcd_putsf_row(1,"Signature OK.");
_0x400C6:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,838
	CALL SUBOPT_0xC
; 0002 01C0    #endif
; 0002 01C1    AVR910_SendRxToUart();
	CALL _AVR910_SendRxToUart
; 0002 01C2    return TRUE;
	RJMP _0x20C001E
; 0002 01C3 }
; .FEND
;void Call_Erase(void)
; 0002 01C5 {
_Call_Erase:
; .FSTART _Call_Erase
; 0002 01C6    #ifdef PRINT_DEBUG
; 0002 01C7    if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400CA
; 0002 01C8    printf("\r\nErasing please wait... ");
	__POINTW1FN _0x40000,852
	CALL SUBOPT_0x22
; 0002 01C9    while(tx_counter);}
_0x400CB:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400CB
; 0002 01CA    #endif
; 0002 01CB    #ifdef PRINT_LCD
; 0002 01CC    lcd_putsf_row(1,"Erasing... ");
_0x400CA:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,878
	CALL SUBOPT_0xC
; 0002 01CD    #endif
; 0002 01CE    AVR910_Standalone("e");//chip erase
	__POINTW1FN _0x40000,432
	CALL SUBOPT_0x4C
; 0002 01CF    #ifdef PRINT_DEBUG
; 0002 01D0    if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400CE
; 0002 01D1    printf("Done.");
	__POINTW1FN _0x40000,890
	CALL SUBOPT_0x22
; 0002 01D2    while(tx_counter);}
_0x400CF:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400CF
; 0002 01D3    #endif
; 0002 01D4    #ifdef PRINT_LCD
; 0002 01D5    lcd_putsf("Done");
_0x400CE:
	__POINTW1FN _0x40000,429
	CALL SUBOPT_0x2
; 0002 01D6    #endif
; 0002 01D7    AVR910_ResetTXData();
	CALL _AVR910_ResetTXData
; 0002 01D8 }
	RET
; .FEND
;UCHAR Call_SetDevType(void)
; 0002 01DA {
_Call_SetDevType:
; .FSTART _Call_SetDevType
; 0002 01DB ////  chipcode -> PageSize in words
; 0002 01DC ////  ['T,A(0x41)'] = SetDevType();g_DeviceCode=A=0x41,g_DevicePollCode=PageSize=0x40(word),g_DeviceType = MEGA;
; 0002 01DD //   /*Set target properties from avr910device.h header*/
; 0002 01DE //   AVR910_SendRxToUart();FIFO_Write('T');FIFO_Write(tmpimage.chipcode);AVR910_Command();
; 0002 01DF ////    //AVR910_Standalone("TA");
; 0002 01E0 //   if(g_txBuf[0]!=ACK){
; 0002 01E1 //        #ifdef PRINT_DEBUG
; 0002 01E2 //        if(debug){
; 0002 01E3 //        printf("\r\nSetDevType FAIL");
; 0002 01E4 //        while(tx_counter);}
; 0002 01E5 //        #endif
; 0002 01E6 //        #ifdef PRINT_LCD
; 0002 01E7 //        lcd_putsf_row(1,"SetDevType FAIL");
; 0002 01E8 //        #endif
; 0002 01E9 //        return FALSE;
; 0002 01EA //   }
; 0002 01EB    g_DevicePollCode=tmpimage.pagesize;
	__GETB1MN _tmpimage,68
	STS  _g_DevicePollCode,R30
; 0002 01EC    //g_DeviceCode
; 0002 01ED    g_DeviceType=MEGA;
	LDI  R30,LOW(0)
	STS  _g_DeviceType,R30
; 0002 01EE    return TRUE;
	RJMP _0x20C001E
; 0002 01EF }
; .FEND
;UCHAR Call_WriteProgFuses(void)
; 0002 01F1 {
_Call_WriteProgFuses:
; .FSTART _Call_WriteProgFuses
; 0002 01F2    if (! programFuses(tmpimage.progfuses, tmpimage.maskfuses)){        // get fuses ready to program
	CALL SUBOPT_0x59
	CALL SUBOPT_0x56
	RCALL _programFuses
	CPI  R30,0
	BRNE _0x400D2
; 0002 01F3      error("\r\nProgram Fuses fail");
	__POINTW1FN _0x40000,896
	CALL SUBOPT_0x42
; 0002 01F4      #ifdef PRINT_LCD
; 0002 01F5      lcd_putsf_row(1,"Prog Fuses fail");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,917
	CALL SUBOPT_0xC
; 0002 01F6      #endif
; 0002 01F7      return FALSE;
	RJMP _0x20C0020
; 0002 01F8    }
; 0002 01F9    if (! verifyFuses(tmpimage.progfuses, tmpimage.maskfuses) ) {
_0x400D2:
	CALL SUBOPT_0x59
	CALL SUBOPT_0x56
	RCALL _verifyFuses
	CPI  R30,0
	BRNE _0x400D3
; 0002 01FA      error("\r\nFailed to verify fuses");
	__POINTW1FN _0x40000,933
	CALL SUBOPT_0x42
; 0002 01FB      #ifdef PRINT_LCD
; 0002 01FC      lcd_putsf_row(1,"Check Fuses fail");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,958
	CALL SUBOPT_0xC
; 0002 01FD      #endif
; 0002 01FE      return FALSE;
	RJMP _0x20C0020
; 0002 01FF    }
; 0002 0200    #ifdef PRINT_DEBUG
; 0002 0201    if(debug){
_0x400D3:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400D4
; 0002 0202    printf("\r\nProgram Fuses Verified OK.");
	__POINTW1FN _0x40000,975
	CALL SUBOPT_0x22
; 0002 0203    while(tx_counter);}
_0x400D5:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400D5
; 0002 0204    #endif
; 0002 0205    return TRUE;
_0x400D4:
	RJMP _0x20C001E
; 0002 0206 }
; .FEND
;UCHAR Call_WriteFlash(void)
; 0002 0208 {
_Call_WriteFlash:
; .FSTART _Call_WriteFlash
; 0002 0209 //here g_DeviceCode=chipcode, g_DevicePollCode=PageSize in words, g_DeviceType = MEGA
; 0002 020A //['A',0x10,0x00]=SetAddr(); g_Addr=0x1000;
; 0002 020B     /*Set g_Addr=0 start address for BlockMode*/
; 0002 020C     AVR910_SendRxToUart();FIFO_Write('A');FIFO_Write(0);FIFO_Write(0);AVR910_Command();
	CALL _AVR910_SendRxToUart
	LDI  R30,LOW(65)
	ST   -Y,R30
	CALL _FIFO_Write
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _FIFO_Write
	LDI  R30,LOW(0)
	CALL SUBOPT_0x5D
; 0002 020D     if(g_txBuf[0]!=ACK){
	LDS  R26,_g_txBuf
	CPI  R26,LOW(0xD)
	BREQ _0x400D8
; 0002 020E         #ifdef PRINT_DEBUG
; 0002 020F         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400D9
; 0002 0210         printf("\r\nSetAddr FAIL");
	__POINTW1FN _0x40000,1004
	CALL SUBOPT_0x22
; 0002 0211         while(tx_counter);}
_0x400DA:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400DA
; 0002 0212         #endif
; 0002 0213         return FALSE;
_0x400D9:
	RJMP _0x20C0020
; 0002 0214     }
; 0002 0215    //here g_Addr=0;
; 0002 0216     //['B',0x00,0x80,'F'] WriteBlockCommand();g_BlockMode=TRUE;g_Operation=OPERATION_WRITE;g_BlockSize=0x0080;g_WordCoun ...
; 0002 0217     AVR910_SendRxToUart();//clear uart
_0x400D8:
	CALL _AVR910_SendRxToUart
; 0002 0218   /*Set BlockMode chip size in bytes and type of memory Flash F or Eeprom E*/
; 0002 0219     FIFO_Write('B');FIFO_Write(tmpimage.chipsize>>16);FIFO_Write(tmpimage.chipsize>>8);FIFO_Write(tmpimage.chipsize&0xFF ...
	LDI  R30,LOW(66)
	ST   -Y,R30
	CALL _FIFO_Write
	CALL SUBOPT_0x47
	CALL __LSRD16
	ST   -Y,R30
	CALL _FIFO_Write
	__GETD2MN _tmpimage,64
	LDI  R30,LOW(8)
	CALL __LSRD12
	ST   -Y,R30
	CALL _FIFO_Write
	__GETB1MN _tmpimage,64
	ST   -Y,R30
	CALL _FIFO_Write
	LDI  R30,LOW(70)
	CALL SUBOPT_0x5D
; 0002 021A     //AVR910_Command();
; 0002 021B   //here should be g_BlockSize(words)=chipsize/2, g_MemType='F'=flash, g_BlockMode=TRUE, g_Operation=Write, g_WordCount= ...
; 0002 021C   //do while pageaddr in bytes less than chipsize in bytes
; 0002 021D     #ifdef PRINT_DEBUG
; 0002 021E     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400DD
; 0002 021F     while(tx_counter);
_0x400DE:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400DE
; 0002 0220     printf("\r\nWriting flash...");
	__POINTW1FN _0x40000,1019
	CALL SUBOPT_0x22
; 0002 0221     while(tx_counter);}
_0x400E1:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400E1
; 0002 0222     #endif
; 0002 0223     #ifdef PRINT_LCD
; 0002 0224     lcd_putsf_row(1,"Writing flash...");
_0x400DD:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1021
	CALL SUBOPT_0xC
; 0002 0225     //lcd_putsf_row(1,"Writing 0 %");
; 0002 0226     #endif
; 0002 0227     if(fileOpen()==0)
	CALL _fileOpen
	CPI  R30,0
	BRNE _0x400E4
; 0002 0228         return FALSE;
	RJMP _0x20C0020
; 0002 0229     #ifdef PRINT_DEBUG
; 0002 022A     if(debug){
_0x400E4:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400E5
; 0002 022B     while(tx_counter);
_0x400E6:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400E6
; 0002 022C     printf("\r\nAfter fileOpen\r\n");
	__POINTW1FN _0x40000,1038
	CALL SUBOPT_0x22
; 0002 022D     while(tx_counter);}
_0x400E9:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400E9
; 0002 022E     #endif
; 0002 022F     if(SetFlashArea()==0)
_0x400E5:
	CALL _SetFlashArea
	CPI  R30,0
	BRNE _0x400EC
; 0002 0230         return FALSE;
	RJMP _0x20C0020
; 0002 0231     #ifdef PRINT_DEBUG
; 0002 0232     if(debug){
_0x400EC:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400ED
; 0002 0233     while(tx_counter);
_0x400EE:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400EE
; 0002 0234     printf("\r\nAfter set adr 1000\r\n");
	__POINTW1FN _0x40000,1057
	CALL SUBOPT_0x22
; 0002 0235     while(tx_counter);}
_0x400F1:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400F1
; 0002 0236     #endif
; 0002 0237     if(fileRead()==0)
_0x400ED:
	CALL _fileRead
	CPI  R30,0
	BRNE _0x400F4
; 0002 0238         return FALSE;
	RJMP _0x20C0020
; 0002 0239     while (pageaddr < tmpimage.chipsize) {
_0x400F4:
_0x400F5:
	CALL SUBOPT_0x47
	CALL SUBOPT_0x5E
	CALL __CPD21
	BRLO PC+2
	RJMP _0x400F7
; 0002 023A      //puts("\r\nBuffering page "); puthexchars(pageaddr);
; 0002 023B  //hextextpos = readImagePage (hextext, pageaddr, pagesize, pageBuffer);
; 0002 023C 
; 0002 023D      if(readImagePageSD (pageaddr, tmpimage.pagesize, pageBuffer)==0){
	LDS  R30,_pageaddr
	LDS  R31,_pageaddr+1
	LDS  R22,_pageaddr+2
	LDS  R23,_pageaddr+3
	CALL __PUTPARD1
	CALL SUBOPT_0x5F
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_pageBuffer)
	LDI  R31,HIGH(_pageBuffer)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _readImagePageSD
	CPI  R30,0
	BRNE _0x400F8
; 0002 023E        #ifdef PRINT_DEBUG
; 0002 023F        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400F9
; 0002 0240        printf("\r\nFlash programming failed");
	__POINTW1FN _0x40000,1080
	CALL SUBOPT_0x22
; 0002 0241        while(tx_counter);}
_0x400FA:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x400FA
; 0002 0242        #endif
; 0002 0243        #ifndef BOOTEEPROM
; 0002 0244        fileClose();
_0x400F9:
	RJMP _0x20C001F
; 0002 0245        #endif
; 0002 0246        return FALSE;
; 0002 0247      }
; 0002 0248      #ifdef DEBUG_PROTEUS
; 0002 0249         #ifdef PRINT_DEBUG
; 0002 024A         if(debug){
; 0002 024B         while(tx_counter);
; 0002 024C         printf("\r\nPage addr=%ul",pageaddr);
; 0002 024D         while(tx_counter);}
; 0002 024E         #endif
; 0002 024F      #endif
; 0002 0250      if (FALSE == blankpage) {//if there data to write the all page buffer to flash
_0x400F8:
	SBIC 0x1E,3
	RJMP _0x400FD
; 0002 0251             if (! flashPage(pageBuffer, tmpimage.pagesize)){//
	LDI  R30,LOW(_pageBuffer)
	LDI  R31,HIGH(_pageBuffer)
	CALL SUBOPT_0x49
	ST   -Y,R31
	ST   -Y,R30
	RCALL _flashPage
	CPI  R30,0
	BRNE _0x400FE
; 0002 0252                 #ifdef PRINT_DEBUG
; 0002 0253                 if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x400FF
; 0002 0254                 printf("\r\nFlash programming failed");
	__POINTW1FN _0x40000,1080
	CALL SUBOPT_0x22
; 0002 0255                 while(tx_counter);}
_0x40100:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40100
; 0002 0256                 #endif
; 0002 0257                 #ifndef BOOTEEPROM
; 0002 0258                 fileClose();
_0x400FF:
_0x20C001F:
	CALL _fileClose
; 0002 0259                 #endif
; 0002 025A                 return FALSE;
_0x20C0020:
	LDI  R30,LOW(0)
	RET
; 0002 025B        }
; 0002 025C      }
_0x400FE:
; 0002 025D      else{//if no data to write, just increment the address in words by pagesize in words, and decrement remain g_BlockS ...
	RJMP _0x40103
_0x400FD:
; 0002 025E         g_Addr = (pageaddr+tmpimage.pagesize)/2;
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x5E
	CLR  R22
	CLR  R23
	CALL __ADDD21
	MOVW R30,R26
	MOVW R22,R24
	CALL __LSRD1
	STS  _g_Addr,R30
	STS  _g_Addr+1,R31
; 0002 025F         g_BlockSize-=(tmpimage.pagesize/2);
	CALL SUBOPT_0x5F
	LSR  R31
	ROR  R30
	LDS  R26,_g_BlockSize
	LDS  R27,_g_BlockSize+1
	LDS  R24,_g_BlockSize+2
	LDS  R25,_g_BlockSize+3
	CLR  R22
	CLR  R23
	CALL __SUBD21
	STS  _g_BlockSize,R26
	STS  _g_BlockSize+1,R27
	STS  _g_BlockSize+2,R24
	STS  _g_BlockSize+3,R25
; 0002 0260      }
_0x40103:
; 0002 0261      if(EndOfFile)
	SBIC 0x1E,2
; 0002 0262         break;
	RJMP _0x400F7
; 0002 0263      pageaddr += tmpimage.pagesize;//increment the address in bytes by pagesize in bytes
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x5E
	CALL SUBOPT_0x60
	STS  _pageaddr,R30
	STS  _pageaddr+1,R31
	STS  _pageaddr+2,R22
	STS  _pageaddr+3,R23
; 0002 0264 
; 0002 0265 //     #ifdef PRINT_LCD
; 0002 0266 //     lcd_gotoxy(8,1);
; 0002 0267 //     itoa((int)((float)((float)pageaddr/(float)tmpimage.chipsize)*100),&temptext[0]);
; 0002 0268 //     //strcatf(temptext,"%");
; 0002 0269 //     lcd_puts(temptext);
; 0002 026A //     #endif
; 0002 026B     }
	RJMP _0x400F5
_0x400F7:
; 0002 026C     #ifdef PRINT_DEBUG
; 0002 026D     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40105
; 0002 026E     printf(" Done.");
	__POINTW1FN _0x40000,1107
	CALL SUBOPT_0x22
; 0002 026F     while(tx_counter);}
_0x40106:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40106
; 0002 0270     #endif
; 0002 0271     #ifndef BOOTEEPROM
; 0002 0272     fileClose();
_0x40105:
	CALL _fileClose
; 0002 0273     #endif
; 0002 0274     return TRUE;
_0x20C001E:
	LDI  R30,LOW(1)
	RET
; 0002 0275 }
; .FEND
;UCHAR Call_ResetChip(void)
; 0002 0277 {
_Call_ResetChip:
; .FSTART _Call_ResetChip
; 0002 0278    AVR910_ResetTXData();
	CALL _AVR910_ResetTXData
; 0002 0279    AVR910_Standalone("L");//end_pmode();
	__POINTW1FN _0x40000,412
	CALL SUBOPT_0x4C
; 0002 027A    return Call_EnterProgMode();
	RCALL _Call_EnterProgMode
	RET
; 0002 027B }
; .FEND
;/*Main function for standalone AVR ISP proccess*/
;void StandalonProg(void)
; 0002 027E {
_StandalonProg:
; .FSTART _StandalonProg
; 0002 027F     //char tmpstr[3];
; 0002 0280     StandaloneMode=RUNNING;
	LDI  R30,LOW(3)
	STS  _StandaloneMode,R30
; 0002 0281     #ifdef PRINT_DEBUG
; 0002 0282     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40109
; 0002 0283     printf("\r\nStart flashing from SDcard...\r\n");
	__POINTW1FN _0x40000,1114
	CALL SUBOPT_0x22
; 0002 0284     while(tx_counter);}
_0x4010A:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4010A
; 0002 0285     #endif
; 0002 0286     LED_PASS_OFF();
_0x40109:
	SBI  0x5,1
; 0002 0287     //if(Call_GetDir()==FALSE)
; 0002 0288     //     goto end_prog;
; 0002 0289     if(tmpimage.ProgCounterTotal<=myimage[dirnum].ProgCounterDone){
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
	__GETW2MN _tmpimage,72
	CALL SUBOPT_0x61
	BRLO _0x4010F
; 0002 028A         #ifdef PRINT_DEBUG
; 0002 028B         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40110
; 0002 028C         printf("\r\nLicenses Total = %lu - Done = %lu",tmpimage.ProgCounterTotal,myimage[dirnum].ProgCounterDone);
	__POINTW1FN _0x40000,1148
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x1C
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
	CALL SUBOPT_0x62
; 0002 028D         while(tx_counter);}
_0x40111:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40111
; 0002 028E         #endif
; 0002 028F         #ifdef PRINT_LCD
; 0002 0290         lcd_putsf_row(1,"No licenses");
_0x40110:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1184
	CALL SUBOPT_0xC
; 0002 0291         #endif
; 0002 0292         goto end_prog;
	RJMP _0x40114
; 0002 0293     }
; 0002 0294     /*Reset flash programminig global variables*/
; 0002 0295     ResetGlobals();
_0x4010F:
	RCALL _ResetGlobals
; 0002 0296     #ifndef DEBUG_PROTEUS
; 0002 0297     if(Call_EnterProgMode()==FALSE)
	RCALL _Call_EnterProgMode
	CPI  R30,0
	BRNE _0x40115
; 0002 0298        goto end_prog;
	RJMP _0x40114
; 0002 0299     if(Call_ReadSignature()==FALSE)
_0x40115:
	RCALL _Call_ReadSignature
	CPI  R30,0
	BRNE _0x40116
; 0002 029A        goto end_prog;
	RJMP _0x40114
; 0002 029B     Call_Erase();
_0x40116:
	RCALL _Call_Erase
; 0002 029C     if(Call_WriteProgFuses()==FALSE)
	RCALL _Call_WriteProgFuses
	CPI  R30,0
	BRNE _0x40117
; 0002 029D        goto end_prog;
	RJMP _0x40114
; 0002 029E     if(Call_ResetChip()==FALSE)
_0x40117:
	RCALL _Call_ResetChip
	CPI  R30,0
	BRNE _0x40118
; 0002 029F        goto end_prog;
	RJMP _0x40114
; 0002 02A0     #endif
; 0002 02A1     if(Call_SetDevType()==FALSE)
_0x40118:
	RCALL _Call_SetDevType
	CPI  R30,0
	BRNE _0x40119
; 0002 02A2        goto end_prog;
	RJMP _0x40114
; 0002 02A3     if(Call_WriteFlash()==FALSE)
_0x40119:
	RCALL _Call_WriteFlash
	CPI  R30,0
	BRNE _0x4011A
; 0002 02A4        goto end_prog;
	RJMP _0x40114
; 0002 02A5 
; 0002 02A6 verify:
_0x4011A:
_0x4011B:
; 0002 02A7     ResetGlobals();
	RCALL _ResetGlobals
; 0002 02A8     if(Call_ResetChip()==FALSE)
	RCALL _Call_ResetChip
	CPI  R30,0
	BRNE _0x4011C
; 0002 02A9        goto end_prog;
	RJMP _0x40114
; 0002 02AA     #ifdef PRINT_DEBUG
; 0002 02AB     if(debug){
_0x4011C:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4011D
; 0002 02AC     printf("\r\nVerifing flash...");
	__POINTW1FN _0x40000,1196
	CALL SUBOPT_0x22
; 0002 02AD     while(tx_counter);}
_0x4011E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4011E
; 0002 02AE     #endif
; 0002 02AF     #ifndef BOOTEEPROM
; 0002 02B0     if(fileOpen()==0)//sdcard version
_0x4011D:
	CALL _fileOpen
	CPI  R30,0
	BRNE _0x40121
; 0002 02B1         goto end_prog;
	RJMP _0x40114
; 0002 02B2     if(SetFlashArea()==0)
_0x40121:
	CALL _SetFlashArea
	CPI  R30,0
	BRNE _0x40122
; 0002 02B3         goto end_prog;
	RJMP _0x40114
; 0002 02B4     if(fileRead()==0)
_0x40122:
	CALL _fileRead
	CPI  R30,0
	BRNE _0x40123
; 0002 02B5         goto end_prog;
	RJMP _0x40114
; 0002 02B6     #else
; 0002 02B7     hextext=(flash UCHAR *)myimage.FlashStartAddrByte; //boot flash from eeprom version
; 0002 02B8     #endif
; 0002 02B9     if (! verifyImageSD() ) {
_0x40123:
	RCALL _verifyImageSD
	CPI  R30,0
	BRNE _0x40124
; 0002 02BA         error("\r\nFailed to verify chip");
	__POINTW1FN _0x40000,1216
	CALL SUBOPT_0x42
; 0002 02BB     #ifndef BOOTEEPROM
; 0002 02BC         fileClose();
	CALL _fileClose
; 0002 02BD     #endif
; 0002 02BE         if((tmpimage.spidiv<<=1)!=0)
	__GETB1MN _tmpimage,93
	LSL  R30
	__PUTB1MN _tmpimage,93
	CPI  R30,0
	BRNE _0x4011B
; 0002 02BF             goto verify;
; 0002 02C0         #ifdef PRINT_LCD
; 0002 02C1         lcd_putsf_row(1,"Failed to verify");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1240
	CALL SUBOPT_0xC
; 0002 02C2         #endif
; 0002 02C3         goto end_prog;
	RJMP _0x40114
; 0002 02C4     } else {
_0x40124:
; 0002 02C5     #ifdef PRINT_DEBUG
; 0002 02C6     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40127
; 0002 02C7     printf("Done.\r\nFlash verified correctly !!!");
	__POINTW1FN _0x40000,1257
	CALL SUBOPT_0x22
; 0002 02C8     while(tx_counter);}
_0x40128:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40128
; 0002 02C9     #endif
; 0002 02CA     #ifndef BOOTEEPROM
; 0002 02CB     fileClose();
_0x40127:
	CALL _fileClose
; 0002 02CC     #endif
; 0002 02CD     }
; 0002 02CE     // Set fuses to 'final' state
; 0002 02CF     if (! programFuses(tmpimage.normfuses, tmpimage.maskfuses)){
	CALL SUBOPT_0x58
	CALL SUBOPT_0x56
	RCALL _programFuses
	CPI  R30,0
	BRNE _0x4012B
; 0002 02D0         error("\r\nNormal Fuses fail");
	__POINTW1FN _0x40000,1293
	CALL SUBOPT_0x42
; 0002 02D1         goto end_prog;
	RJMP _0x40114
; 0002 02D2     }
; 0002 02D3     #ifdef PRINT_DEBUG
; 0002 02D4     if(debug){
_0x4012B:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4012C
; 0002 02D5     printf("\r\nNormal fuses writing done.");
	__POINTW1FN _0x40000,1313
	CALL SUBOPT_0x22
; 0002 02D6     while(tx_counter);}
_0x4012D:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4012D
; 0002 02D7     #endif
; 0002 02D8     if(Call_ResetChip()==FALSE)
_0x4012C:
	RCALL _Call_ResetChip
	CPI  R30,0
	BREQ _0x40114
; 0002 02D9        goto end_prog;
; 0002 02DA     if (! verifyFuses(tmpimage.normfuses, tmpimage.maskfuses) ) {
	CALL SUBOPT_0x58
	CALL SUBOPT_0x56
	RCALL _verifyFuses
	CPI  R30,0
	BRNE _0x40131
; 0002 02DB         error("\r\nFailed to verify fuses");
	__POINTW1FN _0x40000,933
	CALL SUBOPT_0x42
; 0002 02DC         goto end_prog;
	RJMP _0x40114
; 0002 02DD     }
; 0002 02DE     #ifdef PRINT_DEBUG
; 0002 02DF     if(debug){
_0x40131:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40132
; 0002 02E0     printf("\r\nNormal fuses verified correctly !!!");
	__POINTW1FN _0x40000,1342
	CALL SUBOPT_0x22
; 0002 02E1     while(tx_counter);}
_0x40133:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40133
; 0002 02E2     #endif
; 0002 02E3     StandaloneMode=PASS;
_0x40132:
	LDI  R30,LOW(1)
	STS  _StandaloneMode,R30
; 0002 02E4     LED_PASS_ON();
	CBI  0x5,1
; 0002 02E5 end_prog:
_0x40114:
; 0002 02E6     AVR910_ResetTXData();
	CALL _AVR910_ResetTXData
; 0002 02E7     #ifdef PRINT_DEBUG
; 0002 02E8     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40138
; 0002 02E9     printf("\r\nLeaving programming mode... ");
	__POINTW1FN _0x40000,1380
	CALL SUBOPT_0x22
; 0002 02EA     while(tx_counter);}
_0x40139:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40139
; 0002 02EB     #endif
; 0002 02EC     AVR910_Standalone("L");
_0x40138:
	__POINTW1FN _0x40000,412
	CALL SUBOPT_0x4C
; 0002 02ED     #ifdef PRINT_DEBUG
; 0002 02EE     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4013C
; 0002 02EF     printf(" OK.\n");
	__POINTW1FN _0x40000,1411
	CALL SUBOPT_0x22
; 0002 02F0     while(tx_counter);}
_0x4013D:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4013D
; 0002 02F1     #endif
; 0002 02F2     tmpimage.ProgCounterDone = myimage[dirnum].ProgCounterDone;
_0x4013C:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x53
; 0002 02F3     if(StandaloneMode!=PASS){
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x1)
	BREQ _0x40140
; 0002 02F4         if(StandaloneMode!=SDFAIL){
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BREQ _0x40141
; 0002 02F5             StandaloneMode=FAIL;
	LDI  R30,LOW(2)
	STS  _StandaloneMode,R30
; 0002 02F6             #ifdef PRINT_LCD
; 0002 02F7             delay_ms(2000);
	CALL SUBOPT_0x3
; 0002 02F8             lcd_putsf_row(1,"Failed.");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1417
	CALL SUBOPT_0xC
; 0002 02F9             #endif
; 0002 02FA         }
; 0002 02FB         #ifdef PRINT_DEBUG
; 0002 02FC         if(debug){
_0x40141:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40142
; 0002 02FD         if(StandaloneMode!=SDFAIL)
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BREQ _0x40143
; 0002 02FE             printf("\r\nFlashing from sdcard Failed .\r\n",tmpimage.ProgCounterDone);
	__POINTW1FN _0x40000,1425
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x1B
	CALL SUBOPT_0x41
; 0002 02FF         else{
	RJMP _0x40144
_0x40143:
; 0002 0300             printf("\r\nSDCARD Failed .\r\n",);
	__POINTW1FN _0x40000,1459
	CALL SUBOPT_0x22
; 0002 0301             if(value==NULL)
	LDS  R30,_value
	LDS  R31,_value+1
	SBIW R30,0
	BRNE _0x40145
; 0002 0302                 printf("project.txt file missing or corrupted.\r\n");
	__POINTW1FN _0x40000,1479
	CALL SUBOPT_0x22
; 0002 0303         }
_0x40145:
_0x40144:
; 0002 0304         while(tx_counter);}
_0x40146:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40146
; 0002 0305         #endif
; 0002 0306 
; 0002 0307     }
_0x40142:
; 0002 0308     else{
	RJMP _0x40149
_0x40140:
; 0002 0309         tmpimage.ProgCounterDone=++myimage[dirnum].ProgCounterDone;
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
	CALL SUBOPT_0x63
	CALL __EEPROMWRD
	__PUTW1MN _tmpimage,70
; 0002 030A         #ifdef PRINT_DEBUG
; 0002 030B         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4014A
; 0002 030C         printf("\r\nFlashing from sdcard Passed %u.\r\n",tmpimage.ProgCounterDone);
	__POINTW1FN _0x40000,1520
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x1B
	CALL SUBOPT_0x41
; 0002 030D         while(tx_counter);}
_0x4014B:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4014B
; 0002 030E         #endif
; 0002 030F         #ifdef PRINT_LCD
; 0002 0310         lcd_putsf_row(1,"Success!  ");
_0x4014A:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1556
	CALL SUBOPT_0xC
; 0002 0311         itoa(tmpimage.ProgCounterDone,temptext);
	__GETW1MN _tmpimage,70
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_temptext)
	LDI  R31,HIGH(_temptext)
	ST   -Y,R31
	ST   -Y,R30
	CALL _itoa
; 0002 0312         lcd_puts(temptext);
	LDI  R30,LOW(_temptext)
	LDI  R31,HIGH(_temptext)
	CALL SUBOPT_0x1D
; 0002 0313         #endif
; 0002 0314         Beeps(1,1);
	CALL SUBOPT_0x12
; 0002 0315     }
_0x40149:
; 0002 0316 }
	RET
; .FEND
;
;/*
; * readImagePage SDcard
; *
; * Read a page of intel hex image from a string in pgm memory.
;*/
;
;// Returns number of bytes decoded
;UCHAR readImagePageSD (ULONG pageaddr, UINT pagesize, UCHAR *page)
; 0002 0320 {
_readImagePageSD:
; .FSTART _readImagePageSD
; 0002 0321   UINT i;
; 0002 0322   //BOOL firstline = TRUE;
; 0002 0323   UINT page_idx = 0;
; 0002 0324   //byte *beginning = hextext;
; 0002 0325   ULONG lineaddr;
; 0002 0326   UCHAR b, cksum = 0;
; 0002 0327   UCHAR len;
; 0002 0328 
; 0002 0329   //Serial.print("page size = "); Serial.println(pagesize, DEC);
; 0002 032A   if(blankpage==FALSE){
	SBIW R28,5
	CALL __SAVELOCR6
;	pageaddr -> Y+15
;	pagesize -> Y+13
;	*page -> Y+11
;	i -> R16,R17
;	page_idx -> R18,R19
;	lineaddr -> Y+7
;	b -> R21
;	cksum -> R20
;	len -> Y+6
	__GETWRN 18,19,0
	LDI  R20,0
	SBIC 0x1E,3
	RJMP _0x4014E
; 0002 032B       // 'empty' the page by filling it with 0xFF's
; 0002 032C       for (i=0; i<pagesize; i++)
	__GETWRN 16,17,0
_0x40150:
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	CP   R16,R30
	CPC  R17,R31
	BRSH _0x40151
; 0002 032D         page[i] = 0xFF;
	MOVW R30,R16
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ADD  R26,R30
	ADC  R27,R31
	LDI  R30,LOW(255)
	ST   X,R30
	__ADDWRN 16,17,1
	RJMP _0x40150
_0x40151:
; 0002 032E blankpage=TRUE;
	SBI  0x1E,3
; 0002 032F   }
; 0002 0330   while (1) {
_0x4014E:
_0x40154:
; 0002 0331     if(CanContinueRead==0){
	SBIC 0x1E,1
	RJMP _0x40157
; 0002 0332               // read one line!
; 0002 0333         if (hextext_read_byte() != ':') {
	RCALL _hextext_read_byte
	CPI  R30,LOW(0x3A)
	BREQ _0x40158
; 0002 0334           //error("No colon?");
; 0002 0335            return 0;//break;
	RJMP _0x20C001C
; 0002 0336 
; 0002 0337         }
; 0002 0338         // Read the byte count into 'len'
; 0002 0339         len = hexton(hextext_read_byte());
_0x40158:
	CALL SUBOPT_0x64
	STD  Y+6,R30
; 0002 033A         len = (len<<4) + hexton(hextext_read_byte());
	SWAP R30
	ANDI R30,0xF0
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	STD  Y+6,R30
; 0002 033B         cksum = len;
	LDD  R20,Y+6
; 0002 033C 
; 0002 033D         // read high address byte
; 0002 033E         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 033F         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x66
; 0002 0340         cksum += b;
; 0002 0341         lineaddr = b;
	CLR  R31
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x67
; 0002 0342 
; 0002 0343         // read low address byte
; 0002 0344         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 0345         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R21,R30
; 0002 0346         cksum += b;
	ADD  R20,R21
; 0002 0347         lineaddr = (lineaddr << 8) + b;
	CALL SUBOPT_0x68
	LDI  R30,LOW(8)
	CALL __LSLD12
	MOVW R26,R30
	MOVW R24,R22
	MOV  R30,R21
	LDI  R31,0
	CALL SUBOPT_0x69
	CALL SUBOPT_0x67
; 0002 0348         lineaddr+=OffsetX16;//ADD OFFSET *16
	CALL SUBOPT_0x6A
	CALL SUBOPT_0x68
	CALL __ADDD12
	CALL SUBOPT_0x67
; 0002 0349         // example lineaddr=0xFC00 pageaddr=0 pagesize=128 -> (blankpage=true) next time pageaddr=pageaddr+pagesize
; 0002 034A         if (lineaddr >= (pageaddr + pagesize)) {
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	__GETD2S 15
	CALL SUBOPT_0x60
	CALL SUBOPT_0x68
	CALL __CPD21
	BRLO _0x40159
; 0002 034B           return 1;//break;
	LDI  R30,LOW(1)
	RJMP _0x20C001D
; 0002 034C         }
; 0002 034D 
; 0002 034E         b = hexton(hextext_read_byte()); // record type
_0x40159:
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 034F         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R21,R30
; 0002 0350         cksum += b;
	ADD  R20,R21
; 0002 0351         //Serial.print("Record type "); Serial.println(b, HEX);
; 0002 0352         if (b == 0x1) {
	CPI  R21,1
	BRNE _0x4015A
; 0002 0353              EndOfFile=1;
	SBI  0x1E,2
; 0002 0354              // end record!
; 0002 0355              return 1;//break;
	LDI  R30,LOW(1)
	RJMP _0x20C001D
; 0002 0356         }
; 0002 0357         // offset *16 record!
; 0002 0358         else if (b == 0x2) {
_0x4015A:
	CPI  R21,2
	BRNE _0x4015E
; 0002 0359              b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 035A              b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x66
; 0002 035B              cksum += b;
; 0002 035C              OffsetX16=((ULONG)b<<12);
	CALL SUBOPT_0x6B
	CALL SUBOPT_0x6C
; 0002 035D              b = hexton(hextext_read_byte());
	CALL SUBOPT_0x65
; 0002 035E              b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x66
; 0002 035F              cksum += b;
; 0002 0360              OffsetX16|=((ULONG)b<<4);
	CALL SUBOPT_0x6B
	CALL SUBOPT_0x6D
; 0002 0361             b = hexton(hextext_read_byte());  // chxsum
	CALL SUBOPT_0x65
; 0002 0362             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x6E
; 0002 0363             cksum += b;
; 0002 0364             if (cksum != 0) {
	BREQ _0x4015F
; 0002 0365               error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 0366               return 0;
	RJMP _0x20C001C
; 0002 0367               //Serial.print(cksum, HEX);
; 0002 0368             }
; 0002 0369             if (hextext_read_byte() != '\r') {
_0x4015F:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x40160
; 0002 036A               error("No end of line");
	CALL SUBOPT_0x70
; 0002 036B               return 0;//break;
	RJMP _0x20C001C
; 0002 036C             }
; 0002 036D             if (hextext_read_byte() != '\n') {
_0x40160:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x40161
; 0002 036E               error("No end of line");
	CALL SUBOPT_0x70
; 0002 036F               return 0;//break;
	RJMP _0x20C001C
; 0002 0370             }
; 0002 0371             continue;
_0x40161:
	RJMP _0x40154
; 0002 0372         } //no need to stuff
; 0002 0373         else if (b == 0x3) {
_0x4015E:
	CPI  R21,3
	BRNE _0x40163
; 0002 0374             b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 0375             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x71
; 0002 0376             cksum += b;
; 0002 0377             b = hexton(hextext_read_byte());
	CALL SUBOPT_0x65
; 0002 0378             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x71
; 0002 0379             cksum += b;
; 0002 037A             b = hexton(hextext_read_byte());
	CALL SUBOPT_0x65
; 0002 037B             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x71
; 0002 037C             cksum += b;
; 0002 037D             b = hexton(hextext_read_byte());
	CALL SUBOPT_0x65
; 0002 037E             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x71
; 0002 037F             cksum += b;
; 0002 0380             b = hexton(hextext_read_byte());  // chxsum
	CALL SUBOPT_0x65
; 0002 0381             b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x6E
; 0002 0382             cksum += b;
; 0002 0383             if (cksum != 0) {
	BREQ _0x40164
; 0002 0384                 error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 0385                 return 0;//break;
	RJMP _0x20C001C
; 0002 0386             //Serial.print(cksum, HEX);
; 0002 0387             }
; 0002 0388             if (hextext_read_byte() != '\r') {
_0x40164:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x40165
; 0002 0389               error("No end of line");
	CALL SUBOPT_0x70
; 0002 038A               return 0;//break;
	RJMP _0x20C001C
; 0002 038B             }
; 0002 038C             if (hextext_read_byte() != '\n') {
_0x40165:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x40166
; 0002 038D               error("No end of line");
	CALL SUBOPT_0x70
; 0002 038E               return 0;//break;
	RJMP _0x20C001C
; 0002 038F             }
; 0002 0390             continue;
_0x40166:
	RJMP _0x40154
; 0002 0391         }
; 0002 0392         i=0;
_0x40163:
	__GETWRN 16,17,0
; 0002 0393     }
; 0002 0394     else{
	RJMP _0x40167
_0x40157:
; 0002 0395         //lineaddr=Save_lineaddr;
; 0002 0396         i=Save_i;
	LDS  R16,_Save_i
	CLR  R17
; 0002 0397         cksum=Save_cksum;
	LDS  R20,_Save_cksum
; 0002 0398         len=Save_len;
	LDS  R30,_Save_len
	STD  Y+6,R30
; 0002 0399         CanContinueRead=0;
	CBI  0x1E,1
; 0002 039A     }
_0x40167:
; 0002 039B //#if VERBOSE
; 0002 039C //    Serial.print("\nLine address =  0x"); Serial.println(lineaddr, HEX);
; 0002 039D //    Serial.print("Page address =  0x"); Serial.println(pageaddr, HEX);
; 0002 039E //#endif
; 0002 039F     blankpage=FALSE;
	CBI  0x1E,3
; 0002 03A0     for ( ; i < len; i++) {
_0x4016D:
	LDD  R30,Y+6
	MOVW R26,R16
	LDI  R31,0
	CP   R26,R30
	CPC  R27,R31
	BRSH _0x4016E
; 0002 03A1       // read 'n' bytes
; 0002 03A2       b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 03A3       b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R21,R30
; 0002 03A4 
; 0002 03A5       cksum += b;
	ADD  R20,R21
; 0002 03A6 //#if VERBOSE
; 0002 03A7 //      Serial.print(b, HEX);
; 0002 03A8 //      Serial.write(' ');
; 0002 03A9 //#endif
; 0002 03AA 
; 0002 03AB       page[page_idx] = b;
	MOVW R30,R18
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ADD  R30,R26
	ADC  R31,R27
	ST   Z,R21
; 0002 03AC       page_idx++;
	__ADDWRN 18,19,1
; 0002 03AD 
; 0002 03AE       if (page_idx > (pagesize-1)) {
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	SBIW R30,1
	CP   R30,R18
	CPC  R31,R19
	BRSH _0x4016F
; 0002 03AF           CanContinueRead=1;
	SBI  0x1E,1
; 0002 03B0           //Save_lineaddr=lineaddr;
; 0002 03B1           Save_i=i+1;
	MOV  R30,R16
	SUBI R30,-LOW(1)
	STS  _Save_i,R30
; 0002 03B2           Save_cksum=cksum;
	STS  _Save_cksum,R20
; 0002 03B3           Save_len=len;
	LDD  R30,Y+6
	STS  _Save_len,R30
; 0002 03B4           //error("Too much code");
; 0002 03B5           return 1;//break;
	LDI  R30,LOW(1)
	RJMP _0x20C001D
; 0002 03B6       }
; 0002 03B7     }
_0x4016F:
	__ADDWRN 16,17,1
	RJMP _0x4016D
_0x4016E:
; 0002 03B8     if(CanContinueRead)
	SBIS 0x1E,1
	RJMP _0x40172
; 0002 03B9         return 1;//break;
	LDI  R30,LOW(1)
	RJMP _0x20C001D
; 0002 03BA     b = hexton(hextext_read_byte());  // chxsum
_0x40172:
	CALL SUBOPT_0x64
	CALL SUBOPT_0x65
; 0002 03BB     b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x6E
; 0002 03BC     cksum += b;
; 0002 03BD     if (cksum != 0) {
	BREQ _0x40173
; 0002 03BE       error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 03BF       return 0;//break;
	RJMP _0x20C001C
; 0002 03C0       //Serial.print(cksum, HEX);
; 0002 03C1     }
; 0002 03C2     if (hextext_read_byte() != '\r') {
_0x40173:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x40174
; 0002 03C3               error("No end of line");
	CALL SUBOPT_0x70
; 0002 03C4               return 0;//break;
	RJMP _0x20C001C
; 0002 03C5     }
; 0002 03C6     if (hextext_read_byte() != '\n') {
_0x40174:
	RCALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x40175
; 0002 03C7       error("No end of line");
	CALL SUBOPT_0x70
; 0002 03C8       return 0;//break;
	RJMP _0x20C001C
; 0002 03C9     }
; 0002 03CA //#if VERBOSE
; 0002 03CB //    Serial.println();
; 0002 03CC //    Serial.println(page_idx, DEC);
; 0002 03CD //#endif
; 0002 03CE     if (page_idx == pagesize)
_0x40175:
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	CP   R30,R18
	CPC  R31,R19
	BREQ _0x20C001C
; 0002 03CF       return 0;//break;
; 0002 03D0     }
	RJMP _0x40154
; 0002 03D1 //#if VERBOSE
; 0002 03D2 //  Serial.print("\n  Total bytes read: ");
; 0002 03D3 //  Serial.println(page_idx, DEC);
; 0002 03D4 //#endif
; 0002 03D5   return 0;//return hextext;
_0x20C001C:
	LDI  R30,LOW(0)
_0x20C001D:
	CALL __LOADLOCR6
	ADIW R28,19
	RET
; 0002 03D6 }
; .FEND
;
;
;// Basically, write the pagebuff (with pagesize bytes in it) into page $pageaddr
;UCHAR flashPage (UCHAR *pagebuff, UINT pagesize) {
; 0002 03DA UCHAR flashPage (UCHAR *pagebuff, UINT pagesize) {
_flashPage:
; .FSTART _flashPage
; 0002 03DB   //SPI.setClockDivider(CLOCKSPEED_FLASH);
; 0002 03DC   UINT i;
; 0002 03DD   //printf("\r\nFlashing page %u",pageaddr);
; 0002 03DE   for (i=0; i < pagesize/2; i++) {
	ST   -Y,R17
	ST   -Y,R16
;	*pagebuff -> Y+4
;	pagesize -> Y+2
;	i -> R16,R17
	__GETWRN 16,17,0
_0x40178:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	LSR  R31
	ROR  R30
	CP   R16,R30
	CPC  R17,R31
	BRSH _0x40179
; 0002 03DF     AVR910_ResetTXData();//clear send to uart tx buffer
	CALL _AVR910_ResetTXData
; 0002 03E0     FIFO_Write(pagebuff[2*i]);
	__MULBNWRU 16,17,2
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADD  R26,R30
	ADC  R27,R31
	LD   R30,X
	ST   -Y,R30
	CALL _FIFO_Write
; 0002 03E1     FIFO_Write(pagebuff[2*i+1]);
	__MULBNWRU 16,17,2
	ADIW R30,1
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADD  R26,R30
	ADC  R27,R31
	LD   R30,X
	CALL SUBOPT_0x5D
; 0002 03E2     AVR910_Command();
; 0002 03E3   }
	__ADDWRN 16,17,1
	RJMP _0x40178
_0x40179:
; 0002 03E4   return TRUE;
	LDI  R30,LOW(1)
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,6
	RET
; 0002 03E5 }
; .FEND
;
;// verifyImage SDcard does a byte-by-byte verify of the flash hex against the chip
;// Thankfully this does not have to be done by pages!
;// returns true if the image is the same as the hextext, returns false on any error
;UCHAR verifyImageSD ()  {
; 0002 03EA UCHAR verifyImageSD ()  {
_verifyImageSD:
; .FSTART _verifyImageSD
; 0002 03EB   ULONG lineaddr;
; 0002 03EC   UCHAR len;
; 0002 03ED   UCHAR b, cksum = 0;
; 0002 03EE   UCHAR i;
; 0002 03EF   #ifdef PRINT_LCD
; 0002 03F0   lcd_putsf_row(1,"Verifing flash..");
	SBIW R28,4
	CALL __SAVELOCR4
;	lineaddr -> Y+4
;	len -> R17
;	b -> R16
;	cksum -> R19
;	i -> R18
	LDI  R19,0
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1597
	CALL SUBOPT_0xC
; 0002 03F1   //lcd_putsf_row(1,"Verifing 0 %");
; 0002 03F2   #endif
; 0002 03F3   while (1) {
_0x4017A:
; 0002 03F4 //    #ifdef PRINT_LCD
; 0002 03F5 //    lcd_gotoxy(9,1);
; 0002 03F6 //    itoa((int)((float)((float)lineaddr/(float)tmpimage.chipsize)*100),&temptext[0]);
; 0002 03F7 //    lcd_puts(temptext);
; 0002 03F8 //    #endif
; 0002 03F9       // read one line!
; 0002 03FA     if (hextext_read_byte() != ':') {
	RCALL _hextext_read_byte
	CPI  R30,LOW(0x3A)
	BREQ _0x4017D
; 0002 03FB       error("No colon");
	__POINTW1FN _0x40000,1614
	CALL SUBOPT_0x42
; 0002 03FC       return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 03FD     }
; 0002 03FE     len = hexton(hextext_read_byte());
_0x4017D:
	CALL SUBOPT_0x64
	MOV  R17,R30
; 0002 03FF     len = (len<<4) + hexton(hextext_read_byte());
	SWAP R30
	ANDI R30,0xF0
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R17,R30
; 0002 0400     cksum = len;
	MOV  R19,R17
; 0002 0401 
; 0002 0402     b = hexton(hextext_read_byte()); // record type
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0403     b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x73
; 0002 0404     cksum += b;
; 0002 0405     lineaddr = b;
	CLR  R31
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x74
; 0002 0406     b = hexton(hextext_read_byte()); // record type
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0407     b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R16,R30
; 0002 0408     cksum += b;
	ADD  R19,R16
; 0002 0409     lineaddr = (lineaddr << 8) + b;
	CALL SUBOPT_0x75
	LDI  R30,LOW(8)
	CALL __LSLD12
	MOVW R26,R30
	MOVW R24,R22
	MOV  R30,R16
	LDI  R31,0
	CALL SUBOPT_0x69
	CALL SUBOPT_0x74
; 0002 040A     lineaddr+=OffsetX16;//ADD OFFSET *16
	CALL SUBOPT_0x6A
	CALL SUBOPT_0x75
	CALL __ADDD12
	CALL SUBOPT_0x74
; 0002 040B     b = hexton(hextext_read_byte()); // record type
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 040C     b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R16,R30
; 0002 040D     cksum += b;
	ADD  R19,R16
; 0002 040E 
; 0002 040F     //Serial.print("Record type "); Serial.println(b, HEX);
; 0002 0410     if (b == 0x1) {
	CPI  R16,1
	BRNE _0x4017E
; 0002 0411      // end record!
; 0002 0412      break;
	RJMP _0x4017C
; 0002 0413     }
; 0002 0414     // offset *16 record!
; 0002 0415     else if (b == 0x2) {
_0x4017E:
	CPI  R16,2
	BRNE _0x40180
; 0002 0416          b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0417          b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x73
; 0002 0418          cksum += b;
; 0002 0419          OffsetX16=((ULONG)b<<12);
	CALL SUBOPT_0x6B
	CALL SUBOPT_0x6C
; 0002 041A          b = hexton(hextext_read_byte());
	CALL SUBOPT_0x72
; 0002 041B          b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x73
; 0002 041C          cksum += b;
; 0002 041D          OffsetX16|=((ULONG)b<<4);
	CALL SUBOPT_0x6B
	CALL SUBOPT_0x6D
; 0002 041E         b = hexton(hextext_read_byte());  // chxsum
	CALL SUBOPT_0x72
; 0002 041F         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x76
; 0002 0420         cksum += b;
; 0002 0421         if (cksum != 0) {
	BREQ _0x40181
; 0002 0422           error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 0423           //Serial.print(cksum, HEX);
; 0002 0424         }
; 0002 0425         if (hextext_read_byte() != '\r') {
_0x40181:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x40182
; 0002 0426           error("No end of line");
	CALL SUBOPT_0x70
; 0002 0427           return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 0428         }
; 0002 0429         if (hextext_read_byte() != '\n') {
_0x40182:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x40183
; 0002 042A           error("No end of line");
	CALL SUBOPT_0x70
; 0002 042B           break;
	RJMP _0x4017C
; 0002 042C         }
; 0002 042D         continue;
_0x40183:
	RJMP _0x4017A
; 0002 042E     }
; 0002 042F     else if (b == 0x3) {
_0x40180:
	CPI  R16,3
	BRNE _0x40185
; 0002 0430         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0431         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x77
; 0002 0432         cksum += b;
; 0002 0433         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x72
; 0002 0434         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x77
; 0002 0435         cksum += b;
; 0002 0436         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x72
; 0002 0437         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x77
; 0002 0438         cksum += b;
; 0002 0439         b = hexton(hextext_read_byte());
	CALL SUBOPT_0x72
; 0002 043A         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x77
; 0002 043B         cksum += b;
; 0002 043C         b = hexton(hextext_read_byte());  // chxsum
	CALL SUBOPT_0x72
; 0002 043D         b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x76
; 0002 043E         cksum += b;
; 0002 043F         if (cksum != 0) {
	BREQ _0x40186
; 0002 0440             error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 0441         //Serial.print(cksum, HEX);
; 0002 0442         }
; 0002 0443         if (hextext_read_byte() != '\r') {
_0x40186:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x40187
; 0002 0444           error("No end of line");
	CALL SUBOPT_0x70
; 0002 0445           return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 0446         }
; 0002 0447         if (hextext_read_byte() != '\n') {
_0x40187:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x40188
; 0002 0448             error("No end of line");
	CALL SUBOPT_0x70
; 0002 0449             break;
	RJMP _0x4017C
; 0002 044A         }
; 0002 044B         continue;
_0x40188:
	RJMP _0x4017A
; 0002 044C     }
; 0002 044D     for (i=0; i < len; i++) {
_0x40185:
	LDI  R18,LOW(0)
_0x4018A:
	CP   R18,R17
	BRLO PC+2
	RJMP _0x4018B
; 0002 044E       // read 'n' bytes
; 0002 044F       b = hexton(hextext_read_byte());
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0450       b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	ADD  R30,R26
	MOV  R16,R30
; 0002 0451       cksum += b;
	ADD  R19,R16
; 0002 0452 
; 0002 0453 //#if VERBOSE
; 0002 0454 //      Serial.print("$");
; 0002 0455 //      Serial.print(lineaddr, HEX);
; 0002 0456 //      Serial.print(":0x");
; 0002 0457 //      Serial.print(b, HEX);
; 0002 0458 //      Serial.write(" ? ");
; 0002 0459 //#endif
; 0002 045A 
; 0002 045B       // verify this byte!
; 0002 045C       if (lineaddr % 2) {
	CALL SUBOPT_0x78
	ANDI R30,LOW(0x1)
	BREQ _0x4018C
; 0002 045D         // for 'high' bytes:
; 0002 045E         if (b != g_txBuf[0]){//(spi_transaction(0x28, lineaddr >> 9, lineaddr / 2, 0) & 0xFF)) {
	LDS  R30,_g_txBuf
	CP   R30,R16
	BREQ _0x4018D
; 0002 045F           #ifdef PRINT_DEBUG
; 0002 0460           if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4018E
; 0002 0461           printf("verification error at address 0x%X",lineaddr);
	CALL SUBOPT_0x79
; 0002 0462           while(tx_counter);}
_0x4018F:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4018F
; 0002 0463           #endif //puthexchars(lineaddr>>8);puthexchars(lineaddr&0xff);
; 0002 0464           #ifdef PRINT_DEBUG
; 0002 0465           if(debug){
_0x4018E:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40192
; 0002 0466           printf(" Should be 0x%X",b);
	CALL SUBOPT_0x7A
	CALL SUBOPT_0x41
; 0002 0467           while(tx_counter);}
_0x40193:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40193
; 0002 0468           #endif //puthexchars(b);
; 0002 0469           #ifdef PRINT_DEBUG
; 0002 046A           if(debug){
_0x40192:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x40196
; 0002 046B           printf(" not 0x%X",g_txBuf[0]);
	__POINTW1FN _0x40000,1674
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x41
; 0002 046C           while(tx_counter);}
_0x40197:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x40197
; 0002 046D           #endif
; 0002 046E           //puthexchars(g_txBuf[0]);//Serial.println((spi_transaction(0x28, lineaddr >> 9, lineaddr / 2, 0) & 0xFF), HEX ...
; 0002 046F           return FALSE;
_0x40196:
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 0470         }
; 0002 0471       } else {
_0x4018D:
	RJMP _0x4019A
_0x4018C:
; 0002 0472         // for 'low bytes'
; 0002 0473         AVR910_ResetTXData();
	CALL _AVR910_ResetTXData
; 0002 0474         // 1. 'A,0x00,0x01' set address to read from flash. ACK response
; 0002 0475         // 2   'R' - read high byte then low byte
; 0002 0476         FIFO_Write('A');FIFO_Write(lineaddr>>9);FIFO_Write(lineaddr>>1);AVR910_Command();
	LDI  R30,LOW(65)
	ST   -Y,R30
	CALL _FIFO_Write
	CALL SUBOPT_0x75
	LDI  R30,LOW(9)
	CALL __LSRD12
	ST   -Y,R30
	CALL _FIFO_Write
	CALL SUBOPT_0x78
	CALL __LSRD1
	CALL SUBOPT_0x5D
; 0002 0477         if(g_txBuf[0]!=ACK){
	LDS  R26,_g_txBuf
	CPI  R26,LOW(0xD)
	BREQ _0x4019B
; 0002 0478             //puts("\r\nSetAddr FAIL");
; 0002 0479             return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 047A         }
; 0002 047B         AVR910_ResetTXData();
_0x4019B:
	CALL _AVR910_ResetTXData
; 0002 047C         AVR910_Standalone("R");
	__POINTW1FN _0x40000,1684
	CALL SUBOPT_0x4C
; 0002 047D         if (b != g_txBuf[1]){//(spi_transaction(0x28, lineaddr >> 9, lineaddr / 2, 0) & 0xFF)) {
	__GETB1MN _g_txBuf,1
	CP   R30,R16
	BREQ _0x4019C
; 0002 047E           #ifdef PRINT_DEBUG
; 0002 047F           if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x4019D
; 0002 0480           printf("\r\n0=%02x 1=%02x  \r\n",g_txBuf[0],g_txBuf[1]);
	__POINTW1FN _0x40000,1686
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x5B
	LDI  R24,8
	CALL _printf
	ADIW R28,10
; 0002 0481           printf("verification error at address 0x%X",lineaddr);
	CALL SUBOPT_0x79
; 0002 0482           while(tx_counter);}
_0x4019E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x4019E
; 0002 0483           #endif //puthexchars(lineaddr>>8);puthexchars(lineaddr&0xff);
; 0002 0484           #ifdef PRINT_DEBUG
; 0002 0485           if(debug){
_0x4019D:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401A1
; 0002 0486           printf(" Should be 0x%X",b);
	CALL SUBOPT_0x7A
	CALL SUBOPT_0x41
; 0002 0487           while(tx_counter);}
_0x401A2:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401A2
; 0002 0488           #endif // puthexchars(b);
; 0002 0489           #ifdef PRINT_DEBUG
; 0002 048A           if(debug){
_0x401A1:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401A5
; 0002 048B           printf(" not 0x%X",g_txBuf[1]);
	__POINTW1FN _0x40000,1674
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x41
; 0002 048C           while(tx_counter);}
_0x401A6:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401A6
; 0002 048D           #endif
; 0002 048E           //puthexchars(g_txBuf[1]);//Serial.println((spi_transaction(0x28, lineaddr >> 9, lineaddr / 2, 0) & 0xFF), HEX ...
; 0002 048F           return FALSE;
_0x401A5:
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 0490         }
; 0002 0491       }
_0x4019C:
_0x4019A:
; 0002 0492       lineaddr++;
	CALL SUBOPT_0x78
	CALL SUBOPT_0x63
	CALL SUBOPT_0x74
; 0002 0493     }
	SUBI R18,-1
	RJMP _0x4018A
_0x4018B:
; 0002 0494 
; 0002 0495     b = hexton(hextext_read_byte());  // chxsum
	CALL SUBOPT_0x64
	CALL SUBOPT_0x72
; 0002 0496     b = (b<<4) + hexton(hextext_read_byte());
	PUSH R30
	CALL SUBOPT_0x64
	POP  R26
	CALL SUBOPT_0x76
; 0002 0497     cksum += b;
; 0002 0498     if (cksum != 0) {
	BREQ _0x401A9
; 0002 0499       error("Bad checksum: ");
	CALL SUBOPT_0x6F
; 0002 049A       #ifdef PRINT_DEBUG
; 0002 049B       if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401AA
; 0002 049C       printf("0x%x",cksum);
	__POINTW1FN _0x40000,144
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R19
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x41
; 0002 049D       while(tx_counter);}
_0x401AB:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401AB
; 0002 049E       #endif
; 0002 049F       return FALSE;
_0x401AA:
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 04A0     }
; 0002 04A1     if (hextext_read_byte() != '\r') {
_0x401A9:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xD)
	BREQ _0x401AE
; 0002 04A2       error("No end of line");
	CALL SUBOPT_0x70
; 0002 04A3       return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 04A4     }
; 0002 04A5     if (hextext_read_byte() != '\n') {
_0x401AE:
	CALL _hextext_read_byte
	CPI  R30,LOW(0xA)
	BREQ _0x401AF
; 0002 04A6       error("No end of line");
	CALL SUBOPT_0x70
; 0002 04A7       return FALSE;
	LDI  R30,LOW(0)
	RJMP _0x20C001B
; 0002 04A8     }
; 0002 04A9   }
_0x401AF:
	RJMP _0x4017A
_0x4017C:
; 0002 04AA   return TRUE;
	LDI  R30,LOW(1)
_0x20C001B:
	CALL __LOADLOCR4
	ADIW R28,8
	RET
; 0002 04AB }
; .FEND
;
;/*
; * programmingFuses
; * Program the fuse/lock bits
; */
;UCHAR programFuses (UCHAR *fuses,UCHAR *fusemask)
; 0002 04B2 {
_programFuses:
; .FSTART _programFuses
; 0002 04B3   //SPI.setClockDivider(CLOCKSPEED_FUSES);
; 0002 04B4 
; 0002 04B5   UCHAR f;
; 0002 04B6   #ifdef PRINT_DEBUG
; 0002 04B7   if(debug){
	ST   -Y,R17
;	*fuses -> Y+3
;	*fusemask -> Y+1
;	f -> R17
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401B0
; 0002 04B8   while(tx_counter);
_0x401B1:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401B1
; 0002 04B9   printf("\r\nSetting fuses");
	__POINTW1FN _0x40000,1706
	CALL SUBOPT_0x22
; 0002 04BA   while(tx_counter);}
_0x401B4:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401B4
; 0002 04BB   #endif
; 0002 04BC   #ifdef PRINT_LCD
; 0002 04BD   lcd_putsf_row(1,"Setting fuses");
_0x401B0:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1708
	CALL SUBOPT_0xC
; 0002 04BE   #endif
; 0002 04BF   f = pgm_read_byte(&fuses[FUSE_LOW]) | ~pgm_read_byte(&fusemask[FUSE_LOW]);//0x00 | ~0x01=0xFE  = 0xFE
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	CALL SUBOPT_0x7B
	PUSH R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CALL SUBOPT_0x7B
	COM  R30
	POP  R26
	CALL SUBOPT_0x7C
; 0002 04C0   if (pgm_read_byte(&fusemask[FUSE_LOW])) {
	CALL SUBOPT_0x7B
	CPI  R30,0
	BREQ _0x401B7
; 0002 04C1     #ifdef PRINT_DEBUG
; 0002 04C2     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401B8
; 0002 04C3     printf("\r\n  Set Low Fuses to: 0x%02x",f);
	__POINTW1FN _0x40000,1722
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
; 0002 04C4     while(tx_counter);}
_0x401B9:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401B9
; 0002 04C5     #endif
; 0002 04C6     AVR910_ResetTXData();
_0x401B8:
	CALL _AVR910_ResetTXData
; 0002 04C7     FIFO_Write('f');//write low fuses
	LDI  R30,LOW(102)
	CALL SUBOPT_0x7E
; 0002 04C8     FIFO_Write(f);
; 0002 04C9     AVR910_Command();
; 0002 04CA     AVR910_ResetTXData();
; 0002 04CB   }
; 0002 04CC   f = pgm_read_byte(&fuses[FUSE_HIGH]) | ~pgm_read_byte(&fusemask[FUSE_HIGH]);
_0x401B7:
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	CALL SUBOPT_0x7F
	PUSH R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CALL SUBOPT_0x7F
	COM  R30
	POP  R26
	CALL SUBOPT_0x7C
; 0002 04CD   if (pgm_read_byte(&fusemask[FUSE_HIGH])) {
	CALL SUBOPT_0x7F
	CPI  R30,0
	BREQ _0x401BC
; 0002 04CE     #ifdef PRINT_DEBUG
; 0002 04CF     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401BD
; 0002 04D0     printf("\r\n  Set High Fuse to: 0x%02x",f);
	__POINTW1FN _0x40000,1751
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
; 0002 04D1     while(tx_counter);}
_0x401BE:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401BE
; 0002 04D2     #endif
; 0002 04D3     AVR910_ResetTXData();
_0x401BD:
	CALL _AVR910_ResetTXData
; 0002 04D4     FIFO_Write('n');//write high fuses
	LDI  R30,LOW(110)
	CALL SUBOPT_0x7E
; 0002 04D5     FIFO_Write(f);
; 0002 04D6     AVR910_Command();
; 0002 04D7     AVR910_ResetTXData();
; 0002 04D8   }
; 0002 04D9   f = pgm_read_byte(&fuses[FUSE_EXT]) | ~pgm_read_byte(&fusemask[FUSE_EXT]);
_0x401BC:
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	CALL SUBOPT_0x80
	PUSH R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CALL SUBOPT_0x80
	COM  R30
	POP  R26
	CALL SUBOPT_0x7C
; 0002 04DA   if (pgm_read_byte(&fusemask[FUSE_EXT])) {
	CALL SUBOPT_0x80
	CPI  R30,0
	BREQ _0x401C1
; 0002 04DB     #ifdef PRINT_DEBUG
; 0002 04DC     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401C2
; 0002 04DD     printf("\r\n  Set Ext Fuse to: 0x%02x",f);
	__POINTW1FN _0x40000,1780
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
; 0002 04DE     while(tx_counter);}
_0x401C3:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401C3
; 0002 04DF     #endif
; 0002 04E0     AVR910_ResetTXData();
_0x401C2:
	CALL _AVR910_ResetTXData
; 0002 04E1     FIFO_Write('o');//write ext fuses
	LDI  R30,LOW(111)
	CALL SUBOPT_0x7E
; 0002 04E2     FIFO_Write(f);
; 0002 04E3     AVR910_Command();
; 0002 04E4     AVR910_ResetTXData();
; 0002 04E5   }
; 0002 04E6   f = pgm_read_byte(&fuses[FUSE_PROT]) | ~pgm_read_byte(&fusemask[FUSE_PROT]); //used when hex in flash
_0x401C1:
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	CALL SUBOPT_0x81
	PUSH R30
	CALL SUBOPT_0x20
	CALL _pgm_read_byte
	COM  R30
	POP  R26
	OR   R30,R26
	MOV  R17,R30
; 0002 04E7   if (pgm_read_byte(&fusemask[FUSE_PROT])) {
	CALL SUBOPT_0x20
	CALL _pgm_read_byte
	CPI  R30,0
	BREQ _0x401C6
; 0002 04E8     #ifdef PRINT_DEBUG
; 0002 04E9     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401C7
; 0002 04EA     printf("\r\n  Set Lock Fuse to: 0x%02x",f);
	__POINTW1FN _0x40000,1808
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
; 0002 04EB     while(tx_counter);}
_0x401C8:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401C8
; 0002 04EC     #endif
; 0002 04ED     AVR910_ResetTXData();
_0x401C7:
	CALL _AVR910_ResetTXData
; 0002 04EE     FIFO_Write('l');//write lock fuses
	LDI  R30,LOW(108)
	CALL SUBOPT_0x7E
; 0002 04EF     FIFO_Write(f);
; 0002 04F0     AVR910_Command();
; 0002 04F1     AVR910_ResetTXData();
; 0002 04F2   }
; 0002 04F3   return TRUE;			/* */
_0x401C6:
	LDI  R30,LOW(1)
	LDD  R17,Y+0
	ADIW R28,5
	RET
; 0002 04F4 }
; .FEND
;/*
; * verifyFuses
; * Verifies a fuse set
; */
;UCHAR verifyFuses (UCHAR *fuses, UCHAR *fusemask)
; 0002 04FA {
_verifyFuses:
; .FSTART _verifyFuses
; 0002 04FB   //SPI.setClockDivider(CLOCKSPEED_FUSES);
; 0002 04FC   UCHAR f;
; 0002 04FD   UCHAR readfuse;
; 0002 04FE   #ifdef PRINT_DEBUG
; 0002 04FF   if(debug){
	ST   -Y,R17
	ST   -Y,R16
;	*fuses -> Y+4
;	*fusemask -> Y+2
;	f -> R17
;	readfuse -> R16
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x401CB
; 0002 0500   printf("\r\nVerifying fuses...");
	__POINTW1FN _0x40000,1837
	CALL SUBOPT_0x22
; 0002 0501   while(tx_counter);}
_0x401CC:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401CC
; 0002 0502   #endif
; 0002 0503   #ifdef PRINT_LCD
; 0002 0504   lcd_putsf_row(1,"Verifying fuses.");
_0x401CB:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x40000,1858
	CALL SUBOPT_0xC
; 0002 0505   #endif
; 0002 0506   f = pgm_read_byte(&fuses[FUSE_LOW]) | ~pgm_read_byte(&fusemask[FUSE_LOW]);
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x7B
	PUSH R30
	CALL SUBOPT_0x82
	COM  R30
	POP  R26
	OR   R30,R26
	MOV  R17,R30
; 0002 0507   if (pgm_read_byte(&fusemask[FUSE_LOW])) {
	CALL SUBOPT_0x82
	CPI  R30,0
	BREQ _0x401CF
; 0002 0508     AVR910_Standalone("F");  // low fuse
	__POINTW1FN _0x40000,1875
	CALL SUBOPT_0x4C
; 0002 0509     readfuse=g_txBuf[0];
	LDS  R16,_g_txBuf
; 0002 050A     readfuse |= ~pgm_read_byte(&fusemask[FUSE_LOW]);
	CALL SUBOPT_0x82
	CALL SUBOPT_0x83
; 0002 050B     #ifdef PRINT_DEBUG
; 0002 050C     if(debug){
	BREQ _0x401D0
; 0002 050D     printf("\r\n  Low Fuse Writen: 0x%02x",f); printf("\r\n  Low Fuse Readed: 0x%02x",readfuse);
	__POINTW1FN _0x40000,1877
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
	__POINTW1FN _0x40000,1905
	CALL SUBOPT_0x84
	CALL SUBOPT_0x41
; 0002 050E     while(tx_counter);}
_0x401D1:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401D1
; 0002 050F     #endif
; 0002 0510     if (readfuse != f)
_0x401D0:
	CP   R17,R16
	BREQ _0x401D4
; 0002 0511       return FALSE;
	LDI  R30,LOW(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20C0016
; 0002 0512   }
_0x401D4:
; 0002 0513   f = pgm_read_byte(&fuses[FUSE_HIGH]) | ~pgm_read_byte(&fusemask[FUSE_HIGH]);
_0x401CF:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x7F
	PUSH R30
	CALL SUBOPT_0x85
	COM  R30
	POP  R26
	OR   R30,R26
	MOV  R17,R30
; 0002 0514   if (pgm_read_byte(&fusemask[FUSE_HIGH])) {
	CALL SUBOPT_0x85
	CPI  R30,0
	BREQ _0x401D5
; 0002 0515     AVR910_Standalone("N"); // high fuse
	__POINTW1FN _0x40000,1933
	CALL SUBOPT_0x4C
; 0002 0516     readfuse=g_txBuf[0];
	LDS  R16,_g_txBuf
; 0002 0517     readfuse |= ~pgm_read_byte(&fusemask[FUSE_HIGH]);
	CALL SUBOPT_0x85
	CALL SUBOPT_0x83
; 0002 0518     #ifdef PRINT_DEBUG
; 0002 0519     if(debug){
	BREQ _0x401D6
; 0002 051A     printf("\r\n  High Fuse Writen: 0x%02x",f); printf("\r\n  High Fuse Readed: 0x%02x",readfuse);
	__POINTW1FN _0x40000,1935
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
	__POINTW1FN _0x40000,1964
	CALL SUBOPT_0x84
	CALL SUBOPT_0x41
; 0002 051B     while(tx_counter);}
_0x401D7:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401D7
; 0002 051C     #endif
; 0002 051D     if (readfuse != f)
_0x401D6:
	CP   R17,R16
	BREQ _0x401DA
; 0002 051E       return FALSE;
	LDI  R30,LOW(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20C0016
; 0002 051F   }
_0x401DA:
; 0002 0520   f = pgm_read_byte(&fuses[FUSE_EXT]) | ~pgm_read_byte(&fusemask[FUSE_EXT]);
_0x401D5:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x80
	PUSH R30
	CALL SUBOPT_0x86
	COM  R30
	POP  R26
	OR   R30,R26
	MOV  R17,R30
; 0002 0521   if (pgm_read_byte(&fusemask[FUSE_EXT])) {
	CALL SUBOPT_0x86
	CPI  R30,0
	BREQ _0x401DB
; 0002 0522     AVR910_Standalone("O"); // ext fuse
	__POINTW1FN _0x40000,1993
	CALL SUBOPT_0x4C
; 0002 0523     readfuse=g_txBuf[0];
	LDS  R16,_g_txBuf
; 0002 0524     readfuse |= ~pgm_read_byte(&fusemask[FUSE_EXT]);
	CALL SUBOPT_0x86
	CALL SUBOPT_0x83
; 0002 0525     #ifdef PRINT_DEBUG
; 0002 0526     if(debug){
	BREQ _0x401DC
; 0002 0527     printf("\r\n  Ext Fuse Writen: 0x%02x",f); printf("\r\n  Ext Fuse Readed: 0x%02x",readfuse);
	__POINTW1FN _0x40000,1995
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
	__POINTW1FN _0x40000,2023
	CALL SUBOPT_0x84
	CALL SUBOPT_0x41
; 0002 0528     while(tx_counter);}
_0x401DD:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401DD
; 0002 0529     #endif
; 0002 052A     if (readfuse != f)
_0x401DC:
	CP   R17,R16
	BREQ _0x401E0
; 0002 052B       return FALSE;
	LDI  R30,LOW(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20C0016
; 0002 052C   }
_0x401E0:
; 0002 052D   f = pgm_read_byte(&fuses[FUSE_PROT]) | ~pgm_read_byte(&fusemask[FUSE_PROT]);
_0x401DB:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x81
	PUSH R30
	CALL SUBOPT_0x87
	COM  R30
	POP  R26
	OR   R30,R26
	MOV  R17,R30
; 0002 052E   if (pgm_read_byte(&fusemask[FUSE_PROT])) {
	CALL SUBOPT_0x87
	CPI  R30,0
	BREQ _0x401E1
; 0002 052F     AVR910_Standalone("Q");  // lock fuse
	__POINTW1FN _0x40000,2051
	CALL SUBOPT_0x4C
; 0002 0530     readfuse=g_txBuf[0];
	LDS  R16,_g_txBuf
; 0002 0531     readfuse |= ~pgm_read_byte(&fusemask[FUSE_PROT]);
	CALL SUBOPT_0x87
	CALL SUBOPT_0x83
; 0002 0532     #ifdef PRINT_DEBUG
; 0002 0533     if(debug){
	BREQ _0x401E2
; 0002 0534     printf("\r\n  Lock Fuse Writen: 0x%02x",f); printf("\r\n  Lock Fuse Readed: 0x%02x",readfuse);
	__POINTW1FN _0x40000,2053
	CALL SUBOPT_0x7D
	CALL SUBOPT_0x41
	__POINTW1FN _0x40000,2082
	CALL SUBOPT_0x84
	CALL SUBOPT_0x41
; 0002 0535     while(tx_counter);}
_0x401E3:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x401E3
; 0002 0536     #endif
; 0002 0537     if (readfuse != f)
_0x401E2:
	CP   R17,R16
	BREQ _0x401E6
; 0002 0538       return FALSE;
	LDI  R30,LOW(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20C0016
; 0002 0539   }
_0x401E6:
; 0002 053A   return TRUE;			/* */
_0x401E1:
	LDI  R30,LOW(1)
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20C0016
; 0002 053B }
; .FEND
;#include "common.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif
;
;const unsigned char roll[] =
;
;          { 0xE9, 0x79, 0x25, 0x54, 0x88, 0xDF, 0xA5, 0xB9, 0xF6, 0xC2,
;            0xAB, 0xFC, 0xB3, 0xB1, 0x37, 0xE1, 0x83, 0xD5, 0x97, 0x04,
;            0x38, 0xFE, 0x99, 0x26, 0xE4, 0x8E, 0x4B, 0xF7, 0x04, 0xC5,
;            0xA5, 0x1F, 0x88, 0x68, 0xEF, 0x1D, 0x39, 0xBC, 0x62, 0xD8,
;            0x63, 0x0F, 0x6A, 0xA5, 0x12, 0xAA, 0xE5, 0x8C, 0x75, 0x36,
;            0xBA, 0x81, 0x8F, 0x30, 0x3D, 0xEB, 0xE0, 0xFE, 0x70, 0xFA,
;            0x94, 0xAE, 0xB5, 0x31 };
;#ifdef PETITFATFS
;/* MMC/SD/SD HC card support */
;#include "mmc.h"
;/* PETIT FATFS support */
;#include "pff.h"
;#endif
;
;/* sprintf */
;#include <stdio.h>
;/* string functions */
;#include <string.h>
;/* Timer1 overflow interrupt frequency [Hz] */
;#define T1_OVF_FREQ 100
;/* Timer1 clock prescaler value */
;#define T1_PRESC 1024L
;/* Timer1 initialization value after overflow */
;#define T1_INIT (0x10000L-(_MCU_CLOCK_FREQUENCY_/(T1_PRESC*T1_OVF_FREQ)))
;/* 100Hz timer interrupt generated by ATmega128 Timer1 overflow */
;
;volatile unsigned char CounterLed=0;
;
;interrupt [TIM1_OVF] void timer_comp_isr(void)
; 0003 0022 {

	.CSEG
_timer_comp_isr:
; .FSTART _timer_comp_isr
	ST   -Y,R26
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0003 0023     /* re-initialize Timer1 */
; 0003 0024     TCNT1H=T1_INIT>>8;
	CALL SUBOPT_0x88
; 0003 0025     TCNT1L=T1_INIT&0xFF;
; 0003 0026     /* card access low level timing function */
; 0003 0027     #ifndef PETITFATFS
; 0003 0028     disk_timerproc();
; 0003 0029     #endif
; 0003 002A     /* the rest of the interrupt service routine */
; 0003 002B     /* .... */
; 0003 002C     if(StandaloneMode==IDLE){
	LDS  R30,_StandaloneMode
	CPI  R30,0
	BRNE _0x60003
; 0003 002D         LED_PASS_OFF();
	SBI  0x5,1
; 0003 002E         LED_ERR_OFF();
	RJMP _0x600FD
; 0003 002F     }
; 0003 0030     else if(StandaloneMode==RUNNING)
_0x60003:
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x3)
	BREQ _0x600FD
; 0003 0031         LED_ERR_OFF();
; 0003 0032     else if(StandaloneMode==PASS){
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x1)
	BRNE _0x6000D
; 0003 0033         LED_PASS_ON();
	CBI  0x5,1
; 0003 0034         LED_ERR_OFF();
	RJMP _0x600FD
; 0003 0035     }
; 0003 0036     else if(StandaloneMode==FAIL){
_0x6000D:
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x2)
	BRNE _0x60013
; 0003 0037         LED_PASS_OFF();
	SBI  0x5,1
; 0003 0038         if(++CounterLed>=50){
	CALL SUBOPT_0x9
	CPI  R26,LOW(0x32)
	BRLO _0x60016
; 0003 0039             CounterLed=0;
	LDI  R30,LOW(0)
	STS  _CounterLed,R30
; 0003 003A             LED_ERR_TGL();
	SBIS 0x5,0
	RJMP _0x60017
	CBI  0x5,0
	RJMP _0x60018
_0x60017:
	SBI  0x5,0
_0x60018:
; 0003 003B         }
; 0003 003C     }
_0x60016:
; 0003 003D     else if(StandaloneMode==SDFAIL){
	RJMP _0x60019
_0x60013:
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x4)
	BRNE _0x6001A
; 0003 003E         LED_PASS_OFF();
	SBI  0x5,1
; 0003 003F         if(++CounterLed>=100){
	CALL SUBOPT_0x9
	CPI  R26,LOW(0x64)
	BRLO _0x6001D
; 0003 0040             CounterLed=0;
	LDI  R30,LOW(0)
	STS  _CounterLed,R30
; 0003 0041             LED_ERR_TGL();
	SBIS 0x5,0
	RJMP _0x6001E
	CBI  0x5,0
	RJMP _0x6001F
_0x6001E:
_0x600FD:
	SBI  0x5,0
_0x6001F:
; 0003 0042         }
; 0003 0043     }
_0x6001D:
; 0003 0044 }
_0x6001A:
_0x60019:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	LD   R26,Y+
	RETI
; .FEND
;
;/* error message list */
;flash char * flash error_msg[]=
;{
;"", /* not used */
;"FR_DISK_ERR",
;"FR_INT_ERR",
;"FR_NOT_READY",
;"FR_NO_FILE",
;"FR_NO_PATH",
;"FR_INVALID_NAME",
;"FR_DENIED",
;"FR_EXIST",
;"FR_INVALID_OBJECT",
;"FR_WRITE_PROTECTED",
;"FR_INVALID_DRIVE",
;"FR_NOT_ENABLED",
;"FR_NO_FILESYSTEM",
;"FR_MKFS_ABORTED",
;"FR_TIMEOUT"
;};
;
;// Declare your global variables here
;/* FAT function result */
;FRESULT res;
;/* number of bytes written/read to the file */
;UINT nbytes,nbytesCounter;
;//ULONG nSector;
;/* will hold the information for logical drive 0: */
;#ifndef PETITFATFS
;FATFS fat;
;/* will hold the file information */
;FIL file;
;/* will hold the file information */
;FILINFO fno;
;#else
;FATFS fs;          /* Work area (file system object) for the volume */
;#endif
;
;/* file path */
;char path[]="0:/10/file1234.txt";

	.DSEG
;/* file read buffer */
;unsigned char buffer[512];//;
;
;void init_sd_tim1(void)
; 0003 0072 {

	.CSEG
_init_sd_tim1:
; .FSTART _init_sd_tim1
; 0003 0073 /* initialize Timer1 overflow interrupts in Mode 0 (Normal) */
; 0003 0074     TCCR1A=0x00;
	LDI  R30,LOW(0)
	STS  128,R30
; 0003 0075     /* clkio/1024 */
; 0003 0076     TCCR1B=(1<<CS12)|(1<<CS10);
	LDI  R30,LOW(5)
	STS  129,R30
; 0003 0077     /* timer overflow interrupts will occur with 100Hz frequency */
; 0003 0078     TCNT1H=T1_INIT>>8;
	CALL SUBOPT_0x88
; 0003 0079     TCNT1L=T1_INIT&0xFF;
; 0003 007A     /* enable Timer1 overflow interrupt */
; 0003 007B     #ifdef _MEGA64_INCLUDED_
; 0003 007C     TIMSK=1<<TOIE1;
; 0003 007D     #else
; 0003 007E     TIMSK1=1<<TOIE1;
	LDI  R30,LOW(1)
	STS  111,R30
; 0003 007F     #endif
; 0003 0080 }
	RET
; .FEND
;/* display error message and stop */
;void RESerror(FRESULT res)
; 0003 0083 {
_RESerror:
; .FSTART _RESerror
; 0003 0084     if(res!=0)
;	res -> Y+0
	LD   R30,Y
	CPI  R30,0
	BREQ _0x60021
; 0003 0085         StandaloneMode=SDFAIL;
	LDI  R30,LOW(4)
	STS  _StandaloneMode,R30
; 0003 0086     #ifdef PRINT_DEBUG
; 0003 0087     if(debug){
_0x60021:
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x60022
; 0003 0088         while(tx_counter);
_0x60023:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60023
; 0003 0089     #ifdef PETITFATFS
; 0003 008A     //if ((res>=FR_DISK_ERR) && (res<=FR_NO_FILESYSTEM))
; 0003 008B     #else
; 0003 008C     //if ((res>=FR_DISK_ERR) &&(res<=FR_TIMEOUT))
; 0003 008D     #endif
; 0003 008E        printf("\r\nERROR %d: %p",res, error_msg[res]);
	__POINTW1FN _0x60000,207
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	CALL SUBOPT_0x43
	LDD  R30,Y+6
	CALL SUBOPT_0x89
	CALL SUBOPT_0x8A
; 0003 008F        while(tx_counter);}
_0x60026:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60026
; 0003 0090     #endif
; 0003 0091     #ifdef PRINT_LCD
; 0003 0092     lcd_putsf_row(1,error_msg[res]);
_0x60022:
	LDI  R30,LOW(1)
	ST   -Y,R30
	LDD  R30,Y+1
	CALL SUBOPT_0x89
	CALL SUBOPT_0xC
; 0003 0093     #endif
; 0003 0094 /* stop here */
; 0003 0095 //while(1);
; 0003 0096 }
	JMP  _0x20C0014
; .FEND
;
;UCHAR sd_mount(void)
; 0003 0099 {
_sd_mount:
; .FSTART _sd_mount
; 0003 009A     UCHAR retry=3;
; 0003 009B     while(retry)
	ST   -Y,R17
;	retry -> R17
	LDI  R17,3
_0x60029:
	CPI  R17,0
	BRNE PC+2
	RJMP _0x6002B
; 0003 009C     {
; 0003 009D         retry--;
	SUBI R17,1
; 0003 009E         /* initialize SPI interface and card driver */
; 0003 009F         #ifdef PETITFATFS
; 0003 00A0         if((res=disk_initialize())!=0){
	CALL _disk_initialize
	STS  _res,R30
	CPI  R30,0
	BRNE PC+2
	RJMP _0x6002C
; 0003 00A1         #else
; 0003 00A2         if((res=disk_initialize(0))!=0){//0=DRIVE NUMBER
; 0003 00A3         #endif
; 0003 00A4             #ifdef PRINT_DEBUG
; 0003 00A5                 if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6002D
; 0003 00A6                 while(tx_counter);
_0x6002E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6002E
; 0003 00A7                 printf("\r\nSPI Init Failed. Return status %d.\r\n",res);
	__POINTW1FN _0x60000,222
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_res
	CALL SUBOPT_0x43
	CALL SUBOPT_0x41
; 0003 00A8                 if (res & STA_NOINIT) printf("Disk init failed");
	LDS  R30,_res
	ANDI R30,LOW(0x1)
	BREQ _0x60031
	__POINTW1FN _0x60000,261
	RJMP _0x600FE
; 0003 00A9                 else
_0x60031:
; 0003 00AA                 if (res & STA_NODISK) printf("Card not present");
	LDS  R30,_res
	ANDI R30,LOW(0x2)
	BREQ _0x60033
	__POINTW1FN _0x60000,278
	RJMP _0x600FE
; 0003 00AB                 else
_0x60033:
; 0003 00AC                 if (res & STA_PROTECT) printf("Card write\nprotected");
	LDS  R30,_res
	ANDI R30,LOW(0x3)
	BREQ _0x60035
	__POINTW1FN _0x60000,295
_0x600FE:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _printf
	ADIW R28,2
; 0003 00AD                 while(tx_counter);}
_0x60035:
_0x60036:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60036
; 0003 00AE             #endif
; 0003 00AF             #ifdef PRINT_LCD
; 0003 00B0                 if (res & STA_NOINIT) lcd_putsf_row(1,"Disk init failed");
_0x6002D:
	LDS  R30,_res
	ANDI R30,LOW(0x1)
	BREQ _0x60039
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x60000,261
	RJMP _0x600FF
; 0003 00B1                 else
_0x60039:
; 0003 00B2                 if (res & STA_NODISK) lcd_putsf_row(1,"Card not present");
	LDS  R30,_res
	ANDI R30,LOW(0x2)
	BREQ _0x6003B
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x60000,278
	RJMP _0x600FF
; 0003 00B3                 else
_0x6003B:
; 0003 00B4                 if (res & STA_PROTECT) lcd_putsf_row(1,"Card write prot");
	LDS  R30,_res
	ANDI R30,LOW(0x3)
	BREQ _0x6003D
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x60000,316
_0x600FF:
	ST   -Y,R31
	ST   -Y,R30
	CALL _lcd_putsf_row
; 0003 00B5             #endif
; 0003 00B6             if(retry){
_0x6003D:
	CPI  R17,0
	BREQ _0x6003E
; 0003 00B7                 continue;
	RJMP _0x60029
; 0003 00B8             }
; 0003 00B9             else{
_0x6003E:
; 0003 00BA                 delay_ms(1000);
	LDI  R30,LOW(1000)
	LDI  R31,HIGH(1000)
	CALL SUBOPT_0x17
; 0003 00BB                 StandaloneMode=SDFAIL;
	LDI  R30,LOW(4)
	STS  _StandaloneMode,R30
; 0003 00BC                 return FALSE;
	LDI  R30,LOW(0)
	JMP  _0x20C0013
; 0003 00BD             }
; 0003 00BE         }
; 0003 00BF         /* mount logical drive 0: */
; 0003 00C0         #ifdef PETITFATFS
; 0003 00C1         if ((res=pf_mount(&fs))==FR_OK)
_0x6002C:
	LDI  R30,LOW(_fs)
	LDI  R31,HIGH(_fs)
	ST   -Y,R31
	ST   -Y,R30
	CALL _pf_mount
	STS  _res,R30
	CPI  R30,0
	BRNE _0x60040
; 0003 00C2         #else
; 0003 00C3         if((res=f_mount(0,&fat))==FR_OK)
; 0003 00C4         #endif
; 0003 00C5         {
; 0003 00C6             #ifdef PRINT_DEBUG
; 0003 00C7             if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x60041
; 0003 00C8             while(tx_counter);
_0x60042:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60042
; 0003 00C9             printf("\r\nLogical drive 0: mounted OK\r\n");
	__POINTW1FN _0x60000,332
	CALL SUBOPT_0x22
; 0003 00CA             while(tx_counter);}
_0x60045:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60045
; 0003 00CB             #endif
; 0003 00CC         }
_0x60041:
; 0003 00CD         else{
	RJMP _0x60048
_0x60040:
; 0003 00CE             if(retry)
	CPI  R17,0
	BREQ _0x60049
; 0003 00CF                 continue;
	RJMP _0x60029
; 0003 00D0             else
_0x60049:
; 0003 00D1                 /* an error occured, display it and stop */
; 0003 00D2                 goto print_error;
	RJMP _0x6004B
; 0003 00D3         }
_0x60048:
; 0003 00D4         return TRUE;
	LDI  R30,LOW(1)
	JMP  _0x20C0013
; 0003 00D5     }
_0x6002B:
; 0003 00D6 print_error:
_0x6004B:
; 0003 00D7     RESerror(res);
	CALL SUBOPT_0x8B
; 0003 00D8     return FALSE;
	LDI  R30,LOW(0)
	JMP  _0x20C0013
; 0003 00D9 }
; .FEND
;
;char *GetRollCounter(flash char *Key)
; 0003 00DC {
_GetRollCounter:
; .FSTART _GetRollCounter
; 0003 00DD     char *pvalue=NULL,*pkey;
; 0003 00DE     UINT  i;//buffer index
; 0003 00DF 
; 0003 00E0     UCHAR retry=3;
; 0003 00E1     UINT RollCounterToCheck;
; 0003 00E2     debug=1;
	SBIW R28,3
	LDI  R30,LOW(3)
	STD  Y+2,R30
	CALL __SAVELOCR6
;	*Key -> Y+9
;	*pvalue -> R16,R17
;	*pkey -> R18,R19
;	i -> R20,R21
;	retry -> Y+8
;	RollCounterToCheck -> Y+6
	__GETWRN 16,17,0
	LDI  R30,LOW(1)
	STS  _debug,R30
; 0003 00E3     buffer[nbytes]=NULL;
	CALL SUBOPT_0x8C
	CALL SUBOPT_0x8D
; 0003 00E4     if((tmpimage.RollCounter+ROLL_WINDOW)>= ROLL_SIZE)
	CALL SUBOPT_0x8E
	CPI  R30,LOW(0x40)
	LDI  R26,HIGH(0x40)
	CPC  R31,R26
	BRLT _0x6004C
; 0003 00E5         tmpimage.RollCounter=0;
	LDI  R30,LOW(0)
	__PUTB1MN _tmpimage,92
; 0003 00E6     RollCounterToCheck=tmpimage.RollCounter;
_0x6004C:
	__GETB1MN _tmpimage,92
	LDI  R31,0
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0003 00E7     #ifdef PRINT_DEBUG
; 0003 00E8     if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6004D
; 0003 00E9     while(tx_counter);
_0x6004E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6004E
; 0003 00EA     printf("\r\ntmpimage.RollCounter=%d, ",tmpimage.RollCounter);
	__POINTW1FN _0x60000,364
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _tmpimage,92
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x41
; 0003 00EB     while(tx_counter);}
_0x60051:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60051
; 0003 00EC     #endif
; 0003 00ED     if(fileOpen()==0)
_0x6004D:
	RCALL _fileOpen
	CPI  R30,0
	BRNE _0x60054
; 0003 00EE         goto print_error;
	RJMP _0x60055
; 0003 00EF     SetConfigArea();
_0x60054:
	RCALL _SetConfigArea
; 0003 00F0     #ifndef  PETITFATFS
; 0003 00F1     res=f_read(&file,buffer,sizeof(buffer),&nbytes);
; 0003 00F2     #else
; 0003 00F3     res=pf_read(buffer,sizeof(buffer),&nbytes);
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x90
; 0003 00F4     #endif
; 0003 00F5     if(res)
	BREQ _0x60056
; 0003 00F6         goto print_error;
	RJMP _0x60055
; 0003 00F7     while(RollCounterToCheck < (tmpimage.RollCounter+ROLL_WINDOW))
_0x60056:
_0x60057:
	CALL SUBOPT_0x8E
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRLO PC+2
	RJMP _0x60059
; 0003 00F8     {
; 0003 00F9         #ifdef PRINT_DEBUG
; 0003 00FA         if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6005A
; 0003 00FB         while(tx_counter);
_0x6005B:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6005B
; 0003 00FC         printf("\r\nRollCounterToCheck=%d, ",RollCounterToCheck);
	__POINTW1FN _0x60000,392
	CALL SUBOPT_0x91
	CALL SUBOPT_0x44
; 0003 00FD         while(tx_counter);}
_0x6005E:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6005E
; 0003 00FE         #endif
; 0003 00FF        memcpy(tmpbytes,buffer,strlenf("[settings]"));
_0x6005A:
	LDI  R30,LOW(_tmpbytes)
	LDI  R31,HIGH(_tmpbytes)
	CALL SUBOPT_0x50
	CALL SUBOPT_0x92
	CALL _strlenf
	ST   -Y,R31
	ST   -Y,R30
	CALL _memcpy
; 0003 0100        for(i=0;i<strlenf("[settings]");i++)
	__GETWRN 20,21,0
_0x60062:
	CALL SUBOPT_0x93
	CP   R20,R30
	CPC  R21,R31
	BRLO PC+2
	RJMP _0x60063
; 0003 0101        {
; 0003 0102             #ifdef PRINT_DEBUG
; 0003 0103             if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x60064
; 0003 0104             while(tx_counter);
_0x60065:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60065
; 0003 0105             printf("\r\n%d=%02x, %02x ",i,tmpbytes[i],buffer[i]);
	__POINTW1FN _0x60000,429
	CALL SUBOPT_0x94
	CALL SUBOPT_0x95
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x40
; 0003 0106             while(tx_counter);}
_0x60068:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60068
; 0003 0107             #endif
; 0003 0108             tmpbytes[i]=(tmpbytes[i]<<1)|(tmpbytes[i]>>7);  //ROL
_0x60064:
	MOVW R30,R20
	SUBI R30,LOW(-_tmpbytes)
	SBCI R31,HIGH(-_tmpbytes)
	MOVW R22,R30
	CALL SUBOPT_0x96
	LSL  R30
	MOV  R0,R30
	CALL SUBOPT_0x96
	CALL SUBOPT_0x97
; 0003 0109             tmpbytes[i]^=roll[(RollCounterToCheck)%ROLL_SIZE];        //XOR
	SUBI R30,LOW(-_tmpbytes)
	SBCI R31,HIGH(-_tmpbytes)
	MOVW R0,R30
	LD   R26,Z
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ANDI R30,LOW(0x3F)
	ANDI R31,HIGH(0x3F)
	SUBI R30,LOW(-_roll*2)
	SBCI R31,HIGH(-_roll*2)
	LPM  R30,Z
	EOR  R30,R26
	MOVW R26,R0
	ST   X,R30
; 0003 010A             #ifdef PRINT_DEBUG
; 0003 010B             if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6006B
; 0003 010C             while(tx_counter);
_0x6006C:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6006C
; 0003 010D             printf("\r\n%d=%02x, %c",i,tmpbytes[i],tmpbytes[i]);
	__POINTW1FN _0x60000,446
	CALL SUBOPT_0x94
	CALL SUBOPT_0x96
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x40
; 0003 010E             while(tx_counter);}
_0x6006F:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6006F
; 0003 010F             #endif
; 0003 0110        }
_0x6006B:
	__ADDWRN 20,21,1
	RJMP _0x60062
_0x60063:
; 0003 0111        if(strncmpf(tmpbytes,"[settings]",strlenf("[settings]"))==0)
	LDI  R30,LOW(_tmpbytes)
	LDI  R31,HIGH(_tmpbytes)
	CALL SUBOPT_0x92
	CALL SUBOPT_0x93
	ST   -Y,R30
	CALL _strncmpf
	CPI  R30,0
	BREQ _0x60059
; 0003 0112             break;
; 0003 0113        RollCounterToCheck++;
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0003 0114     }
	RJMP _0x60057
_0x60059:
; 0003 0115 
; 0003 0116     if(RollCounterToCheck >= (tmpimage.RollCounter+ROLL_WINDOW))//return null in case of reach roll counter window
	CALL SUBOPT_0x8E
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x60073
; 0003 0117          goto print_error;
	RJMP _0x60055
; 0003 0118     tmpimage.RollCounter=RollCounterToCheck;
_0x60073:
	LDD  R30,Y+6
	__PUTB1MN _tmpimage,92
; 0003 0119     for(i=0;i<(nbytes);i++)
	__GETWRN 20,21,0
_0x60075:
	CALL SUBOPT_0x8C
	CP   R20,R30
	CPC  R21,R31
	BRSH _0x60076
; 0003 011A     {
; 0003 011B         buffer[i]=(buffer[i]<<1)|(buffer[i]>>7);  //ROL
	MOVW R30,R20
	SUBI R30,LOW(-_buffer)
	SBCI R31,HIGH(-_buffer)
	MOVW R22,R30
	CALL SUBOPT_0x95
	LSL  R30
	MOV  R0,R30
	CALL SUBOPT_0x95
	CALL SUBOPT_0x97
; 0003 011C         buffer[i]^=roll[(tmpimage.RollCounter)%ROLL_SIZE];        //XOR
	CALL SUBOPT_0x98
; 0003 011D     }
	__ADDWRN 20,21,1
	RJMP _0x60075
_0x60076:
; 0003 011E      #ifdef PRINT_DEBUG
; 0003 011F      if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x60077
; 0003 0120      while(tx_counter);
_0x60078:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60078
; 0003 0121      buffer[nbytes-1]=0;
	CALL SUBOPT_0x8C
	SBIW R30,1
	CALL SUBOPT_0x8D
; 0003 0122      printf("\r\n%s",buffer);
	__POINTW1FN _0x60000,460
	CALL SUBOPT_0x50
	CALL SUBOPT_0x44
; 0003 0123      while(tx_counter);}
_0x6007B:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6007B
; 0003 0124      #endif
; 0003 0125     if((pkey=strstrf(buffer,"rollcounter"))==NULL){//try find the key "rollcounter"
_0x60077:
	CALL SUBOPT_0x8F
	__POINTW1FN _0x60000,465
	CALL SUBOPT_0x99
	SBIW R30,0
	BRNE _0x6007E
; 0003 0126          #ifdef PRINT_DEBUG
; 0003 0127          if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6007F
; 0003 0128          while(tx_counter);
_0x60080:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60080
; 0003 0129          printf("\r\n%p key not found.","rollcounter");
	__POINTW1FN _0x60000,477
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0x60000,465
	CALL SUBOPT_0x44
; 0003 012A          while(tx_counter);}
_0x60083:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60083
; 0003 012B          #endif
; 0003 012C          goto print_error;
_0x6007F:
	RJMP _0x60055
; 0003 012D     }
; 0003 012E     pvalue=pkey+(strlenf(Key)+1);//set the pointer to found Value
_0x6007E:
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0x9A
; 0003 012F     strncpy(tmpbytes,pvalue,32);//copy string from value pointer to tmpbytes 32 bytes
; 0003 0130     pvalue=tmpbytes;//set pointer to tmpbytes
; 0003 0131     pvalue[strpos(pvalue,'\r')]=NULL;//set string termination
; 0003 0132     #ifdef PRINT_DEBUG
; 0003 0133     if(debug){
	BREQ _0x60086
; 0003 0134     while(tx_counter);
_0x60087:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60087
; 0003 0135     printf("Found Key rollcounter");
	__POINTW1FN _0x60000,497
	CALL SUBOPT_0x22
; 0003 0136     while(tx_counter);}
_0x6008A:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6008A
; 0003 0137     #endif
; 0003 0138     return pvalue;//return the pointer to value
_0x60086:
	MOVW R30,R16
	RJMP _0x20C001A
; 0003 0139 print_error:
_0x60055:
; 0003 013A     #ifndef  PETITFATFS
; 0003 013B     f_close(&file);
; 0003 013C     #endif
; 0003 013D     RESerror(res);
	CALL SUBOPT_0x8B
; 0003 013E     #ifdef PRINT_LCD
; 0003 013F     //lcd_putsf_row(1,"No project file");
; 0003 0140     #endif
; 0003 0141     return NULL;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20C001A:
	CALL __LOADLOCR6
	ADIW R28,11
	RET
; 0003 0142 }
; .FEND
;
;/*Get string value from key string after '=' Key=Value\r\n */
;char *GetValue(flash char *Key)
; 0003 0146 {
_GetValue:
; .FSTART _GetValue
; 0003 0147     char *pvalue=NULL,*pkey;
; 0003 0148     StandaloneMode=IDLE;
	CALL SUBOPT_0x9B
;	*Key -> Y+4
;	*pvalue -> R16,R17
;	*pkey -> R18,R19
	LDI  R30,LOW(0)
	STS  _StandaloneMode,R30
; 0003 0149     pkey=strstrf(&buffer[0],Key);
	CALL SUBOPT_0x8F
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x99
; 0003 014A     if(pkey==NULL){
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x6008D
; 0003 014B          #ifdef PRINT_DEBUG
; 0003 014C          if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x6008E
; 0003 014D          while(tx_counter);
_0x6008F:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6008F
; 0003 014E          printf("\r\n%p Key not found.",Key);
	CALL SUBOPT_0x9C
; 0003 014F          while(tx_counter);}
_0x60092:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60092
; 0003 0150          #endif
; 0003 0151          goto print_error;
_0x6008E:
	RJMP _0x60095
; 0003 0152     }
; 0003 0153     pvalue=pkey+(strlenf(Key)+1);
_0x6008D:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x9A
; 0003 0154     strncpy(tmpbytes,pvalue,32);//copy string from value pointer to tmpbytes 32 bytes
; 0003 0155     pvalue=tmpbytes;//set pointer to tmpbytes
; 0003 0156     pvalue[strpos(pvalue,'\r')]=NULL;
; 0003 0157     #ifdef PRINT_DEBUG
; 0003 0158     if(debug){
	BREQ _0x60096
; 0003 0159     while(tx_counter);
_0x60097:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x60097
; 0003 015A     printf("\r\nFound Key %p=%s.",Key,pvalue);
	__POINTW1FN _0x60000,539
	CALL SUBOPT_0x9D
; 0003 015B     while(tx_counter);}
_0x6009A:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x6009A
; 0003 015C     #endif
; 0003 015D     return pvalue;//return the pointer to value
_0x60096:
	RJMP _0x20C0015
; 0003 015E print_error:
_0x60095:
; 0003 015F     #ifndef  PETITFATFS
; 0003 0160     f_close(&file);
; 0003 0161     #endif
; 0003 0162     RESerror(res);
	CALL SUBOPT_0x8B
; 0003 0163     return pvalue;
	RJMP _0x20C0015
; 0003 0164 }
; .FEND
;
;UCHAR fileOpen()
; 0003 0167 {
_fileOpen:
; .FSTART _fileOpen
; 0003 0168     UCHAR retry=3;
; 0003 0169     /* open the file in read mode */
; 0003 016A     #ifndef  PETITFATFS
; 0003 016B     strcpyf(path,"0:/1/project.txt");
; 0003 016C     path[3]=dirnum+'0';
; 0003 016D     #else
; 0003 016E     //strcpyf(path,"/00/00.dat");
; 0003 016F     strcpyf(path,"/");
	ST   -Y,R17
;	retry -> R17
	LDI  R17,3
	CALL SUBOPT_0x9E
	__POINTW1FN _0x60000,558
	CALL SUBOPT_0x9F
; 0003 0170     itoa(dirnum,tmpbytes);
	LDS  R30,_dirnum
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xA0
	CALL _itoa
; 0003 0171     strcat(path,tmpbytes);// "/1"
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA0
	CALL _strcat
; 0003 0172     strcatf(path,"/");// "/1/"
	CALL SUBOPT_0x9E
	__POINTW1FN _0x60000,558
	ST   -Y,R31
	ST   -Y,R30
	CALL _strcatf
; 0003 0173     strcat(path,tmpbytes);// "/1/1"
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA0
	CALL _strcat
; 0003 0174     strcatf(path,".dat");// "/1/1.dat"
	CALL SUBOPT_0x9E
	__POINTW1FN _0x60000,560
	ST   -Y,R31
	ST   -Y,R30
	CALL _strcatf
; 0003 0175     #endif
; 0003 0176     while(retry)
_0x6009D:
	CPI  R17,0
	BREQ _0x6009F
; 0003 0177     {
; 0003 0178         retry--;
	SUBI R17,1
; 0003 0179         /* open the file in read mode */
; 0003 017A         #ifndef  PETITFATFS
; 0003 017B         if((res=f_open(&file,path,FA_READ|FA_OPEN_EXISTING))==FR_OK)
; 0003 017C         #else
; 0003 017D         if ((res=pf_open(path))==FR_OK)
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
	BRNE _0x600A0
; 0003 017E         #endif
; 0003 017F         {
; 0003 0180             #ifdef PRINT_DEBUG
; 0003 0181             if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600A1
; 0003 0182             while(tx_counter);
_0x600A2:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600A2
; 0003 0183             printf("\r\nFile %s opened OK.\r\n",path);
	CALL SUBOPT_0xA2
; 0003 0184             //printf("\r\n%s key to find - %p",CopyKey,Key);
; 0003 0185             while(tx_counter);}
_0x600A5:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600A5
; 0003 0186             #endif
; 0003 0187             #ifdef  PETITFATFS
; 0003 0188             if((res=pf_lseek(0))!=FR_OK)
_0x600A1:
	CALL SUBOPT_0xA3
	BRNE _0x600A9
; 0003 0189                 goto print_error;//RESerror(res);
; 0003 018A             #endif
; 0003 018B             break;
	RJMP _0x6009F
; 0003 018C         }
; 0003 018D         else{
_0x600A0:
; 0003 018E            /* an error occured, display it and stop */
; 0003 018F            #ifdef PRINT_DEBUG
; 0003 0190            if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600AB
; 0003 0191            while(tx_counter);
_0x600AC:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600AC
; 0003 0192            printf("\r\nWrong path: %s\r\n",path);
	CALL SUBOPT_0xA4
; 0003 0193            while(tx_counter);}
_0x600AF:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600AF
; 0003 0194            #endif
; 0003 0195            if(retry)
_0x600AB:
	CPI  R17,0
	BRNE _0x6009D
; 0003 0196                 continue;
; 0003 0197            else
; 0003 0198                 goto print_error;//RESerror(res);
	RJMP _0x600A9
; 0003 0199         }
; 0003 019A     }
_0x6009F:
; 0003 019B     return 1;
	LDI  R30,LOW(1)
	RJMP _0x20C0013
; 0003 019C print_error:
_0x600A9:
; 0003 019D     RESerror(res);
	CALL SUBOPT_0x8B
; 0003 019E     return 0;
	LDI  R30,LOW(0)
	RJMP _0x20C0013
; 0003 019F }
; .FEND
;UCHAR SetFlashArea()
; 0003 01A1 {
_SetFlashArea:
; .FSTART _SetFlashArea
; 0003 01A2    #ifdef  PETITFATFS
; 0003 01A3    if((res=pf_lseek(1000))!=FR_OK){
	__GETD1N 0x3E8
	CALL __PUTPARD1
	CALL _pf_lseek
	STS  _res,R30
	CPI  R30,0
	BRNE _0x20C0019
; 0003 01A4         RESerror(res);
; 0003 01A5         return FALSE;
; 0003 01A6    }
; 0003 01A7    #endif
; 0003 01A8    return TRUE;
	RJMP _0x20C0018
; 0003 01A9 }
; .FEND
;UCHAR SetConfigArea()
; 0003 01AB {
_SetConfigArea:
; .FSTART _SetConfigArea
; 0003 01AC    #ifdef  PETITFATFS
; 0003 01AD    if((res=pf_lseek(0))!=FR_OK){
	CALL SUBOPT_0xA3
	BREQ _0x600B5
; 0003 01AE         RESerror(res);
_0x20C0019:
	LDS  R30,_res
	ST   -Y,R30
	RCALL _RESerror
; 0003 01AF         return FALSE;
	LDI  R30,LOW(0)
	RET
; 0003 01B0    }
; 0003 01B1    #endif
; 0003 01B2    return TRUE;
_0x600B5:
_0x20C0018:
	LDI  R30,LOW(1)
	RET
; 0003 01B3 }
; .FEND
;UCHAR fileRead(void)
; 0003 01B5 {
_fileRead:
; .FSTART _fileRead
; 0003 01B6     /* read and display the file's content.
; 0003 01B7        make sure to leave space for a NULL terminator
; 0003 01B8        in the buffer, so maximum sizeof(buffer)-1 bytes can be read */
; 0003 01B9     UINT  i;//buffer index
; 0003 01BA     #ifndef  PETITFATFS
; 0003 01BB     res=f_read(&file,buffer,sizeof(buffer),&nbytes);
; 0003 01BC     #else
; 0003 01BD     res=pf_read(buffer,sizeof(buffer),&nbytes);
	ST   -Y,R17
	ST   -Y,R16
;	i -> R16,R17
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x90
; 0003 01BE     #endif
; 0003 01BF     if ((res)==FR_OK){ //
	BRNE _0x600B6
; 0003 01C0 
; 0003 01C1        for(i=0;i<(nbytes);i++)
	__GETWRN 16,17,0
_0x600B8:
	CALL SUBOPT_0x8C
	CP   R16,R30
	CPC  R17,R31
	BRSH _0x600B9
; 0003 01C2        {
; 0003 01C3             buffer[i]=(buffer[i]<<1)|(buffer[i]>>7);  //ROL
	MOVW R30,R16
	SUBI R30,LOW(-_buffer)
	SBCI R31,HIGH(-_buffer)
	MOVW R22,R30
	LDI  R26,LOW(_buffer)
	LDI  R27,HIGH(_buffer)
	ADD  R26,R16
	ADC  R27,R17
	LD   R30,X
	LSL  R30
	MOV  R0,R30
	LDI  R26,LOW(_buffer)
	LDI  R27,HIGH(_buffer)
	ADD  R26,R16
	ADC  R27,R17
	LD   R30,X
	ROL  R30
	LDI  R30,0
	ROL  R30
	OR   R30,R0
	MOVW R26,R22
	ST   X,R30
; 0003 01C4             buffer[i]^=roll[(tmpimage.RollCounter)%ROLL_SIZE];        //XOR
	MOVW R30,R16
	CALL SUBOPT_0x98
; 0003 01C5        }
	__ADDWRN 16,17,1
	RJMP _0x600B8
_0x600B9:
; 0003 01C6     }
; 0003 01C7     else
	RJMP _0x600BA
_0x600B6:
; 0003 01C8         goto print_error;
	RJMP _0x600BB
; 0003 01C9     //buffer[nbytes]=NULL;
; 0003 01CA     nbytesCounter=0;
_0x600BA:
	LDI  R30,LOW(0)
	STS  _nbytesCounter,R30
	STS  _nbytesCounter+1,R30
; 0003 01CB     return 1;
	LDI  R30,LOW(1)
	RJMP _0x20C0017
; 0003 01CC print_error:
_0x600BB:
; 0003 01CD     RESerror(res);
	CALL SUBOPT_0x8B
; 0003 01CE     return 0;
	LDI  R30,LOW(0)
_0x20C0017:
	LD   R16,Y+
	LD   R17,Y+
	RET
; 0003 01CF }
; .FEND
;void fileClose(void)
; 0003 01D1 {
_fileClose:
; .FSTART _fileClose
; 0003 01D2     /* close the file */
; 0003 01D3     #ifndef  PETITFATFS
; 0003 01D4     if ((res=f_close(&file))==FR_OK)
; 0003 01D5     {
; 0003 01D6        #ifdef PRINT_DEBUG
; 0003 01D7        if(debug){
; 0003 01D8        printf("\r\nFile %s closed OK.",path);
; 0003 01D9        while(tx_counter);}
; 0003 01DA        #endif
; 0003 01DB     }
; 0003 01DC     else
; 0003 01DD        /* an error occured, display it and stop */
; 0003 01DE        RESerror(res);
; 0003 01DF     #endif
; 0003 01E0 }
	RET
; .FEND
;UCHAR pgm_read_byte_sd(void)
; 0003 01E2 {
_pgm_read_byte_sd:
; .FSTART _pgm_read_byte_sd
; 0003 01E3    UCHAR result;
; 0003 01E4    if(nbytesCounter>=nbytes){
	ST   -Y,R17
;	result -> R17
	CALL SUBOPT_0x8C
	LDS  R26,_nbytesCounter
	LDS  R27,_nbytesCounter+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x600BC
; 0003 01E5     fileRead();
	RCALL _fileRead
; 0003 01E6    }
; 0003 01E7    result=buffer[nbytesCounter++];
_0x600BC:
	LDI  R26,LOW(_nbytesCounter)
	LDI  R27,HIGH(_nbytesCounter)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	SBIW R30,1
	SUBI R30,LOW(-_buffer)
	SBCI R31,HIGH(-_buffer)
	LD   R17,Z
; 0003 01E8    return result;
	RJMP _0x20C0012
; 0003 01E9 }
; .FEND
;
;/*Get string value from key string after '=' Key=Value\r\n */
;char *GetConfigValue(flash char *Key)
; 0003 01ED {
_GetConfigValue:
; .FSTART _GetConfigValue
; 0003 01EE     char *pvalue=NULL,*pkey;
; 0003 01EF     #ifndef  PETITFATFS
; 0003 01F0     strcpyf(path,"0:/config.ini");
; 0003 01F1     #else
; 0003 01F2     strcpyf(path,"/config.ini");
	CALL SUBOPT_0x9B
;	*Key -> Y+4
;	*pvalue -> R16,R17
;	*pkey -> R18,R19
	CALL SUBOPT_0x9E
	__POINTW1FN _0x60000,607
	CALL SUBOPT_0x9F
; 0003 01F3     #endif
; 0003 01F4     /* open the file in read mode */
; 0003 01F5     #ifndef  PETITFATFS
; 0003 01F6     if((res=f_open(&file,path,FA_READ|FA_OPEN_EXISTING))==FR_OK)
; 0003 01F7     #else
; 0003 01F8     if ((res=pf_open(path))==FR_OK)
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
	BRNE _0x600BD
; 0003 01F9     #endif
; 0003 01FA     {
; 0003 01FB        #ifdef PRINT_DEBUG
; 0003 01FC        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600BE
; 0003 01FD        while(tx_counter);
_0x600BF:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600BF
; 0003 01FE        printf("\r\nFile %s opened OK.\r\n",path);
	CALL SUBOPT_0xA2
; 0003 01FF        while(tx_counter);}
_0x600C2:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600C2
; 0003 0200        #endif
; 0003 0201     }
_0x600BE:
; 0003 0202     else{
	RJMP _0x600C5
_0x600BD:
; 0003 0203        /* an error occured, display it and stop */
; 0003 0204        #ifdef PRINT_DEBUG
; 0003 0205        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600C6
; 0003 0206        while(tx_counter);
_0x600C7:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600C7
; 0003 0207        printf("\r\nWrong path: %s\r\n",path);
	CALL SUBOPT_0xA4
; 0003 0208        while(tx_counter);}
_0x600CA:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600CA
; 0003 0209        #endif
; 0003 020A        goto print_error;//RESerror(res);
_0x600C6:
	RJMP _0x600CD
; 0003 020B     }
_0x600C5:
; 0003 020C     #ifdef  PETITFATFS
; 0003 020D     if((res=pf_lseek(0))!=FR_OK)
	CALL SUBOPT_0xA3
	BREQ _0x600CE
; 0003 020E        goto print_error;//RESerror(res);
	RJMP _0x600CD
; 0003 020F     #endif
; 0003 0210     /* read and display the file's content.
; 0003 0211        make sure to leave space for a NULL terminator
; 0003 0212        in the buffer, so maximum sizeof(buffer)-1 bytes can be read */
; 0003 0213     #ifndef  PETITFATFS
; 0003 0214     if((res=f_read(&file,buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
; 0003 0215     #else
; 0003 0216     if((res=pf_read(buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
_0x600CE:
	CALL SUBOPT_0x8F
	CALL SUBOPT_0xA5
	BREQ PC+2
	RJMP _0x600CF
; 0003 0217     #endif
; 0003 0218     {
; 0003 0219        buffer[nbytes]=NULL;
	CALL SUBOPT_0x8C
	CALL SUBOPT_0x8D
; 0003 021A        if((pkey=strstrf(buffer,Key))==NULL){
	CALL SUBOPT_0x8F
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x99
	SBIW R30,0
	BRNE _0x600D0
; 0003 021B              #ifdef PRINT_DEBUG
; 0003 021C              if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600D1
; 0003 021D              while(tx_counter);
_0x600D2:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600D2
; 0003 021E              printf("\r\n%p Key not found.",Key);
	CALL SUBOPT_0x9C
; 0003 021F              while(tx_counter);}
_0x600D5:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600D5
; 0003 0220              #endif
; 0003 0221              goto print_error;
_0x600D1:
	RJMP _0x600CD
; 0003 0222        }
; 0003 0223        pvalue=pkey+(strlenf(Key)+1);
_0x600D0:
	CALL SUBOPT_0xA6
	CALL SUBOPT_0xA7
; 0003 0224        strncpy(tmpbytes,pvalue,32);//copy string from value pointer to tmpbytes 32 bytes
	CALL SUBOPT_0xA0
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL _strncpy
; 0003 0225        pvalue=tmpbytes;//set pointer to tmpbytes
	__POINTWRM 16,17,_tmpbytes
; 0003 0226        pvalue[strpos(pvalue,'\r')]=NULL;
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(13)
	ST   -Y,R30
	CALL _strpos
	ADD  R30,R16
	ADC  R31,R17
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0003 0227        #ifdef PRINT_DEBUG
; 0003 0228        while(tx_counter);
_0x600D8:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600D8
; 0003 0229        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600DB
; 0003 022A        while(tx_counter);
_0x600DC:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600DC
; 0003 022B        printf(" Found Key %p=%s.\r\n",Key,pvalue);
	__POINTW1FN _0x60000,619
	CALL SUBOPT_0x9D
; 0003 022C        while(tx_counter);}
_0x600DF:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600DF
; 0003 022D        #endif
; 0003 022E     }
_0x600DB:
; 0003 022F     else
	RJMP _0x600E2
_0x600CF:
; 0003 0230         goto print_error;
	RJMP _0x600CD
; 0003 0231     /* close the file */
; 0003 0232     #ifndef  PETITFATFS
; 0003 0233     if ((res=f_close(&file))==FR_OK)
; 0003 0234     {
; 0003 0235        #ifdef PRINT_DEBUG
; 0003 0236        if(debug){
; 0003 0237        while(tx_counter);
; 0003 0238        printf("\r\nFile %s closed OK.\r\n",path);
; 0003 0239        while(tx_counter);}
; 0003 023A        #endif
; 0003 023B     }
; 0003 023C     else
; 0003 023D        /* an error occured, display it and stop */
; 0003 023E        goto print_error;//RESerror(res);
; 0003 023F     #endif
; 0003 0240     //goto print_error;//return the pointer to value
; 0003 0241     return pvalue;
_0x600E2:
	RJMP _0x20C0015
; 0003 0242 print_error:
_0x600CD:
; 0003 0243     #ifndef  PETITFATFS
; 0003 0244     f_close(&file);
; 0003 0245     RESerror(res);
; 0003 0246     #endif
; 0003 0247     #ifdef PRINT_LCD;
; 0003 0248     lcd_putsf_row(1,"No config.ini");
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x60000,639
	CALL SUBOPT_0xC
; 0003 0249     #endif
; 0003 024A     return pvalue;
_0x20C0015:
	MOVW R30,R16
	CALL __LOADLOCR4
_0x20C0016:
	ADIW R28,6
	RET
; 0003 024B }
; .FEND
;
;/*Set string value from key string after '=' Key=Value\r\n */
;UCHAR SetValueReady(flash char *Key,const char ready_val)
; 0003 024F {
_SetValueReady:
; .FSTART _SetValueReady
; 0003 0250     char *pvalue=NULL,*pkey;
; 0003 0251     #ifndef  PETITFATFS
; 0003 0252     strcpyf(path,"0:/1/project.txt");
; 0003 0253     path[3]=dirnum+'0';
; 0003 0254     #else
; 0003 0255     strcpyf(path,"/1/project.txt");
	CALL SUBOPT_0x9B
;	*Key -> Y+5
;	ready_val -> Y+4
;	*pvalue -> R16,R17
;	*pkey -> R18,R19
	CALL SUBOPT_0x9E
	__POINTW1FN _0x60000,653
	CALL SUBOPT_0x9F
; 0003 0256     path[1]=dirnum+'0';
	LDS  R30,_dirnum
	SUBI R30,-LOW(48)
	__PUTB1MN _path,1
; 0003 0257     #endif
; 0003 0258     /* open the file in read mode */
; 0003 0259     #ifndef  PETITFATFS
; 0003 025A     if((res=f_open(&file,path,FA_READ|FA_OPEN_EXISTING))==FR_OK)
; 0003 025B     #else
; 0003 025C     if ((res=pf_open(path))==FR_OK)
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
	BRNE _0x600E3
; 0003 025D     #endif
; 0003 025E     {
; 0003 025F        #ifdef PRINT_DEBUG
; 0003 0260        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600E4
; 0003 0261        printf("\r\nFile %s opened OK.\r\n",path);
	CALL SUBOPT_0xA2
; 0003 0262        while(tx_counter);}
_0x600E5:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600E5
; 0003 0263        #endif
; 0003 0264     }
_0x600E4:
; 0003 0265     else{
	RJMP _0x600E8
_0x600E3:
; 0003 0266        /* an error occured, display it and stop */
; 0003 0267        #ifdef PRINT_DEBUG
; 0003 0268        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600E9
; 0003 0269        printf("\r\nwrong path: %s\r\n",path);
	__POINTW1FN _0x60000,668
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_path)
	LDI  R31,HIGH(_path)
	CALL SUBOPT_0x44
; 0003 026A        while(tx_counter);}
_0x600EA:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600EA
; 0003 026B        #endif
; 0003 026C        goto print_error;//RESerror(res);
_0x600E9:
	RJMP _0x600ED
; 0003 026D     }
_0x600E8:
; 0003 026E     #ifdef  PETITFATFS
; 0003 026F     if((res=pf_lseek(0))!=FR_OK)
	CALL SUBOPT_0xA3
	BREQ _0x600EE
; 0003 0270        goto print_error;//RESerror(res);
	RJMP _0x600ED
; 0003 0271     #endif
; 0003 0272     /* read and display the file's content.
; 0003 0273        make sure to leave space for a NULL terminator
; 0003 0274        in the buffer, so maximum sizeof(buffer)-1 bytes can be read */
; 0003 0275     #ifndef  PETITFATFS
; 0003 0276     if((res=f_read(&file,buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
; 0003 0277     #else
; 0003 0278     if((res=pf_read(buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
_0x600EE:
	CALL SUBOPT_0x8F
	CALL SUBOPT_0xA5
	BREQ PC+2
	RJMP _0x600EF
; 0003 0279     #endif
; 0003 027A     {
; 0003 027B        buffer[nbytes]=NULL;
	CALL SUBOPT_0x8C
	CALL SUBOPT_0x8D
; 0003 027C        if((pkey=strstrf(buffer,Key))==NULL){
	CALL SUBOPT_0x8F
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	CALL SUBOPT_0x99
	SBIW R30,0
	BRNE _0x600F0
; 0003 027D              #ifdef PRINT_DEBUG
; 0003 027E              if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600F1
; 0003 027F              printf("\r\n%p key not found.",Key);
	__POINTW1FN _0x60000,477
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	CALL SUBOPT_0x44
; 0003 0280              while(tx_counter);}
_0x600F2:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600F2
; 0003 0281              #endif
; 0003 0282              goto print_error;
_0x600F1:
	RJMP _0x600ED
; 0003 0283        }
; 0003 0284        pvalue=pkey+(strlenf(Key)+1);
_0x600F0:
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xA7
; 0003 0285        *(pvalue+1)=ready_val;//=0xh
	LDD  R30,Y+4
	__PUTB1RNS 16,1
; 0003 0286        #ifdef  PETITFATFS
; 0003 0287        if((res=pf_lseek(0))!=FR_OK)
	CALL SUBOPT_0xA3
	BRNE _0x600ED
; 0003 0288             goto print_error;//RESerror(res);
; 0003 0289        if((res=pf_write(buffer,(nbytes-1),&nbytes))!=FR_OK)
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8C
	SBIW R30,1
	CALL SUBOPT_0xA8
	BRNE _0x600ED
; 0003 028A             goto print_error;
; 0003 028B        if((res=pf_write(0,0,&nbytes))!=FR_OK)
	CALL SUBOPT_0xA9
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	CALL SUBOPT_0xA8
	BRNE _0x600ED
; 0003 028C             goto print_error;
; 0003 028D        #endif
; 0003 028E        //pvalue[strpos(pvalue,'\r')]=NULL;
; 0003 028F        #ifdef PRINT_DEBUG
; 0003 0290        if(debug){
	LDS  R30,_debug
	CPI  R30,0
	BREQ _0x600F8
; 0003 0291        printf(" Found Key %p=%s.\r\n",Key,pvalue);
	__POINTW1FN _0x60000,619
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	MOVW R30,R16
	CALL SUBOPT_0x8A
; 0003 0292        while(tx_counter);}
_0x600F9:
	LDS  R30,_tx_counter
	CPI  R30,0
	BRNE _0x600F9
; 0003 0293        #endif
; 0003 0294     }
_0x600F8:
; 0003 0295     else
	RJMP _0x600FC
_0x600EF:
; 0003 0296         goto print_error;
	RJMP _0x600ED
; 0003 0297     /* close the file */
; 0003 0298     #ifndef  PETITFATFS
; 0003 0299     if ((res=f_close(&file))==FR_OK)
; 0003 029A     {
; 0003 029B        #ifdef PRINT_DEBUG
; 0003 029C        if(debug){
; 0003 029D        printf("\r\nFile %s closed OK.\r\n",path);
; 0003 029E        while(tx_counter);}
; 0003 029F        #endif
; 0003 02A0     }
; 0003 02A1     else
; 0003 02A2        /* an error occured, display it and stop */
; 0003 02A3        goto print_error;//RESerror(res);
; 0003 02A4     #endif
; 0003 02A5     //goto print_error;//return the pointer to value
; 0003 02A6     return TRUE;
_0x600FC:
	LDI  R30,LOW(1)
	CALL __LOADLOCR4
	RJMP _0x20C0011
; 0003 02A7 print_error:
_0x600ED:
; 0003 02A8     #ifndef  PETITFATFS
; 0003 02A9     f_close(&file);
; 0003 02AA     RESerror(res);
; 0003 02AB     #endif
; 0003 02AC     return FALSE;
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20C0011
; 0003 02AD }
; .FEND
;//-----------------------------------------------------------------------
;// PFF - Low level disk control module for ATmega32
;//-----------------------------------------------------------------------
;#define _WRITE_FUNC	1			//allow write operations
;
;#include "common.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif
;#include "diskio.h"
;#include "mmc.h"
;// Definitions for MMC/SDC connection
;
;//#define SD_INS  6
;//#define SD_WP   7
;
;// Definitions for MMC/SDC command
;#define CMD0	(0x40+0)	// GO_IDLE_STATE
;#define CMD1	(0x40+1)	// SEND_OP_COND (MMC)
;#define	ACMD41	(0xC0+41)	// SEND_OP_COND (SDC)
;#define CMD8	(0x40+8)	// SEND_IF_COND
;#define CMD16	(0x40+16)	// SET_BLOCKLEN
;#define CMD17	(0x40+17)	// READ_SINGLE_BLOCK
;#define CMD24	(0x40+24)	// WRITE_BLOCK
;#define CMD55	(0x40+55)	// APP_CMD
;#define CMD58	(0x40+58)	// READ_OCR
;
;//-----------------------------------------------------------------------
;// SPI functions
;//-----------------------------------------------------------------------
;#define hardware_spi // åñëè îïðåäåëåíî, òî spi àïïàðàòíûé
;
;#define SPI_PORTX PORTB
;#define SPI_DDRX DDRB
;
;#define SPI_MISO SD_DO
;#define SPI_MOSI SD_DI
;#define SPI_SCK SD_CLK
;#define SPI_SS SD_CS
;
;void INIT_SPI(void) {
; 0004 0026 void INIT_SPI(void) {

	.CSEG
_INIT_SPI:
; .FSTART _INIT_SPI
; 0004 0027 #ifdef hardware_spi
; 0004 0028 	/*íàñòðîéêà ïîðòîâ ââîäà-âûâîäà
; 0004 0029 	 âñå âûâîäû, êðîìå MISO âûõîäû*/
; 0004 002A 	SPI_DDRX |= (1 << SPI_MOSI) | (1 << SPI_SCK) | (1 << SPI_SS) | (0 << SPI_MISO);
	IN   R30,0x4
	ORI  R30,LOW(0x2C)
	OUT  0x4,R30
; 0004 002B 	SPI_PORTX |= (1 << SPI_MOSI) | (1 << SPI_SCK) | (1 << SPI_SS) | (1 << SPI_MISO);
	IN   R30,0x5
	ORI  R30,LOW(0x3C)
	OUT  0x5,R30
; 0004 002C 
; 0004 002D 	/*ðàçðåøåíèå spi,ñòàðøèé áèò âïåðåä,ìàñòåð, ðåæèì 0*/
; 0004 002E 	SPCR = (1 << SPE) | (0 << DORD) | (1 << MSTR) | (0 << CPOL) | (0 << CPHA) | (0 << SPR1) | (0 << SPR0);
	LDI  R30,LOW(80)
	OUT  0x2C,R30
; 0004 002F 	SPSR = (1 << SPI2X);
	LDI  R30,LOW(1)
	OUT  0x2D,R30
; 0004 0030 #else
; 0004 0031 	PORTB |= (1<<SD_CS) | (1<<SD_DO) | (1<<SD_DI)/* | (1<<SD_WP) | (1<<SD_INS)*/;
; 0004 0032 	DDRB |=(1<<SD_CS) | (1<<SD_DI) | (1<<SD_CLK);
; 0004 0033 #endif
; 0004 0034 }
	RET
; .FEND
;
;void xmit_spi(BYTE data) {		// Send a byte
; 0004 0036 void xmit_spi(BYTE data) {
_xmit_spi:
; .FSTART _xmit_spi
; 0004 0037 #ifdef hardware_spi
; 0004 0038 	SPDR = data;
;	data -> Y+0
	LD   R30,Y
	OUT  0x2E,R30
; 0004 0039 	while (!(SPSR & (1 << SPIF)));
_0x80003:
	IN   R30,0x2D
	ANDI R30,LOW(0x80)
	BREQ _0x80003
; 0004 003A #else
; 0004 003B 	BYTE i;
; 0004 003C 
; 0004 003D 	for (i = 0; i < 8; i++) {
; 0004 003E 		if ((data & 0x80) == 0x00)
; 0004 003F 			PORTB &= ~(1<<SD_DI);
; 0004 0040 		else
; 0004 0041 			PORTB |= (1<<SD_DI);
; 0004 0042 		data = data << 1;
; 0004 0043 		PORTB |= (1<<SD_CLK);
; 0004 0044 		#asm("nop")
; 0004 0045 		PORTB &= ~(1<<SD_CLK);
; 0004 0046 	}
; 0004 0047 #endif
; 0004 0048 }
_0x20C0014:
	ADIW R28,1
	RET
; .FEND
;
;BYTE rcv_spi(void) {				// Send 0xFF and receive a byte
; 0004 004A BYTE rcv_spi(void) {
_rcv_spi:
; .FSTART _rcv_spi
; 0004 004B #ifdef hardware_spi
; 0004 004C 	unsigned char data;
; 0004 004D 	SPDR = 0xFF;
	ST   -Y,R17
;	data -> R17
	LDI  R30,LOW(255)
	OUT  0x2E,R30
; 0004 004E 	while (!(SPSR & (1 << SPIF)));
_0x80006:
	IN   R30,0x2D
	ANDI R30,LOW(0x80)
	BREQ _0x80006
; 0004 004F 	data = SPDR;
	IN   R17,46
; 0004 0050 	return data;
_0x20C0012:
	MOV  R30,R17
_0x20C0013:
	LD   R17,Y+
	RET
; 0004 0051 #else
; 0004 0052 	BYTE i, res = 0;
; 0004 0053 
; 0004 0054 	PORTB |= (1<<SD_DI);
; 0004 0055 
; 0004 0056 	for (i = 0; i < 8; i++) {
; 0004 0057 		PORTB |= (1<<SD_CLK);
; 0004 0058 		res = res << 1;
; 0004 0059 		if ((PINB & (1<<SD_DO))!=0x00)
; 0004 005A 		res = res | 0x01;
; 0004 005B 		PORTB &= ~(1<<SD_CLK);
; 0004 005C 		#asm("nop")
; 0004 005D 	}
; 0004 005E 	return res;
; 0004 005F #endif
; 0004 0060 } /* Send 0xFF and receive a byte */
; .FEND
;//-----------------------------------------------------------------------
;
;
;
;//-----------------------------------------------------------------------
;//   Module Private Function
;//-----------------------------------------------------------------------
;static BYTE CardType;
;
;//-----------------------------------------------------------------------
;// Deselect the card and release SPI bus
;//-----------------------------------------------------------------------
;static
;void release_spi (void)
; 0004 006F {
_release_spi_G004:
; .FSTART _release_spi_G004
; 0004 0070 	rcv_spi();
	RCALL _rcv_spi
; 0004 0071 }
	RET
; .FEND
;
;//-----------------------------------------------------------------------
;// Send a command packet to MMC
;//-----------------------------------------------------------------------
;static
;BYTE send_cmd (
; 0004 0078 	BYTE cmd,		// Command byte
; 0004 0079 	DWORD arg		// Argument
; 0004 007A )
; 0004 007B {
_send_cmd_G004:
; .FSTART _send_cmd_G004
; 0004 007C 	BYTE n, res;
; 0004 007D 
; 0004 007E 
; 0004 007F 	if (cmd & 0x80) {	// ACMD<n> is the command sequense of CMD55-CMD<n>
	ST   -Y,R17
	ST   -Y,R16
;	cmd -> Y+6
;	arg -> Y+2
;	n -> R17
;	res -> R16
	LDD  R30,Y+6
	ANDI R30,LOW(0x80)
	BREQ _0x80009
; 0004 0080 		cmd &= 0x7F;
	LDD  R30,Y+6
	ANDI R30,0x7F
	STD  Y+6,R30
; 0004 0081 		res = send_cmd(CMD55, 0);
	LDI  R30,LOW(119)
	CALL SUBOPT_0xAA
	MOV  R16,R30
; 0004 0082 		if (res > 1) return res;
	CPI  R16,2
	BRSH _0x20C0010
; 0004 0083 	}
; 0004 0084 
; 0004 0085 	// Select the card
; 0004 0086 	DESELECT();
_0x80009:
	SBI  0x5,2
; 0004 0087 	rcv_spi();
	RCALL _rcv_spi
; 0004 0088 	SELECT();
	CBI  0x5,2
; 0004 0089 	rcv_spi();
	RCALL _rcv_spi
; 0004 008A 
; 0004 008B 	// Send a command packet
; 0004 008C 	xmit_spi(cmd);						// Start + Command index
	LDD  R30,Y+6
	CALL SUBOPT_0xAB
; 0004 008D 	xmit_spi((BYTE)(arg >> 24));		// Argument[31..24]
	LDI  R30,LOW(24)
	CALL __LSRD12
	ST   -Y,R30
	RCALL _xmit_spi
; 0004 008E 	xmit_spi((BYTE)(arg >> 16));		// Argument[23..16]
	CALL SUBOPT_0xAC
	CALL __LSRD16
	CALL SUBOPT_0xAB
; 0004 008F 	xmit_spi((BYTE)(arg >> 8));			// Argument[15..8]
	LDI  R30,LOW(8)
	CALL __LSRD12
	ST   -Y,R30
	RCALL _xmit_spi
; 0004 0090 	xmit_spi((BYTE)arg);				// Argument[7..0]
	LDD  R30,Y+2
	ST   -Y,R30
	RCALL _xmit_spi
; 0004 0091 	n = 0x01;							// Dummy CRC + Stop
	LDI  R17,LOW(1)
; 0004 0092 	if (cmd == CMD0) n = 0x95;			// Valid CRC for CMD0(0)
	LDD  R26,Y+6
	CPI  R26,LOW(0x40)
	BRNE _0x8000B
	LDI  R17,LOW(149)
; 0004 0093 	if (cmd == CMD8) n = 0x87;			// Valid CRC for CMD8(0x1AA)
_0x8000B:
	LDD  R26,Y+6
	CPI  R26,LOW(0x48)
	BRNE _0x8000C
	LDI  R17,LOW(135)
; 0004 0094 	xmit_spi(n);
_0x8000C:
	ST   -Y,R17
	RCALL _xmit_spi
; 0004 0095 
; 0004 0096 	// Receive a command response
; 0004 0097 	n = 10;								// Wait for a valid response in timeout of 10 attempts
	LDI  R17,LOW(10)
; 0004 0098 	do {
_0x8000E:
; 0004 0099 		res = rcv_spi();
	RCALL _rcv_spi
	MOV  R16,R30
; 0004 009A 	} while ((res & 0x80) && --n);
	SBRS R16,7
	RJMP _0x80010
	SUBI R17,LOW(1)
	BRNE _0x80011
_0x80010:
	RJMP _0x8000F
_0x80011:
	RJMP _0x8000E
_0x8000F:
; 0004 009B 
; 0004 009C 	return res;			// Return with the response value
_0x20C0010:
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20C0011:
	ADIW R28,7
	RET
; 0004 009D }
; .FEND
;
;//--------------------------------------------------------------------------
;//
;//   Public Functions
;//
;//--------------------------------------------------------------------------
;
;//--------------------------------------------------------------------------
;// Initialize Disk Drive
;//--------------------------------------------------------------------------
;DSTATUS disk_initialize (void)
; 0004 00A9 {
_disk_initialize:
; .FSTART _disk_initialize
; 0004 00AA 	BYTE n, cmd, ty, ocr[4];
; 0004 00AB 	WORD tmr;
; 0004 00AC 
; 0004 00AD 
; 0004 00AE 	INIT_SPI();
	SBIW R28,4
	CALL __SAVELOCR6
;	n -> R17
;	cmd -> R16
;	ty -> R19
;	ocr -> Y+6
;	tmr -> R20,R21
	RCALL _INIT_SPI
; 0004 00AF 
; 0004 00B0 //	if ((PINB&_BV(SD_INS))!=0x00) return STA_NOINIT;
; 0004 00B1 
; 0004 00B2 #if _WRITE_FUNC
; 0004 00B3 	if (MMC_SEL) disk_writep(0, 0);		// Finalize write process if it is in progress
	SBIC 0x5,2
	RJMP _0x80012
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xAD
	RCALL _disk_writep
; 0004 00B4 #endif
; 0004 00B5 	for (n = 100; n; n--) rcv_spi();	// Dummy clocks
_0x80012:
	LDI  R17,LOW(100)
_0x80014:
	CPI  R17,0
	BREQ _0x80015
	RCALL _rcv_spi
	SUBI R17,1
	RJMP _0x80014
_0x80015:
; 0004 00B7 ty = 0;
	LDI  R19,LOW(0)
; 0004 00B8 	if (send_cmd(CMD0, 0) == 1) {			// Enter Idle state
	LDI  R30,LOW(64)
	CALL SUBOPT_0xAA
	CPI  R30,LOW(0x1)
	BREQ PC+2
	RJMP _0x80016
; 0004 00B9 		if (send_cmd(CMD8, 0x1AA) == 1) {	// SDv2
	LDI  R30,LOW(72)
	ST   -Y,R30
	__GETD1N 0x1AA
	CALL SUBOPT_0xAE
	CPI  R30,LOW(0x1)
	BREQ PC+2
	RJMP _0x80017
; 0004 00BA 			for (n = 0; n < 4; n++) ocr[n] = rcv_spi();		// Get trailing return value of R7 resp
	LDI  R17,LOW(0)
_0x80019:
	CPI  R17,4
	BRSH _0x8001A
	CALL SUBOPT_0xAF
	PUSH R31
	PUSH R30
	RCALL _rcv_spi
	POP  R26
	POP  R27
	ST   X,R30
	SUBI R17,-1
	RJMP _0x80019
_0x8001A:
; 0004 00BB if (ocr[2] == 0x01 && ocr[3] == 0xAA) {
	LDD  R26,Y+8
	CPI  R26,LOW(0x1)
	BRNE _0x8001C
	LDD  R26,Y+9
	CPI  R26,LOW(0xAA)
	BREQ _0x8001D
_0x8001C:
	RJMP _0x8001B
_0x8001D:
; 0004 00BC 				for (tmr = 12000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) ;	// Wait for leaving idle state (ACMD41 with HCS bit)
	__GETWRN 20,21,12000
_0x8001F:
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x80021
	LDI  R30,LOW(233)
	ST   -Y,R30
	__GETD1N 0x40000000
	CALL SUBOPT_0xAE
	CPI  R30,0
	BRNE _0x80022
_0x80021:
	RJMP _0x80020
_0x80022:
	__SUBWRN 20,21,1
	RJMP _0x8001F
_0x80020:
; 0004 00BD 				if (tmr && send_cmd(CMD58, 0) == 0) {		// Check CCS bit in the OCR
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x80024
	LDI  R30,LOW(122)
	CALL SUBOPT_0xAA
	CPI  R30,0
	BREQ _0x80025
_0x80024:
	RJMP _0x80023
_0x80025:
; 0004 00BE 					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
	LDI  R17,LOW(0)
_0x80027:
	CPI  R17,4
	BRSH _0x80028
	CALL SUBOPT_0xAF
	PUSH R31
	PUSH R30
	RCALL _rcv_spi
	POP  R26
	POP  R27
	ST   X,R30
	SUBI R17,-1
	RJMP _0x80027
_0x80028:
; 0004 00BF ty = (ocr[0] & 0x40) ? 0x04	 | 0x08	 : 0x04	;
	LDD  R30,Y+6
	ANDI R30,LOW(0x40)
	BREQ _0x80029
	LDI  R30,LOW(12)
	RJMP _0x8002A
_0x80029:
	LDI  R30,LOW(4)
_0x8002A:
	MOV  R19,R30
; 0004 00C0 				}
; 0004 00C1 			}
_0x80023:
; 0004 00C2 		} else {							// SDv1 or MMCv3
_0x8001B:
	RJMP _0x8002C
_0x80017:
; 0004 00C3 			if (send_cmd(ACMD41, 0) <= 1) 	{
	LDI  R30,LOW(233)
	CALL SUBOPT_0xAA
	CPI  R30,LOW(0x2)
	BRSH _0x8002D
; 0004 00C4 				ty = CT_SD1; cmd = ACMD41;	// SDv1
	LDI  R19,LOW(2)
	LDI  R16,LOW(233)
; 0004 00C5 			} else {
	RJMP _0x8002E
_0x8002D:
; 0004 00C6 				ty = CT_MMC; cmd = CMD1;	// MMCv3
	LDI  R19,LOW(1)
	LDI  R16,LOW(65)
; 0004 00C7 			}
_0x8002E:
; 0004 00C8 			for (tmr = 25000; tmr && send_cmd(cmd, 0); tmr--) ;	// Wait for leaving idle state
	__GETWRN 20,21,25000
_0x80030:
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x80032
	ST   -Y,R16
	CALL SUBOPT_0xAD
	RCALL _send_cmd_G004
	CPI  R30,0
	BRNE _0x80033
_0x80032:
	RJMP _0x80031
_0x80033:
	__SUBWRN 20,21,1
	RJMP _0x80030
_0x80031:
; 0004 00C9 			if (!tmr || send_cmd(CMD16, 512) != 0)			// Set R/W block length to 512
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x80035
	LDI  R30,LOW(80)
	ST   -Y,R30
	CALL SUBOPT_0xB0
	CALL SUBOPT_0xAE
	CPI  R30,0
	BREQ _0x80034
_0x80035:
; 0004 00CA 				ty = 0;
	LDI  R19,LOW(0)
; 0004 00CB 		}
_0x80034:
_0x8002C:
; 0004 00CC 	}
; 0004 00CD 	CardType = ty;
_0x80016:
	STS  _CardType_G004,R19
; 0004 00CE 	release_spi();
	RCALL _release_spi_G004
; 0004 00CF 
; 0004 00D0 #ifdef hardware_spi
; 0004 00D1 	//äëÿ àïïàðàòíîãî SPI!!!--------------------------------------------
; 0004 00D2 	SPCR &= ~((1 << SPR1) | (1 << SPR0)); // óáèðàåì ïðåääåëèòåëü
	IN   R30,0x2C
	ANDI R30,LOW(0xFC)
	OUT  0x2C,R30
; 0004 00D3 	SPSR |= (1 << SPI2X); // óäâàèâàåì ÷àñòîòó
	IN   R30,0x2D
	ORI  R30,1
	OUT  0x2D,R30
; 0004 00D4 	//------------------------------------------------------------------
; 0004 00D5 #endif
; 0004 00D6 
; 0004 00D7 	return ty ? 0 : STA_NOINIT;
	CPI  R19,0
	BREQ _0x80037
	LDI  R30,LOW(0)
	RJMP _0x80038
_0x80037:
	LDI  R30,LOW(1)
_0x80038:
	CALL __LOADLOCR6
	RJMP _0x20C000D
; 0004 00D8 }
; .FEND
;//-----------------------------------------------------------------------
;// Read partial sector
;//-----------------------------------------------------------------------
;
;DRESULT disk_readp (
; 0004 00DE 	BYTE *buff,		// Pointer to the read buffer (NULL:Read bytes are forwarded to the stream)
; 0004 00DF 	DWORD lba,		// Sector number (LBA)
; 0004 00E0 	WORD ofs,		// Byte offset to read from (0..511)
; 0004 00E1 	WORD cnt		// Number of bytes to read (ofs + cnt mus be <= 512)
; 0004 00E2 )
; 0004 00E3 {
_disk_readp:
; .FSTART _disk_readp
; 0004 00E4 	DRESULT res;
; 0004 00E5 	BYTE rc;
; 0004 00E6 	WORD bc;
; 0004 00E7 
; 0004 00E8 //	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
; 0004 00E9 
; 0004 00EA 	if (!(CardType & CT_BLOCK)) lba *= 512;		// Convert to byte address if needed
	CALL __SAVELOCR4
;	*buff -> Y+12
;	lba -> Y+8
;	ofs -> Y+6
;	cnt -> Y+4
;	res -> R17
;	rc -> R16
;	bc -> R18,R19
	LDS  R30,_CardType_G004
	ANDI R30,LOW(0x8)
	BRNE _0x8003A
	CALL SUBOPT_0xB1
	CALL SUBOPT_0xB2
	CALL SUBOPT_0xB3
; 0004 00EB 
; 0004 00EC 	res = RES_ERROR;
_0x8003A:
	LDI  R17,LOW(1)
; 0004 00ED 	if (send_cmd(CMD17, lba) == 0) {		// READ_SINGLE_BLOCK
	LDI  R30,LOW(81)
	ST   -Y,R30
	CALL SUBOPT_0xB4
	CALL SUBOPT_0xAE
	CPI  R30,0
	BREQ PC+2
	RJMP _0x8003B
; 0004 00EE 
; 0004 00EF 		bc = 30000;
	__GETWRN 18,19,30000
; 0004 00F0 		do {							// Wait for data packet in timeout of 100ms
_0x8003D:
; 0004 00F1 			rc = rcv_spi();
	RCALL _rcv_spi
	MOV  R16,R30
; 0004 00F2 		} while (rc == 0xFF && --bc);
	CPI  R16,255
	BRNE _0x8003F
	__SUBWRN 18,19,1
	BRNE _0x80040
_0x8003F:
	RJMP _0x8003E
_0x80040:
	RJMP _0x8003D
_0x8003E:
; 0004 00F3 
; 0004 00F4 		if (rc == 0xFE) {				// A data packet arrived
	CPI  R16,254
	BRNE _0x80041
; 0004 00F5 			bc = 514 - ofs - cnt;
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(514)
	LDI  R31,HIGH(514)
	SUB  R30,R26
	SBC  R31,R27
	MOVW R26,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SUB  R26,R30
	SBC  R27,R31
	MOVW R18,R26
; 0004 00F6 
; 0004 00F7 			// Skip leading bytes
; 0004 00F8 			if (ofs) {
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,0
	BREQ _0x80042
; 0004 00F9 				do rcv_spi(); while (--ofs);
_0x80044:
	RCALL _rcv_spi
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	BRNE _0x80044
; 0004 00FA 			}
; 0004 00FB 
; 0004 00FC 			// Receive a part of the sector
; 0004 00FD 			if (buff) {	// Store data to the memory
_0x80042:
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	SBIW R30,0
	BREQ _0x80046
; 0004 00FE 				do
_0x80048:
; 0004 00FF 					*buff++ = rcv_spi();
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	ADIW R30,1
	STD  Y+12,R30
	STD  Y+12+1,R31
	SBIW R30,1
	PUSH R31
	PUSH R30
	RCALL _rcv_spi
	POP  R26
	POP  R27
	ST   X,R30
; 0004 0100 				while (--cnt);
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	BRNE _0x80048
; 0004 0101 			} else {	// Forward data to the outgoing stream (depends on the project)
	RJMP _0x8004A
_0x80046:
; 0004 0102 				do
_0x8004C:
; 0004 0103                 ;//uart_transmit(rcv_spi());		// (Console output)
; 0004 0104 				while (--cnt);
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	BRNE _0x8004C
; 0004 0105 			}
_0x8004A:
; 0004 0106 
; 0004 0107 			// Skip trailing bytes and CRC
; 0004 0108 			do rcv_spi(); while (--bc);
_0x8004F:
	RCALL _rcv_spi
	MOVW R30,R18
	SBIW R30,1
	MOVW R18,R30
	BRNE _0x8004F
; 0004 0109 
; 0004 010A 			res = RES_OK;
	LDI  R17,LOW(0)
; 0004 010B 		}
; 0004 010C 	}
_0x80041:
; 0004 010D 
; 0004 010E 	release_spi();
_0x8003B:
	RCALL _release_spi_G004
; 0004 010F 
; 0004 0110 	return res;
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20C000B
; 0004 0111 }
; .FEND
;
;//-----------------------------------------------------------------------
;// Write partial sector
;//-----------------------------------------------------------------------
;#if _WRITE_FUNC
;
;DRESULT disk_writep (
; 0004 0119 	const BYTE *buff,	// Pointer to the bytes to be written (NULL:Initiate/Finalize sector write)
; 0004 011A 	DWORD sa			// Number of bytes to send, Sector number (LBA) or zero
; 0004 011B )
; 0004 011C {
_disk_writep:
; .FSTART _disk_writep
; 0004 011D 	DRESULT res;
; 0004 011E 	WORD bc;
; 0004 011F 	static WORD wc;
; 0004 0120 
; 0004 0121 //	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
; 0004 0122 //	if ((PINB&_BV(SD_WP))!=0x00) return RES_ERROR;
; 0004 0123 
; 0004 0124 	res = RES_ERROR;
	CALL __SAVELOCR4
;	*buff -> Y+8
;	sa -> Y+4
;	res -> R17
;	bc -> R18,R19
	LDI  R17,LOW(1)
; 0004 0125 
; 0004 0126 	if (buff) {		// Send data bytes
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	SBIW R30,0
	BREQ _0x80051
; 0004 0127 		bc = (WORD)sa;
	__GETWRS 18,19,4
; 0004 0128 		while (bc && wc) {		// Send data bytes to the card
_0x80052:
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x80055
	LDS  R30,_wc_S0040007000
	LDS  R31,_wc_S0040007000+1
	SBIW R30,0
	BRNE _0x80056
_0x80055:
	RJMP _0x80054
_0x80056:
; 0004 0129 			xmit_spi(*buff++);
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LD   R30,X+
	STD  Y+8,R26
	STD  Y+8+1,R27
	ST   -Y,R30
	RCALL _xmit_spi
; 0004 012A 			wc--; bc--;
	LDI  R26,LOW(_wc_S0040007000)
	LDI  R27,HIGH(_wc_S0040007000)
	LD   R30,X+
	LD   R31,X+
	SBIW R30,1
	ST   -X,R31
	ST   -X,R30
	__SUBWRN 18,19,1
; 0004 012B 		}
	RJMP _0x80052
_0x80054:
; 0004 012C 		res = RES_OK;
	LDI  R17,LOW(0)
; 0004 012D 	} else {
	RJMP _0x80057
_0x80051:
; 0004 012E 		if (sa) {	// Initiate sector write process
	CALL SUBOPT_0x78
	CALL __CPD10
	BREQ _0x80058
; 0004 012F 			if (!(CardType & CT_BLOCK)) sa *= 512;	// Convert to byte address if needed
	LDS  R30,_CardType_G004
	ANDI R30,LOW(0x8)
	BRNE _0x80059
	CALL SUBOPT_0x78
	CALL SUBOPT_0xB2
	CALL SUBOPT_0x74
; 0004 0130 			if (send_cmd(CMD24, sa) == 0) {			// WRITE_SINGLE_BLOCK
_0x80059:
	LDI  R30,LOW(88)
	ST   -Y,R30
	__GETD1S 5
	CALL SUBOPT_0xAE
	CPI  R30,0
	BRNE _0x8005A
; 0004 0131 				xmit_spi(0xFF); xmit_spi(0xFE);		// Data block header
	LDI  R30,LOW(255)
	ST   -Y,R30
	RCALL _xmit_spi
	LDI  R30,LOW(254)
	ST   -Y,R30
	RCALL _xmit_spi
; 0004 0132 				wc = 512;							// Set byte counter
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	STS  _wc_S0040007000,R30
	STS  _wc_S0040007000+1,R31
; 0004 0133 				res = RES_OK;
	LDI  R17,LOW(0)
; 0004 0134 			}
; 0004 0135 		} else {	// Finalize sector write process
_0x8005A:
	RJMP _0x8005B
_0x80058:
; 0004 0136 			bc = wc + 2;
	LDS  R30,_wc_S0040007000
	LDS  R31,_wc_S0040007000+1
	ADIW R30,2
	MOVW R18,R30
; 0004 0137 			while (bc--) xmit_spi(0);	// Fill left bytes and CRC with zeros
_0x8005C:
	MOVW R30,R18
	__SUBWRN 18,19,1
	SBIW R30,0
	BREQ _0x8005E
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _xmit_spi
	RJMP _0x8005C
_0x8005E:
; 0004 0138 if ((rcv_spi() & 0x1F) == 0x05) {
	RCALL _rcv_spi
	ANDI R30,LOW(0x1F)
	CPI  R30,LOW(0x5)
	BRNE _0x8005F
; 0004 0139 				for (bc = 65000; rcv_spi() != 0xFF && bc; bc--) ;	// Wait ready
	__GETWRN 18,19,-536
_0x80061:
	RCALL _rcv_spi
	CPI  R30,LOW(0xFF)
	BREQ _0x80063
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x80064
_0x80063:
	RJMP _0x80062
_0x80064:
	__SUBWRN 18,19,1
	RJMP _0x80061
_0x80062:
; 0004 013A 				if (bc) res = RES_OK;
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x80065
	LDI  R17,LOW(0)
; 0004 013B 			}
_0x80065:
; 0004 013C 			release_spi();
_0x8005F:
	RCALL _release_spi_G004
; 0004 013D 		}
_0x8005B:
; 0004 013E 	}
_0x80057:
; 0004 013F 
; 0004 0140 	return res;
	MOV  R30,R17
	RJMP _0x20C000C
; 0004 0141 }
; .FEND
;#endif
;/*----------------------------------------------------------------------------/
;/  Petit FatFs - FAT file system module  R0.02                 (C)ChaN, 2009
;/-----------------------------------------------------------------------------/
;/ Petit FatFs module is an open source software to implement FAT file system to
;/ small embedded systems. This is a free software and is opened for education,
;/ research and commercial developments under license policy of following trems.
;/
;/  Copyright (C) 2009, ChaN, all right reserved.
;/
;/ * The Petit FatFs module is a free software and there is NO WARRANTY.
;/ * No restriction on use. You can use, modify and redistribute it for
;/   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
;/ * Redistributions of source code must retain the above copyright notice.
;/
;/-----------------------------------------------------------------------------/
;/ Jun 15,'09  R0.01a  First release. (Branched from FatFs R0.07b.)
;/
;/ Dec 14,'09  R0.02   Added multiple code page support.
;/                     Added write funciton.
;/                     Changed stream read mode interface.
;/----------------------------------------------------------------------------*/
;
;#include "pff.h"		/* Petit FatFs configurations and declarations */
;#include "diskio.h"		/* Declarations of low level disk I/O functions */
;
;
;/*--------------------------------------------------------------------------
;
;   Private Functions
;
;---------------------------------------------------------------------------*/
;
;static
;FATFS *FatFs;	/* Pointer to the file system object (logical drive) */
;
;
;
;/*-----------------------------------------------------------------------*/
;/* String functions                                                      */
;/*-----------------------------------------------------------------------*/
;
;/* Fill memory */
;static
;void mem_set (void* dst, int val, int cnt) {
; 0005 002C void mem_set (void* dst, int val, int cnt) {

	.CSEG
_mem_set_G005:
; .FSTART _mem_set_G005
; 0005 002D 	char *d = (char*)dst;
; 0005 002E 	while (cnt--) *d++ = (char)val;
	ST   -Y,R17
	ST   -Y,R16
;	*dst -> Y+6
;	val -> Y+4
;	cnt -> Y+2
;	*d -> R16,R17
	__GETWRS 16,17,6
_0xA0003:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,1
	STD  Y+2,R30
	STD  Y+2+1,R31
	ADIW R30,1
	BREQ _0xA0005
	PUSH R17
	PUSH R16
	__ADDWRN 16,17,1
	LDD  R30,Y+4
	POP  R26
	POP  R27
	ST   X,R30
	RJMP _0xA0003
_0xA0005:
; 0005 002F }
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C000A
; .FEND
;
;/* Compare memory to memory */
;static
;int mem_cmp (const void* dst, const void* src, int cnt) {
; 0005 0033 int mem_cmp (const void* dst, const void* src, int cnt) {
_mem_cmp_G005:
; .FSTART _mem_cmp_G005
; 0005 0034 	const char *d = (const char *)dst, *s = (const char *)src;
; 0005 0035 	int r = 0;
; 0005 0036 	while (cnt-- && (r = *d++ - *s++) == 0) ;
	CALL __SAVELOCR6
;	*dst -> Y+10
;	*src -> Y+8
;	cnt -> Y+6
;	*d -> R16,R17
;	*s -> R18,R19
;	r -> R20,R21
	__GETWRS 16,17,10
	__GETWRS 18,19,8
	__GETWRN 20,21,0
_0xA0006:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	ADIW R30,1
	BREQ _0xA0009
	MOVW R26,R16
	__ADDWRN 16,17,1
	LD   R30,X
	LDI  R31,0
	SBRC R30,7
	SER  R31
	MOVW R0,R30
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	LDI  R31,0
	SBRC R30,7
	SER  R31
	MOVW R26,R30
	MOVW R30,R0
	SUB  R30,R26
	SBC  R31,R27
	MOVW R20,R30
	SBIW R30,0
	BREQ _0xA000A
_0xA0009:
	RJMP _0xA0008
_0xA000A:
	RJMP _0xA0006
_0xA0008:
; 0005 0037 	return r;
	MOVW R30,R20
	CALL __LOADLOCR6
	ADIW R28,12
	RET
; 0005 0038 }
; .FEND
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT access - Read value of a FAT entry                                */
;/*-----------------------------------------------------------------------*/
;
;static
;CLUST get_fat (	/* 1:IO error, Else:Cluster status */
; 0005 0042 	CLUST clst	/* Cluster# to get the link information */
; 0005 0043 )
; 0005 0044 {
_get_fat_G005:
; .FSTART _get_fat_G005
; 0005 0045 	WORD wc, bc, ofs;
; 0005 0046 	BYTE buf[4];
; 0005 0047 	FATFS *fs = FatFs;
; 0005 0048 
; 0005 0049 
; 0005 004A 	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
	SBIW R28,6
	CALL __SAVELOCR6
;	clst -> Y+12
;	wc -> R16,R17
;	bc -> R18,R19
;	ofs -> R20,R21
;	buf -> Y+8
;	*fs -> Y+6
	CALL SUBOPT_0xB5
	STD  Y+6,R30
	STD  Y+6+1,R31
	CALL SUBOPT_0xB6
	CALL SUBOPT_0xB7
	BRLO _0xA000C
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0xB6
	CALL __CPD21
	BRLO _0xA000B
_0xA000C:
; 0005 004B 		return 1;
	RJMP _0x20C000F
; 0005 004C 
; 0005 004D 	switch (fs->fs_type) {
_0xA000B:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X
	LDI  R31,0
; 0005 004E 	case FS_FAT12 :
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BREQ PC+2
	RJMP _0xA0011
; 0005 004F 		bc = (WORD)clst; bc += bc / 2;
	__GETWRS 18,19,12
	MOVW R30,R18
	LSR  R31
	ROR  R30
	__ADDWRR 18,19,30,31
; 0005 0050 		ofs = bc % 512; bc /= 512;
	MOVW R30,R18
	ANDI R31,HIGH(0x1FF)
	MOVW R20,R30
	MOVW R26,R18
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	MOVW R18,R30
; 0005 0051 		if (ofs != 511) {
	LDI  R30,LOW(511)
	LDI  R31,HIGH(511)
	CP   R30,R20
	CPC  R31,R21
	BREQ _0xA0012
; 0005 0052 			if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xB9
	CALL __PUTPARD1
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0xBA
	BREQ _0xA0013
	RJMP _0xA0010
; 0005 0053 		} else {
_0xA0013:
	RJMP _0xA0014
_0xA0012:
; 0005 0054 			if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xB9
	CALL __PUTPARD1
	LDI  R30,LOW(511)
	LDI  R31,HIGH(511)
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xBB
	BREQ _0xA0015
	RJMP _0xA0010
; 0005 0055 			if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
_0xA0015:
	MOVW R30,R28
	ADIW R30,9
	CALL SUBOPT_0x91
	CALL SUBOPT_0xB9
	__ADDD1N 1
	CALL __PUTPARD1
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xBB
	BREQ _0xA0016
	RJMP _0xA0010
; 0005 0056 		}
_0xA0016:
_0xA0014:
; 0005 0057 		wc = LD_WORD(buf);
	__GETWRS 16,17,8
; 0005 0058 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
	LDD  R30,Y+12
	ANDI R30,LOW(0x1)
	BREQ _0xA0017
	MOVW R30,R16
	CALL __LSRW4
	RJMP _0xA00E5
_0xA0017:
	MOVW R30,R16
	ANDI R31,HIGH(0xFFF)
_0xA00E5:
	CLR  R22
	CLR  R23
	RJMP _0x20C000E
; 0005 0059 
; 0005 005A 	case FS_FAT16 :
_0xA0011:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0xA001A
; 0005 005B 		if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xBC
	PUSH R25
	PUSH R24
	PUSH R27
	PUSH R26
	CALL SUBOPT_0xBD
	__GETD1N 0x100
	CALL __DIVD21U
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xBE
	ANDI R31,HIGH(0xFF)
	LSL  R30
	ROL  R31
	CALL SUBOPT_0xBF
	BRNE _0xA0010
; 0005 005C 		return LD_WORD(buf);
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CLR  R22
	CLR  R23
	RJMP _0x20C000E
; 0005 005D #if _FS_FAT32
; 0005 005E 	case FS_FAT32 :
_0xA001A:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0xA0010
; 0005 005F 		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xBC
	PUSH R25
	PUSH R24
	PUSH R27
	PUSH R26
	CALL SUBOPT_0xBD
	__GETD1N 0x80
	CALL __DIVD21U
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xBE
	ANDI R30,LOW(0x7F)
	ANDI R31,HIGH(0x7F)
	CALL __LSLW2
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(4)
	LDI  R31,HIGH(4)
	CALL SUBOPT_0xC0
	BRNE _0xA0010
; 0005 0060 		return LD_DWORD(buf) & 0x0FFFFFFF;
	CALL SUBOPT_0xB1
	__ANDD1N 0xFFFFFFF
	RJMP _0x20C000E
; 0005 0061 #endif
; 0005 0062 	}
_0xA0010:
; 0005 0063 
; 0005 0064 	return 1;	/* An error occured at the disk I/O layer */
_0x20C000F:
	__GETD1N 0x1
_0x20C000E:
	CALL __LOADLOCR6
	ADIW R28,16
	RET
; 0005 0065 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get sector# from cluster#                                             */
;/*-----------------------------------------------------------------------*/
;
;static
;DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
; 0005 0070 	CLUST clst		/* Cluster# to be converted */
; 0005 0071 )
; 0005 0072 {
_clust2sect_G005:
; .FSTART _clust2sect_G005
; 0005 0073 	FATFS *fs = FatFs;
; 0005 0074 
; 0005 0075 
; 0005 0076 	clst -= 2;
	CALL SUBOPT_0xC1
;	clst -> Y+2
;	*fs -> R16,R17
	CALL SUBOPT_0xAC
	__SUBD1N 2
	CALL SUBOPT_0xC2
; 0005 0077 	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
	MOVW R30,R16
	__GETD2Z 8
	__GETD1N 0x2
	CALL __SWAPD12
	CALL __SUBD12
	CALL SUBOPT_0xC3
	CALL __CPD21
	BRLO _0xA001E
	CALL SUBOPT_0xC4
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C0009
; 0005 0078 	return (DWORD)clst * fs->csize + fs->database;
_0xA001E:
	MOVW R30,R16
	LDD  R30,Z+1
	LDI  R31,0
	CALL SUBOPT_0xC3
	CALL __CWD1
	CALL __MULD12U
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R16
	ADIW R26,20
	CALL __GETD1P
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ADDD12
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C0009
; 0005 0079 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Rewind directory index                           */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_rewind (
; 0005 0084 	DIR *dj			/* Pointer to directory object */
; 0005 0085 )
; 0005 0086 {
_dir_rewind_G005:
; .FSTART _dir_rewind_G005
; 0005 0087 	CLUST clst;
; 0005 0088 	FATFS *fs = FatFs;
; 0005 0089 
; 0005 008A 
; 0005 008B 	dj->index = 0;
	SBIW R28,4
	CALL SUBOPT_0xC1
;	*dj -> Y+6
;	clst -> Y+2
;	*fs -> R16,R17
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0xC5
; 0005 008C 	clst = dj->sclust;
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,4
	CALL SUBOPT_0xC6
; 0005 008D 	if (clst == 1 || clst >= fs->max_clust)	/* Check start cluster range */
	CALL SUBOPT_0xC7
	BREQ _0xA0020
	MOVW R26,R16
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0xC3
	CALL __CPD21
	BRLO _0xA001F
_0xA0020:
; 0005 008E 		return FR_DISK_ERR;
	LDI  R30,LOW(1)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C000A
; 0005 008F #if _FS_FAT32
; 0005 0090 	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
_0xA001F:
	CALL SUBOPT_0xC8
	BRNE _0xA0023
	MOVW R26,R16
	LD   R26,X
	CPI  R26,LOW(0x3)
	BREQ _0xA0024
_0xA0023:
	RJMP _0xA0022
_0xA0024:
; 0005 0091 		clst = fs->dirbase;
	MOVW R26,R16
	ADIW R26,16
	CALL SUBOPT_0xC6
; 0005 0092 #endif
; 0005 0093 	dj->clust = clst;						/* Current cluster */
_0xA0022:
	CALL SUBOPT_0xAC
	__PUTD1SNS 6,8
; 0005 0094 	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
	CALL SUBOPT_0xC8
	BREQ _0xA0025
	CALL SUBOPT_0xC9
	RCALL _clust2sect_G005
	RJMP _0xA0026
_0xA0025:
	MOVW R26,R16
	ADIW R26,16
	CALL __GETD1P
_0xA0026:
	__PUTD1SNS 6,12
; 0005 0095 
; 0005 0096 	return FR_OK;	/* Seek succeeded */
	LDI  R30,LOW(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C000A
; 0005 0097 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Move directory index next                        */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
; 0005 00A2 	DIR *dj			/* Pointer to directory object */
; 0005 00A3 )
; 0005 00A4 {
_dir_next_G005:
; .FSTART _dir_next_G005
; 0005 00A5 	CLUST clst;
; 0005 00A6 	WORD i;
; 0005 00A7 	FATFS *fs = FatFs;
; 0005 00A8 
; 0005 00A9 
; 0005 00AA 	i = dj->index + 1;
	SBIW R28,4
	CALL SUBOPT_0xCA
;	*dj -> Y+8
;	clst -> Y+4
;	i -> R16,R17
;	*fs -> R18,R19
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __GETW1P
	ADIW R30,1
	MOVW R16,R30
; 0005 00AB 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
	MOV  R0,R16
	OR   R0,R17
	BREQ _0xA0029
	ADIW R26,12
	CALL __GETD1P
	CALL __CPD10
	BRNE _0xA0028
_0xA0029:
; 0005 00AC 		return FR_NO_FILE;
	LDI  R30,LOW(3)
	RJMP _0x20C000C
; 0005 00AD 
; 0005 00AE 	if (!(i & (16-1))) {	/* Sector changed? */
_0xA0028:
	MOVW R30,R16
	ANDI R30,LOW(0xF)
	BREQ PC+2
	RJMP _0xA002B
; 0005 00AF 		dj->sect++;			/* Next sector */
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,12
	CALL __GETD1P_INC
	CALL SUBOPT_0x63
	CALL __PUTDP1_DEC
; 0005 00B0 
; 0005 00B1 		if (dj->clust == 0) {	/* Static table */
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,8
	CALL __GETD1P
	CALL __CPD10
	BRNE _0xA002C
; 0005 00B2 			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
	MOVW R26,R18
	ADIW R26,4
	CALL __GETW1P
	CP   R16,R30
	CPC  R17,R31
	BRLO _0xA002D
; 0005 00B3 				return FR_NO_FILE;
	LDI  R30,LOW(3)
	RJMP _0x20C000C
; 0005 00B4 		}
_0xA002D:
; 0005 00B5 		else {					/* Dynamic table */
	RJMP _0xA002E
_0xA002C:
; 0005 00B6 			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
	MOVW R30,R16
	CALL __LSRW4
	MOVW R26,R30
	MOVW R30,R18
	LDD  R30,Z+1
	LDI  R31,0
	SBIW R30,1
	AND  R30,R26
	AND  R31,R27
	SBIW R30,0
	BRNE _0xA002F
; 0005 00B7 				clst = get_fat(dj->clust);		/* Get next cluster */
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__GETD2Z 8
	CALL SUBOPT_0xCB
	CALL SUBOPT_0x74
; 0005 00B8 				if (clst <= 1) return FR_DISK_ERR;
	CALL SUBOPT_0x75
	CALL SUBOPT_0xB7
	BRSH _0xA0030
	LDI  R30,LOW(1)
	RJMP _0x20C000C
; 0005 00B9 				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
_0xA0030:
	MOVW R26,R18
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0x75
	CALL __CPD21
	BRLO _0xA0031
; 0005 00BA 					return FR_NO_FILE;			/* Report EOT */
	LDI  R30,LOW(3)
	RJMP _0x20C000C
; 0005 00BB 				dj->clust = clst;				/* Initialize data for new cluster */
_0xA0031:
	CALL SUBOPT_0x78
	__PUTD1SNS 8,8
; 0005 00BC 				dj->sect = clust2sect(clst);
	CALL SUBOPT_0x78
	CALL __PUTPARD1
	RCALL _clust2sect_G005
	__PUTD1SNS 8,12
; 0005 00BD 			}
; 0005 00BE 		}
_0xA002F:
_0xA002E:
; 0005 00BF 	}
; 0005 00C0 
; 0005 00C1 	dj->index = i;
_0xA002B:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ST   X+,R16
	ST   X,R17
; 0005 00C2 
; 0005 00C3 	return FR_OK;
	LDI  R30,LOW(0)
_0x20C000C:
	CALL __LOADLOCR4
_0x20C000D:
	ADIW R28,10
	RET
; 0005 00C4 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Find an object in the directory                  */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_find (
; 0005 00CF 	DIR *dj			/* Pointer to the directory object linked to the file name */
; 0005 00D0 )
; 0005 00D1 {
_dir_find_G005:
; .FSTART _dir_find_G005
; 0005 00D2 	FRESULT res;
; 0005 00D3 	BYTE c, *dir;
; 0005 00D4 
; 0005 00D5 
; 0005 00D6 	res = dir_rewind(dj);			/* Rewind directory object */
	CALL __SAVELOCR4
;	*dj -> Y+4
;	res -> R17
;	c -> R16
;	*dir -> R18,R19
	CALL SUBOPT_0xA6
	RCALL _dir_rewind_G005
	MOV  R17,R30
; 0005 00D7 	if (res != FR_OK) return res;
	CPI  R17,0
	BREQ _0xA0032
	CALL __LOADLOCR4
	RJMP _0x20C0009
; 0005 00D8 
; 0005 00D9 	dir = FatFs->buf;
_0xA0032:
	CALL SUBOPT_0xCC
; 0005 00DA 	do {
_0xA0034:
; 0005 00DB 		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
; 0005 00DC 			? FR_DISK_ERR : FR_OK;
	ST   -Y,R19
	ST   -Y,R18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xBC
	CALL __PUTPARD2
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL __GETW1P
	ANDI R30,LOW(0xF)
	ANDI R31,HIGH(0xF)
	LSL  R30
	CALL __LSLW4
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(32)
	LDI  R31,HIGH(32)
	CALL SUBOPT_0xC0
	BREQ _0xA0036
	LDI  R30,LOW(1)
	RJMP _0xA0037
_0xA0036:
	LDI  R30,LOW(0)
_0xA0037:
	MOV  R17,R30
; 0005 00DD 		if (res != FR_OK) break;
	CPI  R17,0
	BRNE _0xA0035
; 0005 00DE 		c = dir[DIR_Name];	/* First character */
	MOVW R26,R18
	LD   R16,X
; 0005 00DF 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
	CPI  R16,0
	BRNE _0xA003A
	LDI  R17,LOW(3)
	RJMP _0xA0035
; 0005 00E0 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
_0xA003A:
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x8)
	BRNE _0xA003C
	ST   -Y,R19
	ST   -Y,R18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+2
	LDD  R27,Z+3
	ST   -Y,R27
	ST   -Y,R26
	LDI  R30,LOW(11)
	LDI  R31,HIGH(11)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _mem_cmp_G005
	SBIW R30,0
	BREQ _0xA003D
_0xA003C:
	RJMP _0xA003B
_0xA003D:
; 0005 00E1 			break;
	RJMP _0xA0035
; 0005 00E2 		res = dir_next(dj);							/* Next entry */
_0xA003B:
	CALL SUBOPT_0xA6
	RCALL _dir_next_G005
	MOV  R17,R30
; 0005 00E3 	} while (res == FR_OK);
	CPI  R17,0
	BRNE _0xA0035
	RJMP _0xA0034
_0xA0035:
; 0005 00E4 
; 0005 00E5 	return res;
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20C0009
; 0005 00E6 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read an object from the directory                                     */
;/*-----------------------------------------------------------------------*/
;#if _USE_DIR
;static
;FRESULT dir_read (
; 0005 00F1 	DIR *dj			/* Pointer to the directory object to store read object name */
; 0005 00F2 )
; 0005 00F3 {
; 0005 00F4 	FRESULT res;
; 0005 00F5 	BYTE a, c, *dir;
; 0005 00F6 
; 0005 00F7 
; 0005 00F8 	res = FR_NO_FILE;
;	*dj -> Y+6
;	res -> R17
;	a -> R16
;	c -> R19
;	*dir -> R20,R21
; 0005 00F9 	dir = FatFs->buf;
; 0005 00FA 	while (dj->sect) {
; 0005 00FB 		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
; 0005 00FC 			? FR_DISK_ERR : FR_OK;
; 0005 00FD 		if (res != FR_OK) break;
; 0005 00FE 		c = dir[DIR_Name];
; 0005 00FF 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
; 0005 0100 		a = dir[DIR_Attr] & AM_MASK;
; 0005 0101 		if (c != 0xE5 && c != '.' && !(a & AM_VOL))	/* Is it a valid entry? */
; 0005 0102 			break;
; 0005 0103 		res = dir_next(dj);				/* Next entry */
; 0005 0104 		if (res != FR_OK) break;
; 0005 0105 	}
; 0005 0106 
; 0005 0107 	if (res != FR_OK) dj->sect = 0;
; 0005 0108 
; 0005 0109 	return res;
; 0005 010A }
;#endif
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Pick a segment and create the object name in directory form           */
;/*-----------------------------------------------------------------------*/
;
;#ifdef _EXCVT
;	static const BYTE cvt[] = _EXCVT;
;#endif
;
;static
;FRESULT create_name (
; 0005 0119 	DIR *dj,			/* Pointer to the directory object */
; 0005 011A 	const char **path	/* Pointer to pointer to the segment in the path string */
; 0005 011B )
; 0005 011C {
_create_name_G005:
; .FSTART _create_name_G005
; 0005 011D 	BYTE c, d, ni, si, i, *sfn;
; 0005 011E 	const char *p;
; 0005 011F 
; 0005 0120 	/* Create file name in directory form */
; 0005 0121 	sfn = dj->fn;
	SBIW R28,4
	CALL __SAVELOCR6
;	*dj -> Y+12
;	*path -> Y+10
;	c -> R17
;	d -> R16
;	ni -> R19
;	si -> R18
;	i -> R21
;	*sfn -> Y+8
;	*p -> Y+6
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,2
	CALL __GETW1P
	STD  Y+8,R30
	STD  Y+8+1,R31
; 0005 0122 	mem_set(sfn, ' ', 11);
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(32)
	LDI  R31,HIGH(32)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(11)
	LDI  R31,HIGH(11)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _mem_set_G005
; 0005 0123 	si = i = 0; ni = 8;
	LDI  R30,LOW(0)
	MOV  R21,R30
	MOV  R18,R30
	LDI  R19,LOW(8)
; 0005 0124 	p = *path;
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0xCD
; 0005 0125 	for (;;) {
_0xA004C:
; 0005 0126 		c = p[si++];
	CALL SUBOPT_0xCE
	LD   R17,X
; 0005 0127 		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
	CPI  R17,33
	BRLO _0xA004F
	CPI  R17,47
	BRNE _0xA004E
_0xA004F:
	RJMP _0xA004D
; 0005 0128 		if (c == '.' || i >= ni) {
_0xA004E:
	CPI  R17,46
	BREQ _0xA0052
	CP   R21,R19
	BRLO _0xA0051
_0xA0052:
; 0005 0129 			if (ni != 8 || c != '.') break;
	CPI  R19,8
	BRNE _0xA0055
	CPI  R17,46
	BREQ _0xA0054
_0xA0055:
	RJMP _0xA004D
; 0005 012A 			i = 8; ni = 11;
_0xA0054:
	LDI  R21,LOW(8)
	LDI  R19,LOW(11)
; 0005 012B 			continue;
	RJMP _0xA004B
; 0005 012C 		}
; 0005 012D #ifdef _EXCVT
; 0005 012E 		if (c >= 0x80)					/* To upper extended char (SBCS) */
_0xA0051:
	CPI  R17,128
	BRLO _0xA0057
; 0005 012F 			c = cvt[c - 0x80];
	MOV  R30,R17
	LDI  R31,0
	SUBI R30,LOW(128)
	SBCI R31,HIGH(128)
	SUBI R30,LOW(-_cvt_G005*2)
	SBCI R31,HIGH(-_cvt_G005*2)
	LPM  R17,Z
; 0005 0130 #endif
; 0005 0131 		if (IsDBCS1(c) && i >= ni - 1) {	/* DBC 1st byte? */
_0xA0057:
	LDI  R30,LOW(0)
	CPI  R30,0
	BREQ _0xA0059
	MOV  R30,R19
	LDI  R31,0
	SBIW R30,1
	MOV  R26,R21
	LDI  R27,0
	CP   R26,R30
	CPC  R27,R31
	BRGE _0xA005A
_0xA0059:
	RJMP _0xA0058
_0xA005A:
; 0005 0132 			d = p[si++];					/* Get 2nd byte */
	CALL SUBOPT_0xCE
	LD   R16,X
; 0005 0133 			sfn[i++] = c;
	CALL SUBOPT_0xCF
	ST   Z,R17
; 0005 0134 			sfn[i++] = d;
	CALL SUBOPT_0xCF
	ST   Z,R16
; 0005 0135 		} else {						/* Single byte code */
	RJMP _0xA005B
_0xA0058:
; 0005 0136 			if (IsLower(c)) c -= 0x20;	/* toupper */
	CPI  R17,97
	BRLO _0xA005D
	CPI  R17,123
	BRLO _0xA005E
_0xA005D:
	RJMP _0xA005C
_0xA005E:
	SUBI R17,LOW(32)
; 0005 0137 			sfn[i++] = c;
_0xA005C:
	CALL SUBOPT_0xCF
	ST   Z,R17
; 0005 0138 		}
_0xA005B:
; 0005 0139 	}
_0xA004B:
	RJMP _0xA004C
_0xA004D:
; 0005 013A 	*path = &p[si];						/* Rerurn pointer to the next segment */
	MOV  R30,R18
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	ST   X+,R30
	ST   X,R31
; 0005 013B 
; 0005 013C 	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
	CPI  R17,33
	BRSH _0xA005F
	LDI  R30,LOW(1)
	RJMP _0xA0060
_0xA005F:
	LDI  R30,LOW(0)
_0xA0060:
	__PUTB1SNS 8,11
; 0005 013D 
; 0005 013E 	return FR_OK;
	LDI  R30,LOW(0)
	CALL __LOADLOCR6
_0x20C000B:
	ADIW R28,14
	RET
; 0005 013F }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get file information from directory entry                             */
;/*-----------------------------------------------------------------------*/
;#if _USE_DIR
;static
;void get_fileinfo (		/* No return code */
; 0005 014A 	DIR *dj,			/* Pointer to the directory object */
; 0005 014B 	FILINFO *fno	 	/* Pointer to store the file information */
; 0005 014C )
; 0005 014D {
; 0005 014E 	BYTE i, c, *dir;
; 0005 014F 	char *p;
; 0005 0150 
; 0005 0151 
; 0005 0152 	p = fno->fname;
;	*dj -> Y+8
;	*fno -> Y+6
;	i -> R17
;	c -> R16
;	*dir -> R18,R19
;	*p -> R20,R21
; 0005 0153 	if (dj->sect) {
; 0005 0154 		dir = FatFs->buf;
; 0005 0155 		for (i = 0; i < 8; i++) {	/* Copy file name body */
; 0005 0156 			c = dir[i];
; 0005 0157 			if (c == ' ') break;
; 0005 0158 			if (c == 0x05) c = 0xE5;
; 0005 0159 			*p++ = c;
; 0005 015A 		}
; 0005 015B 		if (dir[8] != ' ') {		/* Copy file name extension */
; 0005 015C 			*p++ = '.';
; 0005 015D 			for (i = 8; i < 11; i++) {
; 0005 015E 				c = dir[i];
; 0005 015F 				if (c == ' ') break;
; 0005 0160 				*p++ = c;
; 0005 0161 			}
; 0005 0162 		}
; 0005 0163 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
; 0005 0164 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
; 0005 0165 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
; 0005 0166 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
; 0005 0167 	}
; 0005 0168 	*p = 0;
; 0005 0169 }
;#endif /* _USE_DIR */
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Follow a file path                                                    */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
; 0005 0174 	DIR *dj,			/* Directory object to return last directory and found object */
; 0005 0175 	const char *path	/* Full-path string to find a file or directory */
; 0005 0176 )
; 0005 0177 {
_follow_path_G005:
; .FSTART _follow_path_G005
; 0005 0178 	FRESULT res;
; 0005 0179 	BYTE *dir;
; 0005 017A 
; 0005 017B 
; 0005 017C 	while (*path == ' ') path++;		/* Skip leading spaces */
	CALL __SAVELOCR4
;	*dj -> Y+6
;	*path -> Y+4
;	res -> R17
;	*dir -> R18,R19
_0xA006D:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x20)
	BRNE _0xA006F
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	RJMP _0xA006D
_0xA006F:
; 0005 017D if (*path == '/') path++;
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x2F)
	BRNE _0xA0070
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
; 0005 017E 	dj->sclust = 0;						/* Set start directory (always root dir) */
_0xA0070:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,4
	CALL SUBOPT_0xD0
; 0005 017F 
; 0005 0180 	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x21)
	BRSH _0xA0071
; 0005 0181 		res = dir_rewind(dj);
	CALL SUBOPT_0xD1
	RCALL _dir_rewind_G005
	MOV  R17,R30
; 0005 0182 		FatFs->buf[0] = 0;
	CALL SUBOPT_0xB5
	LDD  R26,Z+6
	LDD  R27,Z+7
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 0183 
; 0005 0184 	} else {							/* Follow path */
	RJMP _0xA0072
_0xA0071:
; 0005 0185 		for (;;) {
_0xA0074:
; 0005 0186 			res = create_name(dj, &path);	/* Get a segment */
	CALL SUBOPT_0xD1
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	RCALL _create_name_G005
	MOV  R17,R30
; 0005 0187 			if (res != FR_OK) break;
	CPI  R17,0
	BRNE _0xA0075
; 0005 0188 			res = dir_find(dj);				/* Find it */
	CALL SUBOPT_0xD1
	RCALL _dir_find_G005
	MOV  R17,R30
; 0005 0189 			if (res != FR_OK) {				/* Could not find the object */
	CPI  R17,0
	BREQ _0xA0077
; 0005 018A 				if (res == FR_NO_FILE && !*(dj->fn+11))
	CPI  R17,3
	BRNE _0xA0079
	CALL SUBOPT_0xD2
	BREQ _0xA007A
_0xA0079:
	RJMP _0xA0078
_0xA007A:
; 0005 018B 					res = FR_NO_PATH;
	LDI  R17,LOW(4)
; 0005 018C 				break;
_0xA0078:
	RJMP _0xA0075
; 0005 018D 			}
; 0005 018E 			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
_0xA0077:
	CALL SUBOPT_0xD2
	BRNE _0xA0075
; 0005 018F 			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
	CALL SUBOPT_0xCC
; 0005 0190 			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BRNE _0xA007C
; 0005 0191 				res = FR_NO_PATH; break;
	LDI  R17,LOW(4)
	RJMP _0xA0075
; 0005 0192 			}
; 0005 0193 			dj->sclust =
_0xA007C:
; 0005 0194 #if _FS_FAT32
; 0005 0195 				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
; 0005 0196 #endif
; 0005 0197 				LD_WORD(dir+DIR_FstClusLO);
	MOVW R26,R18
	ADIW R26,20
	CALL SUBOPT_0xD3
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R18
	ADIW R26,26
	CALL __GETW1P
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x3D
	__PUTD1SNS 6,4
; 0005 0198 		}
	RJMP _0xA0074
_0xA0075:
; 0005 0199 	}
_0xA0072:
; 0005 019A 
; 0005 019B 	return res;
	MOV  R30,R17
	CALL __LOADLOCR4
_0x20C000A:
	ADIW R28,8
	RET
; 0005 019C }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Check a sector if it is an FAT boot record                            */
;/*-----------------------------------------------------------------------*/
;
;static
;BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
; 0005 01A7 	BYTE *buf,	/* Working buffer */
; 0005 01A8 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
; 0005 01A9 )
; 0005 01AA {
_check_fs_G005:
; .FSTART _check_fs_G005
; 0005 01AB 	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
;	*buf -> Y+4
;	sect -> Y+0
	CALL SUBOPT_0xA6
	CALL SUBOPT_0xC9
	LDI  R30,LOW(510)
	LDI  R31,HIGH(510)
	CALL SUBOPT_0xBF
	BREQ _0xA007D
; 0005 01AC 		return 3;
	LDI  R30,LOW(3)
	RJMP _0x20C0009
; 0005 01AD 	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
_0xA007D:
	CALL SUBOPT_0xD4
	CPI  R30,LOW(0xAA55)
	LDI  R26,HIGH(0xAA55)
	CPC  R31,R26
	BREQ _0xA007E
; 0005 01AE 		return 2;
	LDI  R30,LOW(2)
	RJMP _0x20C0009
; 0005 01AF 
; 0005 01B0 	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
_0xA007E:
	CALL SUBOPT_0xA6
	CALL SUBOPT_0xC9
	LDI  R30,LOW(54)
	LDI  R31,HIGH(54)
	CALL SUBOPT_0xBF
	BRNE _0xA0080
	CALL SUBOPT_0xD4
	CPI  R30,LOW(0x4146)
	LDI  R26,HIGH(0x4146)
	CPC  R31,R26
	BREQ _0xA0081
_0xA0080:
	RJMP _0xA007F
_0xA0081:
; 0005 01B1 		return 0;
	LDI  R30,LOW(0)
	RJMP _0x20C0009
; 0005 01B2 #if _FS_FAT32
; 0005 01B3 	if (!disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
_0xA007F:
	CALL SUBOPT_0xA6
	CALL SUBOPT_0xC9
	LDI  R30,LOW(82)
	LDI  R31,HIGH(82)
	CALL SUBOPT_0xBF
	BRNE _0xA0083
	CALL SUBOPT_0xD4
	CPI  R30,LOW(0x4146)
	LDI  R26,HIGH(0x4146)
	CPC  R31,R26
	BREQ _0xA0084
_0xA0083:
	RJMP _0xA0082
_0xA0084:
; 0005 01B4 		return 0;
	LDI  R30,LOW(0)
	RJMP _0x20C0009
; 0005 01B5 #endif
; 0005 01B6 	return 1;
_0xA0082:
	LDI  R30,LOW(1)
_0x20C0009:
	ADIW R28,6
	RET
; 0005 01B7 }
; .FEND
;
;
;
;
;/*--------------------------------------------------------------------------
;
;   Public Functions
;
;--------------------------------------------------------------------------*/
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Mount/Unmount a Locical Drive                                         */
;/*-----------------------------------------------------------------------*/
;
;FRESULT pf_mount (
; 0005 01C9 	FATFS *fs		/* Pointer to new file system object (NULL: Unmount) */
; 0005 01CA )
; 0005 01CB {
_pf_mount:
; .FSTART _pf_mount
; 0005 01CC 	BYTE fmt, buf[36];
; 0005 01CD 	DWORD bsect, fsize, tsect, mclst;
; 0005 01CE 
; 0005 01CF 
; 0005 01D0 	FatFs = 0;
	SBIW R28,52
	ST   -Y,R17
;	*fs -> Y+53
;	fmt -> R17
;	buf -> Y+17
;	bsect -> Y+13
;	fsize -> Y+9
;	tsect -> Y+5
;	mclst -> Y+1
	LDI  R30,LOW(0)
	STS  _FatFs_G005,R30
	STS  _FatFs_G005+1,R30
; 0005 01D1 	if (!fs) return FR_OK;				/* Unregister fs object */
	LDD  R30,Y+53
	LDD  R31,Y+53+1
	SBIW R30,0
	BRNE _0xA0085
	RJMP _0x20C0008
; 0005 01D2 
; 0005 01D3 	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
_0xA0085:
	RCALL _disk_initialize
	ANDI R30,LOW(0x1)
	BREQ _0xA0086
; 0005 01D4 		return FR_NOT_READY;
	LDI  R30,LOW(2)
	RJMP _0x20C0007
; 0005 01D5 
; 0005 01D6 	/* Search FAT partition on the drive */
; 0005 01D7 	bsect = 0;
_0xA0086:
	LDI  R30,LOW(0)
	__CLRD1S 13
; 0005 01D8 	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
	CALL SUBOPT_0xD5
	RCALL _check_fs_G005
	MOV  R17,R30
; 0005 01D9 	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
	CPI  R17,1
	BRNE _0xA0087
; 0005 01DA 		/* Check a partition listed in top of the partition table */
; 0005 01DB 		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
	CALL SUBOPT_0xD5
	LDI  R30,LOW(446)
	LDI  R31,HIGH(446)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(16)
	LDI  R31,HIGH(16)
	CALL SUBOPT_0xC0
	BREQ _0xA0088
; 0005 01DC 			fmt = 3;
	LDI  R17,LOW(3)
; 0005 01DD 		} else {
	RJMP _0xA0089
_0xA0088:
; 0005 01DE 			if (buf[4]) {					/* Is the partition existing? */
	LDD  R30,Y+21
	CPI  R30,0
	BREQ _0xA008A
; 0005 01DF 				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
	__GETD1S 25
	__PUTD1S 13
; 0005 01E0 				fmt = check_fs(buf, bsect);	/* Check the partition */
	CALL SUBOPT_0xD5
	RCALL _check_fs_G005
	MOV  R17,R30
; 0005 01E1 			}
; 0005 01E2 		}
_0xA008A:
_0xA0089:
; 0005 01E3 	}
; 0005 01E4 	if (fmt == 3) return FR_DISK_ERR;
_0xA0087:
	CPI  R17,3
	BRNE _0xA008B
	LDI  R30,LOW(1)
	RJMP _0x20C0007
; 0005 01E5 	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
_0xA008B:
	CPI  R17,0
	BREQ _0xA008C
	LDI  R30,LOW(7)
	RJMP _0x20C0007
; 0005 01E6 
; 0005 01E7 	/* Initialize the file system object */
; 0005 01E8 	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
_0xA008C:
	CALL SUBOPT_0xD5
	LDI  R30,LOW(13)
	LDI  R31,HIGH(13)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(36)
	LDI  R31,HIGH(36)
	CALL SUBOPT_0xC0
	BREQ _0xA008D
	LDI  R30,LOW(1)
	RJMP _0x20C0007
; 0005 01E9 
; 0005 01EA 	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
_0xA008D:
	MOVW R30,R28
	ADIW R30,39
	SBIW R30,13
	MOVW R26,R30
	CALL SUBOPT_0xD3
	CALL SUBOPT_0xD6
; 0005 01EB 	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
	CALL SUBOPT_0xB4
	CALL __CPD10
	BRNE _0xA008E
	MOVW R30,R28
	ADIW R30,53
	SBIW R30,13
	MOVW R26,R30
	CALL __GETD1P
	CALL SUBOPT_0xD6
; 0005 01EC 
; 0005 01ED 	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
_0xA008E:
	LDD  R30,Y+20
	LDI  R31,0
	__GETD2S 9
	CALL __CWD1
	CALL __MULD12U
	CALL SUBOPT_0xD6
; 0005 01EE 	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	CALL SUBOPT_0xD7
	__GETD2S 13
	CALL SUBOPT_0x60
	__PUTD1SNS 53,12
; 0005 01EF 	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	LDD  R30,Y+17
	__PUTB1SNS 53,1
; 0005 01F0 	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	MOVW R30,R28
	ADIW R30,34
	SBIW R30,13
	MOVW R26,R30
	CALL __GETW1P
	__PUTW1SNS 53,4
; 0005 01F1 	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	MOVW R30,R28
	ADIW R30,36
	SBIW R30,13
	MOVW R26,R30
	CALL SUBOPT_0xD3
	__PUTD1S 5
; 0005 01F2 	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
	CALL __CPD10
	BRNE _0xA008F
	MOVW R30,R28
	ADIW R30,49
	SBIW R30,13
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1S 5
; 0005 01F3 	mclst = (tsect						/* Last cluster# + 1 */
_0xA008F:
; 0005 01F4 		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
; 0005 01F5 		) / fs->csize + 2;
	CALL SUBOPT_0xD7
	__GETD2S 5
	CLR  R22
	CLR  R23
	CALL __SWAPD12
	CALL __SUBD12
	__GETD2S 9
	CALL __SUBD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xD8
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CLR  R22
	CLR  R23
	CALL __SUBD21
	LDD  R30,Y+53
	LDD  R31,Y+53+1
	CALL SUBOPT_0xD9
	CALL __DIVD21U
	__ADDD1N 2
	__PUTD1S 1
; 0005 01F6 	fs->max_clust = (CLUST)mclst;
	__PUTD1SNS 53,8
; 0005 01F7 
; 0005 01F8 	fmt = FS_FAT12;							/* Determine the FAT sub type */
	LDI  R17,LOW(1)
; 0005 01F9 	if (mclst >= 0xFF7) fmt = FS_FAT16;		/* Number of clusters >= 0xFF5 */
	__GETD2S 1
	__CPD2N 0xFF7
	BRLO _0xA0090
	LDI  R17,LOW(2)
; 0005 01FA 	if (mclst >= 0xFFF7)					/* Number of clusters >= 0xFFF5 */
_0xA0090:
	__GETD2S 1
	__CPD2N 0xFFF7
	BRLO _0xA0091
; 0005 01FB #if _FS_FAT32
; 0005 01FC 		fmt = FS_FAT32;
	LDI  R17,LOW(3)
; 0005 01FD #else
; 0005 01FE 		return FR_NO_FILESYSTEM;
; 0005 01FF #endif
; 0005 0200 
; 0005 0201 	fs->fs_type = fmt;		/* FAT sub-type */
_0xA0091:
	LDD  R26,Y+53
	LDD  R27,Y+53+1
	ST   X,R17
; 0005 0202 #if _FS_FAT32
; 0005 0203 	if (fmt == FS_FAT32)
	CPI  R17,3
	BRNE _0xA0092
; 0005 0204 		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	__GETD1S 48
	RJMP _0xA00E6
; 0005 0205 	else
_0xA0092:
; 0005 0206 #endif
; 0005 0207 		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	CALL SUBOPT_0xDA
_0xA00E6:
	__PUTD1SNS 53,16
; 0005 0208 	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
	CALL SUBOPT_0xDA
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xD8
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x60
	__PUTD1SNS 53,20
; 0005 0209 
; 0005 020A 	fs->flag = 0;
	LDD  R26,Y+53
	LDD  R27,Y+53+1
	ADIW R26,2
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 020B 	FatFs = fs;
	LDD  R30,Y+53
	LDD  R31,Y+53+1
	STS  _FatFs_G005,R30
	STS  _FatFs_G005+1,R31
; 0005 020C 
; 0005 020D 	return FR_OK;
_0x20C0008:
	LDI  R30,LOW(0)
_0x20C0007:
	LDD  R17,Y+0
	ADIW R28,55
	RET
; 0005 020E }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Open or Create a File                                                 */
;/*-----------------------------------------------------------------------*/
;
;FRESULT pf_open (
; 0005 0218 	const char *path	/* Pointer to the file name */
; 0005 0219 )
; 0005 021A {
_pf_open:
; .FSTART _pf_open
; 0005 021B 	FRESULT res;
; 0005 021C 	DIR dj;
; 0005 021D 	BYTE sp[12], dir[32];
; 0005 021E 	FATFS *fs = FatFs;
; 0005 021F 
; 0005 0220 
; 0005 0221 	if (!fs)						/* Check file system */
	SBIW R28,60
	CALL SUBOPT_0xCA
;	*path -> Y+64
;	res -> R17
;	dj -> Y+48
;	sp -> Y+36
;	dir -> Y+4
;	*fs -> R18,R19
	MOV  R0,R18
	OR   R0,R19
	BRNE _0xA0094
; 0005 0222 		return FR_NOT_ENABLED;
	LDI  R30,LOW(6)
	RJMP _0x20C0006
; 0005 0223 
; 0005 0224 	fs->flag = 0;
_0xA0094:
	MOVW R26,R18
	ADIW R26,2
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 0225 	fs->buf = dir;
	MOVW R30,R28
	ADIW R30,4
	__PUTW1RNS 18,6
; 0005 0226 	dj.fn = sp;
	MOVW R30,R28
	ADIW R30,36
	STD  Y+50,R30
	STD  Y+50+1,R31
; 0005 0227 	res = follow_path(&dj, path);	/* Follow the file path */
	MOVW R30,R28
	ADIW R30,48
	ST   -Y,R31
	ST   -Y,R30
	__GETW1SX 66
	ST   -Y,R31
	ST   -Y,R30
	RCALL _follow_path_G005
	MOV  R17,R30
; 0005 0228 	if (res != FR_OK) return res;	/* Follow failed */
	CPI  R17,0
	BREQ _0xA0095
	RJMP _0x20C0006
; 0005 0229 	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
_0xA0095:
	LDD  R30,Y+4
	CPI  R30,0
	BREQ _0xA0097
	LDD  R30,Y+15
	ANDI R30,LOW(0x10)
	BREQ _0xA0096
_0xA0097:
; 0005 022A 		return FR_NO_FILE;
	LDI  R30,LOW(3)
	RJMP _0x20C0006
; 0005 022B 
; 0005 022C 	fs->org_clust =						/* File start cluster */
_0xA0096:
; 0005 022D #if _FS_FAT32
; 0005 022E 		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
; 0005 022F #endif
; 0005 0230 		LD_WORD(dir+DIR_FstClusLO);
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	CLR  R22
	CLR  R23
	CALL __LSLD16
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+30
	LDD  R31,Y+30+1
	CALL SUBOPT_0x3D
	__PUTD1RNS 18,32
; 0005 0231 	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
	__GETD1S 32
	__PUTD1RNS 18,28
; 0005 0232 	fs->fptr = 0;						/* File pointer */
	MOVW R26,R18
	ADIW R26,24
	CALL SUBOPT_0xD0
; 0005 0233 	fs->flag = FA_OPENED;
	MOVW R26,R18
	ADIW R26,2
	LDI  R30,LOW(1)
	ST   X,R30
; 0005 0234 
; 0005 0235 	return FR_OK;
	LDI  R30,LOW(0)
_0x20C0006:
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,3
	RET
; 0005 0236 }
; .FEND
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read File                                                             */
;/*-----------------------------------------------------------------------*/
;#if _USE_READ
;
;FRESULT pf_read (
; 0005 0241 	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
; 0005 0242 	WORD btr,		/* Number of bytes to read */
; 0005 0243 	WORD* br		/* Pointer to number of bytes read */
; 0005 0244 )
; 0005 0245 {
_pf_read:
; .FSTART _pf_read
; 0005 0246 	DRESULT dr;
; 0005 0247 	CLUST clst;
; 0005 0248 	DWORD sect, remain;
; 0005 0249 	BYTE *rbuff = buff;
; 0005 024A 	WORD rcnt;
; 0005 024B 	FATFS *fs = FatFs;
; 0005 024C 
; 0005 024D 
; 0005 024E 	*br = 0;
	SBIW R28,14
	CALL __SAVELOCR6
;	*buff -> Y+24
;	btr -> Y+22
;	*br -> Y+20
;	dr -> R17
;	clst -> Y+16
;	sect -> Y+12
;	remain -> Y+8
;	*rbuff -> R18,R19
;	rcnt -> R20,R21
;	*fs -> Y+6
	__GETWRS 18,19,24
	CALL SUBOPT_0xB5
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0xC5
; 0005 024F 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,0
	BRNE _0xA0099
	LDI  R30,LOW(6)
	RJMP _0x20C0005
; 0005 0250 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
_0xA0099:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+2
	ANDI R26,LOW(0x1)
	BRNE _0xA009A
; 0005 0251 		return FR_NOT_OPENED;
	LDI  R30,LOW(5)
	RJMP _0x20C0005
; 0005 0252 
; 0005 0253 	remain = fs->fsize - fs->fptr;
_0xA009A:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__GETD2Z 28
	PUSH R25
	PUSH R24
	PUSH R27
	PUSH R26
	CALL SUBOPT_0xDB
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	CALL __SUBD12
	CALL SUBOPT_0xB3
; 0005 0254 	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
	CALL SUBOPT_0xB1
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x61
	BRSH _0xA009B
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	STD  Y+22,R30
	STD  Y+22+1,R31
; 0005 0255 
; 0005 0256 	while (btr)	{									/* Repeat until all data transferred */
_0xA009B:
_0xA009C:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	SBIW R30,0
	BRNE PC+2
	RJMP _0xA009E
; 0005 0257 		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
	CALL SUBOPT_0xDB
	MOVW R30,R26
	MOVW R22,R24
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ PC+2
	RJMP _0xA009F
; 0005 0258 			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
	CALL SUBOPT_0xDB
	CALL SUBOPT_0xDC
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xD9
	CALL __MODD21U
	CALL __CPD10
	BRNE _0xA00A0
; 0005 0259 				clst = (fs->fptr == 0) ?			/* On the top of the file? */
; 0005 025A 					fs->org_clust : get_fat(fs->curr_clust);
	CALL SUBOPT_0xDB
	CALL __CPD02
	BRNE _0xA00A1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,32
	CALL __GETD1P
	RJMP _0xA00A2
_0xA00A1:
	CALL SUBOPT_0xDD
	CALL SUBOPT_0xCB
_0xA00A2:
	__PUTD1S 16
; 0005 025B 				if (clst <= 1) goto fr_abort;
	__GETD2S 16
	CALL SUBOPT_0xB7
	BRSH _0xA00A4
	RJMP _0xA00A5
; 0005 025C 				fs->curr_clust = clst;				/* Update current cluster */
_0xA00A4:
	__GETD1S 16
	__PUTD1SNS 6,36
; 0005 025D 				fs->csect = 0;						/* Reset sector offset in the cluster */
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,3
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 025E 			}
; 0005 025F 			sect = clust2sect(fs->curr_clust);		/* Get current sector */
_0xA00A0:
	CALL SUBOPT_0xDD
	CALL __PUTPARD2
	RCALL _clust2sect_G005
	CALL SUBOPT_0xDE
; 0005 0260 			if (!sect) goto fr_abort;
	__GETD1S 12
	CALL __CPD10
	BRNE _0xA00A6
	RJMP _0xA00A5
; 0005 0261 			fs->dsect = sect + fs->csect++;
_0xA00A6:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0xDF
	CALL SUBOPT_0xB6
	CALL SUBOPT_0x69
	__PUTD1SNS 6,40
; 0005 0262 		}
; 0005 0263 		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
_0xA009F:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xE0
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	SUB  R26,R30
	SBC  R27,R31
	MOVW R20,R26
; 0005 0264 		if (rcnt > btr) rcnt = btr;
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CP   R30,R20
	CPC  R31,R21
	BRSH _0xA00A7
	__GETWRS 20,21,22
; 0005 0265 		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
_0xA00A7:
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	SBIW R30,0
	BRNE _0xA00A8
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0xA00A9
_0xA00A8:
	MOVW R30,R18
_0xA00A9:
	CALL SUBOPT_0x91
	CALL SUBOPT_0xE1
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,24
	CALL __GETW1P
	ANDI R31,HIGH(0x1FF)
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R21
	ST   -Y,R20
	RCALL _disk_readp
	MOV  R17,R30
; 0005 0266 		if (dr) goto fr_abort;
	CPI  R17,0
	BRNE _0xA00A5
; 0005 0267 		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xE2
	MOVW R26,R30
	MOVW R24,R22
	MOVW R30,R20
	CALL SUBOPT_0x60
	MOVW R26,R0
	CALL __PUTDP1
	__ADDWRR 18,19,20,21
; 0005 0268 		btr -= rcnt; *br += rcnt;
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	SUB  R30,R20
	SBC  R31,R21
	STD  Y+22,R30
	STD  Y+22+1,R31
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	LD   R30,X+
	LD   R31,X+
	ADD  R30,R20
	ADC  R31,R21
	ST   -X,R31
	ST   -X,R30
; 0005 0269 	}
	RJMP _0xA009C
_0xA009E:
; 0005 026A 
; 0005 026B 	return FR_OK;
	LDI  R30,LOW(0)
	RJMP _0x20C0005
; 0005 026C 
; 0005 026D fr_abort:
_0xA00A5:
; 0005 026E 	fs->flag = 0;
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0xE3
; 0005 026F 	return FR_DISK_ERR;
_0x20C0005:
	CALL __LOADLOCR6
	ADIW R28,26
	RET
; 0005 0270 }
; .FEND
;#endif
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Write File                                                            */
;/*-----------------------------------------------------------------------*/
;#if _USE_WRITE
;
;FRESULT pf_write (
; 0005 027B 	const void* buff,	/* Pointer to the data to be written */
; 0005 027C 	WORD btw,			/* Number of bytes to write (0:Finalize the current write operation) */
; 0005 027D 	WORD* bw			/* Pointer to number of bytes written */
; 0005 027E )
; 0005 027F {
_pf_write:
; .FSTART _pf_write
; 0005 0280 	CLUST clst;
; 0005 0281 	DWORD sect, remain;
; 0005 0282 	const BYTE *p = buff;
; 0005 0283 	WORD wcnt;
; 0005 0284 	FATFS *fs = FatFs;
; 0005 0285 
; 0005 0286 
; 0005 0287 	*bw = 0;
	SBIW R28,12
	CALL __SAVELOCR6
;	*buff -> Y+22
;	btw -> Y+20
;	*bw -> Y+18
;	clst -> Y+14
;	sect -> Y+10
;	remain -> Y+6
;	*p -> R16,R17
;	wcnt -> R18,R19
;	*fs -> R20,R21
	__GETWRS 16,17,22
	__GETWRMN 20,21,0,_FatFs_G005
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0xC5
; 0005 0288 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	MOV  R0,R20
	OR   R0,R21
	BRNE _0xA00AC
	LDI  R30,LOW(6)
	RJMP _0x20C0004
; 0005 0289 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
_0xA00AC:
	MOVW R30,R20
	LDD  R26,Z+2
	ANDI R26,LOW(0x1)
	BRNE _0xA00AD
; 0005 028A 		return FR_NOT_OPENED;
	LDI  R30,LOW(5)
	RJMP _0x20C0004
; 0005 028B 
; 0005 028C 	if (!btw) {		/* Finalize request */
_0xA00AD:
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	SBIW R30,0
	BRNE _0xA00AE
; 0005 028D 		if ((fs->flag & FA__WIP) && disk_writep(0, 0)) goto fw_abort;
	MOVW R30,R20
	LDD  R26,Z+2
	ANDI R26,LOW(0x40)
	BREQ _0xA00B0
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xAD
	RCALL _disk_writep
	CPI  R30,0
	BRNE _0xA00B1
_0xA00B0:
	RJMP _0xA00AF
_0xA00B1:
	RJMP _0xA00B2
; 0005 028E 		fs->flag &= ~FA__WIP;
_0xA00AF:
	MOVW R26,R20
	ADIW R26,2
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
; 0005 028F 		return FR_OK;
	LDI  R30,LOW(0)
	RJMP _0x20C0004
; 0005 0290 	} else {		/* Write data request */
_0xA00AE:
; 0005 0291 		if (!(fs->flag & FA__WIP))		/* Round down fptr to the sector boundary */
	MOVW R30,R20
	LDD  R26,Z+2
	ANDI R26,LOW(0x40)
	BRNE _0xA00B4
; 0005 0292 			fs->fptr &= 0xFFFFFE00;
	MOVW R26,R20
	ADIW R26,24
	LD   R30,X+
	LD   R31,X+
	ANDI R30,LOW(0xFFFFFE00)
	ANDI R31,HIGH(0xFFFFFE00)
	ST   -X,R31
	ST   -X,R30
; 0005 0293 	}
_0xA00B4:
; 0005 0294 	remain = fs->fsize - fs->fptr;
	MOVW R30,R20
	__GETD2Z 28
	PUSH R25
	PUSH R24
	PUSH R27
	PUSH R26
	CALL SUBOPT_0xE4
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	CALL __SUBD12
	CALL SUBOPT_0xE5
; 0005 0295 	if (btw > remain) btw = (WORD)remain;			/* Truncate btw by remaining bytes */
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0x61
	BRSH _0xA00B5
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	STD  Y+20,R30
	STD  Y+20+1,R31
; 0005 0296 
; 0005 0297 	while (btw)	{									/* Repeat until all data transferred */
_0xA00B5:
_0xA00B6:
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	SBIW R30,0
	BRNE PC+2
	RJMP _0xA00B8
; 0005 0298 		if (((WORD)fs->fptr % 512) == 0) {				/* On the sector boundary? */
	MOVW R30,R20
	CALL SUBOPT_0xE0
	SBIW R30,0
	BREQ PC+2
	RJMP _0xA00B9
; 0005 0299 			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
	CALL SUBOPT_0xE4
	CALL SUBOPT_0xDC
	MOVW R30,R20
	CALL SUBOPT_0xD9
	CALL __MODD21U
	CALL __CPD10
	BRNE _0xA00BA
; 0005 029A 				clst = (fs->fptr == 0) ?			/* On the top of the file? */
; 0005 029B 					fs->org_clust : get_fat(fs->curr_clust);
	CALL SUBOPT_0xE4
	CALL __CPD02
	BRNE _0xA00BB
	MOVW R26,R20
	ADIW R26,32
	CALL __GETD1P
	RJMP _0xA00BC
_0xA00BB:
	MOVW R30,R20
	__GETD2Z 36
	CALL SUBOPT_0xCB
_0xA00BC:
	CALL SUBOPT_0xE6
; 0005 029C 				if (clst <= 1) goto fw_abort;
	CALL SUBOPT_0xBD
	CALL SUBOPT_0xB7
	BRSH _0xA00BE
	RJMP _0xA00B2
; 0005 029D 				fs->curr_clust = clst;				/* Update current cluster */
_0xA00BE:
	CALL SUBOPT_0xE7
	__PUTD1RNS 20,36
; 0005 029E 				fs->csect = 0;						/* Reset sector offset in the cluster */
	MOVW R26,R20
	ADIW R26,3
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 029F 			}
; 0005 02A0 			sect = clust2sect(fs->curr_clust);		/* Get current sector */
_0xA00BA:
	MOVW R30,R20
	__GETD2Z 36
	CALL __PUTPARD2
	RCALL _clust2sect_G005
	__PUTD1S 10
; 0005 02A1 			if (!sect) goto fw_abort;
	CALL SUBOPT_0xE8
	CALL __CPD10
	BRNE _0xA00BF
	RJMP _0xA00B2
; 0005 02A2 			fs->dsect = sect + fs->csect++;
_0xA00BF:
	MOVW R26,R20
	CALL SUBOPT_0xDF
	CALL SUBOPT_0xE9
	CALL SUBOPT_0x69
	__PUTD1RNS 20,40
; 0005 02A3 			if (disk_writep(0, fs->dsect)) goto fw_abort;	/* Initiate a sector write operation */
	CALL SUBOPT_0xA9
	MOVW R30,R20
	CALL SUBOPT_0xE1
	RCALL _disk_writep
	CPI  R30,0
	BREQ _0xA00C0
	RJMP _0xA00B2
; 0005 02A4 			fs->flag |= FA__WIP;
_0xA00C0:
	MOVW R26,R20
	ADIW R26,2
	LD   R30,X
	ORI  R30,0x40
	ST   X,R30
; 0005 02A5 		}
; 0005 02A6 		wcnt = 512 - ((WORD)fs->fptr % 512);		/* Number of bytes to write to the sector */
_0xA00B9:
	MOVW R30,R20
	CALL SUBOPT_0xE0
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	SUB  R26,R30
	SBC  R27,R31
	MOVW R18,R26
; 0005 02A7 		if (wcnt > btw) wcnt = btw;
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	CP   R30,R18
	CPC  R31,R19
	BRSH _0xA00C1
	__GETWRS 18,19,20
; 0005 02A8 		if (disk_writep(p, wcnt)) goto fw_abort;	/* Send data to the sector */
_0xA00C1:
	ST   -Y,R17
	ST   -Y,R16
	MOVW R30,R18
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RCALL _disk_writep
	CPI  R30,0
	BRNE _0xA00B2
; 0005 02A9 		fs->fptr += wcnt; p += wcnt;				/* Update pointers and counters */
	MOVW R30,R20
	CALL SUBOPT_0xE2
	MOVW R26,R30
	MOVW R24,R22
	MOVW R30,R18
	CALL SUBOPT_0x60
	MOVW R26,R0
	CALL __PUTDP1
	__ADDWRR 16,17,18,19
; 0005 02AA 		btw -= wcnt; *bw += wcnt;
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	SUB  R30,R18
	SBC  R31,R19
	STD  Y+20,R30
	STD  Y+20+1,R31
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	LD   R30,X+
	LD   R31,X+
	ADD  R30,R18
	ADC  R31,R19
	ST   -X,R31
	ST   -X,R30
; 0005 02AB 		if (((WORD)fs->fptr % 512) == 0) {
	MOVW R30,R20
	CALL SUBOPT_0xE0
	SBIW R30,0
	BRNE _0xA00C3
; 0005 02AC 			if (disk_writep(0, 0)) goto fw_abort;	/* Finalize the currtent secter write operation */
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xAD
	RCALL _disk_writep
	CPI  R30,0
	BRNE _0xA00B2
; 0005 02AD 			fs->flag &= ~FA__WIP;
	MOVW R26,R20
	ADIW R26,2
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
; 0005 02AE 		}
; 0005 02AF 	}
_0xA00C3:
	RJMP _0xA00B6
_0xA00B8:
; 0005 02B0 
; 0005 02B1 	return FR_OK;
	LDI  R30,LOW(0)
	RJMP _0x20C0004
; 0005 02B2 
; 0005 02B3 fw_abort:
_0xA00B2:
; 0005 02B4 	fs->flag = 0;
	MOVW R26,R20
	CALL SUBOPT_0xE3
; 0005 02B5 	return FR_DISK_ERR;
_0x20C0004:
	CALL __LOADLOCR6
	ADIW R28,24
	RET
; 0005 02B6 }
; .FEND
;#endif
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Seek File R/W Pointer                                                 */
;/*-----------------------------------------------------------------------*/
;#if _USE_LSEEK
;
;FRESULT pf_lseek (
; 0005 02C1 	DWORD ofs		/* File pointer from top of file */
; 0005 02C2 )
; 0005 02C3 {
_pf_lseek:
; .FSTART _pf_lseek
; 0005 02C4 	CLUST clst;
; 0005 02C5 	DWORD bcs, sect, ifptr;
; 0005 02C6 	FATFS *fs = FatFs;
; 0005 02C7 
; 0005 02C8 
; 0005 02C9 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	SBIW R28,16
	CALL SUBOPT_0xC1
;	ofs -> Y+18
;	clst -> Y+14
;	bcs -> Y+10
;	sect -> Y+6
;	ifptr -> Y+2
;	*fs -> R16,R17
	MOV  R0,R16
	OR   R0,R17
	BRNE _0xA00C5
	LDI  R30,LOW(6)
	RJMP _0x20C0003
; 0005 02CA 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
_0xA00C5:
	MOVW R30,R16
	LDD  R26,Z+2
	ANDI R26,LOW(0x1)
	BRNE _0xA00C6
; 0005 02CB 			return FR_NOT_OPENED;
	LDI  R30,LOW(5)
	RJMP _0x20C0003
; 0005 02CC 
; 0005 02CD 	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
_0xA00C6:
	MOVW R26,R16
	ADIW R26,28
	CALL SUBOPT_0xEA
	CALL __CPD12
	BRSH _0xA00C7
	MOVW R26,R16
	ADIW R26,28
	CALL __GETD1P
	__PUTD1S 18
; 0005 02CE 	ifptr = fs->fptr;
_0xA00C7:
	MOVW R26,R16
	ADIW R26,24
	CALL SUBOPT_0xC6
; 0005 02CF 	fs->fptr = 0;
	MOVW R26,R16
	ADIW R26,24
	CALL SUBOPT_0xD0
; 0005 02D0 	if (ofs > 0) {
	CALL SUBOPT_0xEB
	CALL __CPD02
	BRLO PC+2
	RJMP _0xA00C8
; 0005 02D1 		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
	MOVW R30,R16
	CALL SUBOPT_0xD9
	CALL SUBOPT_0xB2
	__PUTD1S 10
; 0005 02D2 		if (ifptr > 0 &&
; 0005 02D3 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
	CALL SUBOPT_0xC3
	CALL __CPD02
	BRSH _0xA00CA
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xED
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xAC
	CALL SUBOPT_0xED
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRSH _0xA00CB
_0xA00CA:
	RJMP _0xA00C9
_0xA00CB:
; 0005 02D4 			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
	CALL SUBOPT_0xAC
	__SUBD1N 1
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0xE8
	__SUBD1N 1
	CALL __COMD1
	CALL __ANDD12
	__PUTD1RNS 16,24
; 0005 02D5 			ofs -= fs->fptr;
	MOVW R26,R16
	ADIW R26,24
	CALL SUBOPT_0xEA
	CALL __SUBD21
	__PUTD2S 18
; 0005 02D6 			clst = fs->curr_clust;
	MOVW R26,R16
	ADIW R26,36
	CALL __GETD1P
	CALL SUBOPT_0xE6
; 0005 02D7 		} else {							/* When seek to back cluster, */
	RJMP _0xA00CC
_0xA00C9:
; 0005 02D8 			clst = fs->org_clust;			/* start from the first cluster */
	MOVW R26,R16
	ADIW R26,32
	CALL __GETD1P
	CALL SUBOPT_0xE6
; 0005 02D9 			fs->curr_clust = clst;
	CALL SUBOPT_0xEE
; 0005 02DA 		}
_0xA00CC:
; 0005 02DB 		while (ofs > bcs) {				/* Cluster following loop */
_0xA00CD:
	CALL SUBOPT_0xE8
	CALL SUBOPT_0xEB
	CALL __CPD12
	BRSH _0xA00CF
; 0005 02DC 			clst = get_fat(clst);		/* Follow cluster chain */
	CALL SUBOPT_0xE7
	CALL __PUTPARD1
	RCALL _get_fat_G005
	CALL SUBOPT_0xE6
; 0005 02DD 			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
	CALL SUBOPT_0xBD
	CALL SUBOPT_0xB7
	BRLO _0xA00D1
	MOVW R26,R16
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0xBD
	CALL __CPD21
	BRLO _0xA00D0
_0xA00D1:
	RJMP _0xA00D3
; 0005 02DE 			fs->curr_clust = clst;
_0xA00D0:
	CALL SUBOPT_0xEE
; 0005 02DF 			fs->fptr += bcs;
	MOVW R30,R16
	CALL SUBOPT_0xE2
	CALL SUBOPT_0xE9
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
; 0005 02E0 			ofs -= bcs;
	CALL SUBOPT_0xE9
	CALL SUBOPT_0xEC
	CALL __SUBD12
	__PUTD1S 18
; 0005 02E1 		}
	RJMP _0xA00CD
_0xA00CF:
; 0005 02E2 		fs->fptr += ofs;
	MOVW R30,R16
	CALL SUBOPT_0xE2
	CALL SUBOPT_0xEB
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
; 0005 02E3 		sect = clust2sect(clst);		/* Current sector */
	CALL SUBOPT_0xE7
	CALL __PUTPARD1
	RCALL _clust2sect_G005
	CALL SUBOPT_0xE5
; 0005 02E4 		if (!sect) goto fe_abort;
	CALL __CPD10
	BREQ _0xA00D3
; 0005 02E5 		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
	CALL SUBOPT_0xEB
	CALL SUBOPT_0xB0
	CALL __DIVD21U
	__PUTB1RNS 16,3
; 0005 02E6 		if (ofs % 512)
	CALL SUBOPT_0xEC
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ _0xA00D5
; 0005 02E7 			fs->dsect = sect + fs->csect++;
	MOVW R26,R16
	CALL SUBOPT_0xDF
	__GETD2S 6
	CALL SUBOPT_0x69
	__PUTD1RNS 16,40
; 0005 02E8 	}
_0xA00D5:
; 0005 02E9 
; 0005 02EA 	return FR_OK;
_0xA00C8:
	LDI  R30,LOW(0)
	RJMP _0x20C0003
; 0005 02EB 
; 0005 02EC fe_abort:
_0xA00D3:
; 0005 02ED 	fs->flag = 0;
	MOVW R26,R16
	CALL SUBOPT_0xE3
; 0005 02EE 	return FR_DISK_ERR;
_0x20C0003:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,22
	RET
; 0005 02EF }
; .FEND
;#endif
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Create a Directroy Object                                             */
;/*-----------------------------------------------------------------------*/
;#if _USE_DIR
;
;FRESULT pf_opendir (
; 0005 02FA 	DIR *dj,			/* Pointer to directory object to create */
; 0005 02FB 	const char *path	/* Pointer to the directory path */
; 0005 02FC )
; 0005 02FD {
; 0005 02FE 	FRESULT res;
; 0005 02FF 	BYTE sp[12], dir[32];
; 0005 0300 	FATFS *fs = FatFs;
; 0005 0301 
; 0005 0302 
; 0005 0303 	if (!fs) {				/* Check file system */
;	*dj -> Y+50
;	*path -> Y+48
;	res -> R17
;	sp -> Y+36
;	dir -> Y+4
;	*fs -> R18,R19
; 0005 0304 		res = FR_NOT_ENABLED;
; 0005 0305 	} else {
; 0005 0306 		fs->buf = dir;
; 0005 0307 		dj->fn = sp;
; 0005 0308 		res = follow_path(dj, path);			/* Follow the path to the directory */
; 0005 0309 		if (res == FR_OK) {						/* Follow completed */
; 0005 030A 			if (dir[0]) {						/* It is not the root dir */
; 0005 030B 				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
; 0005 030C 					dj->sclust =
; 0005 030D #if _FS_FAT32
; 0005 030E 					((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
; 0005 030F #endif
; 0005 0310 					LD_WORD(dir+DIR_FstClusLO);
; 0005 0311 				} else {						/* The object is not a directory */
; 0005 0312 					res = FR_NO_PATH;
; 0005 0313 				}
; 0005 0314 			}
; 0005 0315 			if (res == FR_OK)
; 0005 0316 				res = dir_rewind(dj);			/* Rewind dir */
; 0005 0317 		}
; 0005 0318 		if (res == FR_NO_FILE) res = FR_NO_PATH;
; 0005 0319 	}
; 0005 031A 
; 0005 031B 	return res;
; 0005 031C }
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read Directory Entry in Sequense                                      */
;/*-----------------------------------------------------------------------*/
;
;FRESULT pf_readdir (
; 0005 0326 	DIR *dj,			/* Pointer to the open directory object */
; 0005 0327 	FILINFO *fno		/* Pointer to file information to return */
; 0005 0328 )
; 0005 0329 {
; 0005 032A 	FRESULT res;
; 0005 032B 	BYTE sp[12], dir[32];
; 0005 032C 	FATFS *fs = FatFs;
; 0005 032D 
; 0005 032E 
; 0005 032F 	if (!fs) {				/* Check file system */
;	*dj -> Y+50
;	*fno -> Y+48
;	res -> R17
;	sp -> Y+36
;	dir -> Y+4
;	*fs -> R18,R19
; 0005 0330 		res = FR_NOT_ENABLED;
; 0005 0331 	} else {
; 0005 0332 		fs->buf = dir;
; 0005 0333 		dj->fn = sp;
; 0005 0334 		if (!fno) {
; 0005 0335 			res = dir_rewind(dj);
; 0005 0336 		} else {
; 0005 0337 			res = dir_read(dj);
; 0005 0338 			if (res == FR_NO_FILE) {
; 0005 0339 				dj->sect = 0;
; 0005 033A 				res = FR_OK;
; 0005 033B 			}
; 0005 033C 			if (res == FR_OK) {				/* A valid entry is found */
; 0005 033D 				get_fileinfo(dj, fno);		/* Get the object information */
; 0005 033E 				res = dir_next(dj);			/* Increment index for next */
; 0005 033F 				if (res == FR_NO_FILE) {
; 0005 0340 					dj->sect = 0;
; 0005 0341 					res = FR_OK;
; 0005 0342 				}
; 0005 0343 			}
; 0005 0344 		}
; 0005 0345 	}
; 0005 0346 
; 0005 0347 	return res;
; 0005 0348 }
;
;#endif /* _USE_DIR */
;
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif

	.DSEG

	.CSEG
__lcd_write_nibble_G100:
; .FSTART __lcd_write_nibble_G100
	IN   R30,0x8
	ANDI R30,LOW(0xF0)
	MOV  R26,R30
	LD   R30,Y
	SWAP R30
	ANDI R30,0xF
	OR   R30,R26
	OUT  0x8,R30
	__DELAY_USB 20
	SBI  0xB,4
	__DELAY_USB 20
	CBI  0xB,4
	__DELAY_USB 20
	RJMP _0x20C0002
; .FEND
__lcd_write_data:
; .FSTART __lcd_write_data
	LD   R30,Y
	ST   -Y,R30
	RCALL __lcd_write_nibble_G100
    ld    r30,y
    swap  r30
    st    y,r30
	LD   R30,Y
	ST   -Y,R30
	RCALL __lcd_write_nibble_G100
	__DELAY_USB 200
	RJMP _0x20C0002
; .FEND
_lcd_gotoxy:
; .FSTART _lcd_gotoxy
	LD   R30,Y
	LDI  R31,0
	SUBI R30,LOW(-__base_y_G100)
	SBCI R31,HIGH(-__base_y_G100)
	LD   R30,Z
	LDD  R26,Y+1
	ADD  R30,R26
	ST   -Y,R30
	RCALL __lcd_write_data
	LDD  R30,Y+1
	STS  __lcd_x,R30
	LD   R30,Y
	STS  __lcd_y,R30
	ADIW R28,2
	RET
; .FEND
_lcd_clear:
; .FSTART _lcd_clear
	LDI  R30,LOW(2)
	CALL SUBOPT_0xEF
	LDI  R30,LOW(12)
	ST   -Y,R30
	RCALL __lcd_write_data
	LDI  R30,LOW(1)
	CALL SUBOPT_0xEF
	LDI  R30,LOW(0)
	STS  __lcd_y,R30
	STS  __lcd_x,R30
	RET
; .FEND
_lcd_putchar:
; .FSTART _lcd_putchar
	LD   R26,Y
	CPI  R26,LOW(0xA)
	BREQ _0x2000005
	LDS  R30,__lcd_maxx
	LDS  R26,__lcd_x
	CP   R26,R30
	BRLO _0x2000004
_0x2000005:
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDS  R30,__lcd_y
	SUBI R30,-LOW(1)
	STS  __lcd_y,R30
	ST   -Y,R30
	RCALL _lcd_gotoxy
	LD   R26,Y
	CPI  R26,LOW(0xA)
	BRNE _0x2000007
	RJMP _0x20C0002
_0x2000007:
_0x2000004:
	LDS  R30,__lcd_x
	SUBI R30,-LOW(1)
	STS  __lcd_x,R30
	SBI  0x8,5
	LD   R30,Y
	ST   -Y,R30
	RCALL __lcd_write_data
	CBI  0x8,5
	RJMP _0x20C0002
; .FEND
_lcd_puts:
; .FSTART _lcd_puts
	ST   -Y,R17
_0x2000008:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R30,X+
	STD  Y+1,R26
	STD  Y+1+1,R27
	MOV  R17,R30
	CPI  R30,0
	BREQ _0x200000A
	ST   -Y,R17
	RCALL _lcd_putchar
	RJMP _0x2000008
_0x200000A:
	LDD  R17,Y+0
	JMP  _0x20C0001
; .FEND
_lcd_putsf:
; .FSTART _lcd_putsf
	ST   -Y,R17
_0x200000B:
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,1
	STD  Y+1,R30
	STD  Y+1+1,R31
	SBIW R30,1
	LPM  R30,Z
	MOV  R17,R30
	CPI  R30,0
	BREQ _0x200000D
	ST   -Y,R17
	RCALL _lcd_putchar
	RJMP _0x200000B
_0x200000D:
	LDD  R17,Y+0
	JMP  _0x20C0001
; .FEND
_lcd_init:
; .FSTART _lcd_init
	IN   R30,0x7
	ORI  R30,LOW(0xF)
	OUT  0x7,R30
	SBI  0xA,4
	SBI  0x7,5
	SBI  0x7,4
	CBI  0xB,4
	CBI  0x8,5
	CBI  0x8,4
	LD   R30,Y
	STS  __lcd_maxx,R30
	SUBI R30,-LOW(128)
	__PUTB1MN __base_y_G100,2
	LD   R30,Y
	SUBI R30,-LOW(192)
	__PUTB1MN __base_y_G100,3
	CALL SUBOPT_0x25
	CALL SUBOPT_0xF0
	CALL SUBOPT_0xF0
	CALL SUBOPT_0xF0
	LDI  R30,LOW(32)
	ST   -Y,R30
	RCALL __lcd_write_nibble_G100
	__DELAY_USW 300
	LDI  R30,LOW(40)
	ST   -Y,R30
	RCALL __lcd_write_data
	LDI  R30,LOW(4)
	ST   -Y,R30
	RCALL __lcd_write_data
	LDI  R30,LOW(133)
	ST   -Y,R30
	RCALL __lcd_write_data
	LDI  R30,LOW(6)
	ST   -Y,R30
	RCALL __lcd_write_data
	RCALL _lcd_clear
_0x20C0002:
	ADIW R28,1
	RET
; .FEND

	.CSEG
_atoi:
; .FSTART _atoi
   	ldd  r27,y+1
   	ld   r26,y
__atoi0:
   	ld   r30,x
        mov  r24,r26
	ST   -Y,R30
	CALL _isspace
        mov  r26,r24
   	tst  r30
   	breq __atoi1
   	adiw r26,1
   	rjmp __atoi0
__atoi1:
   	clt
   	ld   r30,x
   	cpi  r30,'-'
   	brne __atoi2
   	set
   	rjmp __atoi3
__atoi2:
   	cpi  r30,'+'
   	brne __atoi4
__atoi3:
   	adiw r26,1
__atoi4:
   	clr  r22
   	clr  r23
__atoi5:
   	ld   r30,x
        mov  r24,r26
	ST   -Y,R30
	CALL _isdigit
        mov  r26,r24
   	tst  r30
   	breq __atoi6
   	movw r30,r22
   	lsl  r22
   	rol  r23
   	lsl  r22
   	rol  r23
   	add  r22,r30
   	adc  r23,r31
   	lsl  r22
   	rol  r23
   	ld   r30,x+
   	clr  r31
   	subi r30,'0'
   	add  r22,r30
   	adc  r23,r31
   	rjmp __atoi5
__atoi6:
   	movw r30,r22
   	brtc __atoi7
   	com  r30
   	com  r31
   	adiw r30,1
__atoi7:
   	adiw r28,2
   	ret
; .FEND
_atol:
; .FSTART _atol
    ldd  r27,y+1
    ld   r26,y
__atol0:
    ld   r30,x
    push r26
	ST   -Y,R30
	CALL _isspace
    pop  r26
    tst  r30
    breq __atol1
    adiw r26,1
    rjmp __atol0
__atol1:
    clt
    ld   r30,x
    cpi  r30,'-'
    brne __atol2
    set
    rjmp __atol3
__atol2:
    cpi  r30,'+'
    brne __atol4
__atol3:
    adiw r26,1
__atol4:
    clr  r0
    clr  r1
    clr  r24
    clr  r25
__atol5:
    ld   r30,x
    push r26
	ST   -Y,R30
	CALL _isdigit
    pop  r26
    tst  r30
    breq __atol6
    movw r30,r0
    movw r22,r24
    rcall __atol8
    rcall __atol8
    add  r0,r30
    adc  r1,r31
    adc  r24,r22
    adc  r25,r23
    rcall __atol8
    ld   r30,x+
    clr  r31
    subi r30,'0'
    add  r0,r30
    adc  r1,r31
    adc  r24,r31
    adc  r25,r31
    rjmp __atol5
__atol6:
    movw r30,r0
    movw r22,r24
    brtc __atol7
    com  r30
    com  r31
    com  r22
    com  r23
    clr  r24
    adiw r30,1
    adc  r22,r24
    adc  r23,r24
__atol7:
    adiw r28,2
    ret

__atol8:
    lsl  r0
    rol  r1
    rol  r24
    rol  r25
    ret
; .FEND
_itoa:
; .FSTART _itoa
    ld   r26,y+
    ld   r27,y+
    ld   r30,y+
    ld   r31,y+
    adiw r30,0
    brpl __itoa0
    com  r30
    com  r31
    adiw r30,1
    ldi  r22,'-'
    st   x+,r22
__itoa0:
    clt
    ldi  r24,low(10000)
    ldi  r25,high(10000)
    rcall __itoa1
    ldi  r24,low(1000)
    ldi  r25,high(1000)
    rcall __itoa1
    ldi  r24,100
    clr  r25
    rcall __itoa1
    ldi  r24,10
    rcall __itoa1
    mov  r22,r30
    rcall __itoa5
    clr  r22
    st   x,r22
    ret

__itoa1:
    clr	 r22
__itoa2:
    cp   r30,r24
    cpc  r31,r25
    brlo __itoa3
    inc  r22
    sub  r30,r24
    sbc  r31,r25
    brne __itoa2
__itoa3:
    tst  r22
    brne __itoa4
    brts __itoa5
    ret
__itoa4:
    set
__itoa5:
    subi r22,-0x30
    st   x+,r22
    ret
; .FEND
_ltoa:
; .FSTART _ltoa
	SBIW R28,4
	ST   -Y,R17
	ST   -Y,R16
	__GETD1N 0x3B9ACA00
	CALL SUBOPT_0xC2
	LDI  R16,LOW(0)
	LDD  R26,Y+11
	TST  R26
	BRPL _0x2020003
	CALL SUBOPT_0xB1
	CALL __ANEGD1
	CALL SUBOPT_0xB3
	CALL SUBOPT_0xF1
	LDI  R30,LOW(45)
	ST   X,R30
_0x2020003:
_0x2020005:
	CALL SUBOPT_0xF2
	CALL __DIVD21U
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020008
	CPI  R16,0
	BRNE _0x2020008
	CALL SUBOPT_0xC7
	BRNE _0x2020007
_0x2020008:
	CALL SUBOPT_0xF1
	MOV  R30,R17
	SUBI R30,-LOW(48)
	ST   X,R30
	LDI  R16,LOW(1)
_0x2020007:
	CALL SUBOPT_0xF2
	CALL __MODD21U
	CALL SUBOPT_0xB3
	CALL SUBOPT_0xC3
	__GETD1N 0xA
	CALL __DIVD21U
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xC8
	BRNE _0x2020005
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,12
	RET
; .FEND

	.DSEG

	.CSEG
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_adc_noise_red=0x02
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.SET power_ctrl_reg=smcr
	#endif

	.CSEG
_put_usart_G102:
; .FSTART _put_usart_G102
	LDD  R30,Y+2
	ST   -Y,R30
	CALL _putchar
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
_0x20C0001:
	ADIW R28,3
	RET
; .FEND
__print_G102:
; .FSTART __print_G102
	SBIW R28,11
	CALL __SAVELOCR6
	LDI  R17,0
	LDD  R26,Y+17
	LDD  R27,Y+17+1
	CALL SUBOPT_0xC5
_0x2040016:
	LDD  R30,Y+23
	LDD  R31,Y+23+1
	ADIW R30,1
	STD  Y+23,R30
	STD  Y+23+1,R31
	SBIW R30,1
	LPM  R30,Z
	MOV  R18,R30
	CPI  R30,0
	BRNE PC+2
	RJMP _0x2040018
	MOV  R30,R17
	CPI  R30,0
	BRNE _0x204001C
	CPI  R18,37
	BRNE _0x204001D
	LDI  R17,LOW(1)
	RJMP _0x204001E
_0x204001D:
	CALL SUBOPT_0xF3
_0x204001E:
	RJMP _0x204001B
_0x204001C:
	CPI  R30,LOW(0x1)
	BRNE _0x204001F
	CPI  R18,37
	BRNE _0x2040020
	CALL SUBOPT_0xF3
	RJMP _0x20400D2
_0x2040020:
	LDI  R17,LOW(2)
	LDI  R20,LOW(0)
	LDI  R16,LOW(0)
	CPI  R18,45
	BRNE _0x2040021
	LDI  R16,LOW(1)
	RJMP _0x204001B
_0x2040021:
	CPI  R18,43
	BRNE _0x2040022
	LDI  R20,LOW(43)
	RJMP _0x204001B
_0x2040022:
	CPI  R18,32
	BRNE _0x2040023
	LDI  R20,LOW(32)
	RJMP _0x204001B
_0x2040023:
	RJMP _0x2040024
_0x204001F:
	CPI  R30,LOW(0x2)
	BRNE _0x2040025
_0x2040024:
	LDI  R21,LOW(0)
	LDI  R17,LOW(3)
	CPI  R18,48
	BRNE _0x2040026
	ORI  R16,LOW(128)
	RJMP _0x204001B
_0x2040026:
	RJMP _0x2040027
_0x2040025:
	CPI  R30,LOW(0x3)
	BRNE _0x2040028
_0x2040027:
	CPI  R18,48
	BRLO _0x204002A
	CPI  R18,58
	BRLO _0x204002B
_0x204002A:
	RJMP _0x2040029
_0x204002B:
	LDI  R26,LOW(10)
	MUL  R21,R26
	MOV  R21,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R21,R30
	RJMP _0x204001B
_0x2040029:
	CPI  R18,108
	BRNE _0x204002C
	ORI  R16,LOW(2)
	LDI  R17,LOW(5)
	RJMP _0x204001B
_0x204002C:
	RJMP _0x204002D
_0x2040028:
	CPI  R30,LOW(0x5)
	BREQ PC+2
	RJMP _0x204001B
_0x204002D:
	MOV  R30,R18
	CPI  R30,LOW(0x63)
	BRNE _0x2040032
	CALL SUBOPT_0xF4
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ST   -Y,R26
	CALL SUBOPT_0xF5
	RJMP _0x2040033
_0x2040032:
	CPI  R30,LOW(0x73)
	BRNE _0x2040035
	CALL SUBOPT_0xF4
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	CALL SUBOPT_0xCD
	CALL SUBOPT_0xD1
	CALL _strlen
	MOV  R17,R30
	RJMP _0x2040036
_0x2040035:
	CPI  R30,LOW(0x70)
	BRNE _0x2040038
	CALL SUBOPT_0xF4
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	CALL SUBOPT_0xCD
	CALL SUBOPT_0xD1
	CALL _strlenf
	MOV  R17,R30
	ORI  R16,LOW(8)
_0x2040036:
	ANDI R16,LOW(127)
	LDI  R30,LOW(0)
	STD  Y+16,R30
	LDI  R19,LOW(0)
	RJMP _0x2040039
_0x2040038:
	CPI  R30,LOW(0x64)
	BREQ _0x204003C
	CPI  R30,LOW(0x69)
	BRNE _0x204003D
_0x204003C:
	ORI  R16,LOW(4)
	RJMP _0x204003E
_0x204003D:
	CPI  R30,LOW(0x75)
	BRNE _0x204003F
_0x204003E:
	LDI  R30,LOW(10)
	STD  Y+16,R30
	SBRS R16,1
	RJMP _0x2040040
	__GETD1N 0x3B9ACA00
	CALL SUBOPT_0xB3
	LDI  R17,LOW(10)
	RJMP _0x2040041
_0x2040040:
	__GETD1N 0x2710
	CALL SUBOPT_0xB3
	LDI  R17,LOW(5)
	RJMP _0x2040041
_0x204003F:
	CPI  R30,LOW(0x58)
	BRNE _0x2040043
	ORI  R16,LOW(8)
	RJMP _0x2040044
_0x2040043:
	CPI  R30,LOW(0x78)
	BREQ PC+2
	RJMP _0x2040077
_0x2040044:
	LDI  R30,LOW(16)
	STD  Y+16,R30
	SBRS R16,1
	RJMP _0x2040046
	__GETD1N 0x10000000
	CALL SUBOPT_0xB3
	LDI  R17,LOW(8)
	RJMP _0x2040041
_0x2040046:
	__GETD1N 0x1000
	CALL SUBOPT_0xB3
	LDI  R17,LOW(4)
_0x2040041:
	SBRS R16,1
	RJMP _0x2040047
	CALL SUBOPT_0xF4
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	CALL __GETD1P
	RJMP _0x20400D3
_0x2040047:
	SBRS R16,2
	RJMP _0x2040049
	CALL SUBOPT_0xF4
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	CALL __GETW1P
	CALL __CWD1
	RJMP _0x20400D3
_0x2040049:
	CALL SUBOPT_0xF4
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	CALL SUBOPT_0xD3
_0x20400D3:
	__PUTD1S 12
	SBRS R16,2
	RJMP _0x204004B
	LDD  R26,Y+15
	TST  R26
	BRPL _0x204004C
	__GETD1S 12
	CALL __ANEGD1
	CALL SUBOPT_0xDE
	LDI  R20,LOW(45)
_0x204004C:
	CPI  R20,0
	BREQ _0x204004D
	SUBI R17,-LOW(1)
	RJMP _0x204004E
_0x204004D:
	ANDI R16,LOW(251)
_0x204004E:
_0x204004B:
_0x2040039:
	SBRC R16,0
	RJMP _0x204004F
_0x2040050:
	CP   R17,R21
	BRSH _0x2040052
	SBRS R16,7
	RJMP _0x2040053
	SBRS R16,2
	RJMP _0x2040054
	ANDI R16,LOW(251)
	MOV  R18,R20
	SUBI R17,LOW(1)
	RJMP _0x2040055
_0x2040054:
	LDI  R18,LOW(48)
_0x2040055:
	RJMP _0x2040056
_0x2040053:
	LDI  R18,LOW(32)
_0x2040056:
	CALL SUBOPT_0xF3
	SUBI R21,LOW(1)
	RJMP _0x2040050
_0x2040052:
_0x204004F:
	MOV  R19,R17
	LDD  R30,Y+16
	CPI  R30,0
	BRNE _0x2040057
_0x2040058:
	CPI  R19,0
	BREQ _0x204005A
	SBRS R16,3
	RJMP _0x204005B
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LPM  R18,Z+
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x204005C
_0x204005B:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R18,X+
	STD  Y+6,R26
	STD  Y+6+1,R27
_0x204005C:
	CALL SUBOPT_0xF3
	CPI  R21,0
	BREQ _0x204005D
	SUBI R21,LOW(1)
_0x204005D:
	SUBI R19,LOW(1)
	RJMP _0x2040058
_0x204005A:
	RJMP _0x204005E
_0x2040057:
_0x2040060:
	CALL SUBOPT_0xB1
	CALL SUBOPT_0xB6
	CALL __DIVD21U
	MOV  R18,R30
	CPI  R18,10
	BRLO _0x2040062
	SBRS R16,3
	RJMP _0x2040063
	SUBI R18,-LOW(55)
	RJMP _0x2040064
_0x2040063:
	SUBI R18,-LOW(87)
_0x2040064:
	RJMP _0x2040065
_0x2040062:
	SUBI R18,-LOW(48)
_0x2040065:
	SBRC R16,4
	RJMP _0x2040067
	CPI  R18,49
	BRSH _0x2040069
	__GETD2S 8
	__CPD2N 0x1
	BRNE _0x2040068
_0x2040069:
	RJMP _0x204006B
_0x2040068:
	CP   R21,R19
	BRLO _0x204006D
	SBRS R16,0
	RJMP _0x204006E
_0x204006D:
	RJMP _0x204006C
_0x204006E:
	LDI  R18,LOW(32)
	SBRS R16,7
	RJMP _0x204006F
	LDI  R18,LOW(48)
_0x204006B:
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x2040070
	ANDI R16,LOW(251)
	ST   -Y,R20
	CALL SUBOPT_0xF5
	CPI  R21,0
	BREQ _0x2040071
	SUBI R21,LOW(1)
_0x2040071:
_0x2040070:
_0x204006F:
_0x2040067:
	CALL SUBOPT_0xF3
	CPI  R21,0
	BREQ _0x2040072
	SUBI R21,LOW(1)
_0x2040072:
_0x204006C:
	SUBI R19,LOW(1)
	CALL SUBOPT_0xB1
	CALL SUBOPT_0xB6
	CALL __MODD21U
	CALL SUBOPT_0xDE
	LDD  R30,Y+16
	__GETD2S 8
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __DIVD21U
	CALL SUBOPT_0xB3
	CALL SUBOPT_0xB1
	CALL __CPD10
	BREQ _0x2040061
	RJMP _0x2040060
_0x2040061:
_0x204005E:
	SBRS R16,0
	RJMP _0x2040073
_0x2040074:
	CPI  R21,0
	BREQ _0x2040076
	SUBI R21,LOW(1)
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL SUBOPT_0xF5
	RJMP _0x2040074
_0x2040076:
_0x2040073:
_0x2040077:
_0x2040033:
_0x20400D2:
	LDI  R17,LOW(0)
_0x204001B:
	RJMP _0x2040016
_0x2040018:
	LDD  R26,Y+17
	LDD  R27,Y+17+1
	CALL __GETW1P
	CALL __LOADLOCR6
	ADIW R28,25
	RET
; .FEND
_printf:
; .FSTART _printf
	PUSH R15
	MOV  R15,R24
	SBIW R28,6
	ST   -Y,R17
	ST   -Y,R16
	MOVW R26,R28
	ADIW R26,4
	CALL __ADDW2R15
	MOVW R16,R26
	LDI  R30,LOW(0)
	STD  Y+4,R30
	STD  Y+4+1,R30
	STD  Y+6,R30
	STD  Y+6+1,R30
	MOVW R26,R28
	ADIW R26,8
	CALL __ADDW2R15
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(_put_usart_G102)
	LDI  R31,HIGH(_put_usart_G102)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,8
	ST   -Y,R31
	ST   -Y,R30
	RCALL __print_G102
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,8
	POP  R15
	RET
; .FEND

	.CSEG
_memcpy:
; .FSTART _memcpy
    ldd  r25,y+1
    ld   r24,y
    adiw r24,0
    breq memcpy1
    ldd  r27,y+5
    ldd  r26,y+4
    ldd  r31,y+3
    ldd  r30,y+2
memcpy0:
    ld   r22,z+
    st   x+,r22
    sbiw r24,1
    brne memcpy0
memcpy1:
    ldd  r31,y+5
    ldd  r30,y+4
	ADIW R28,6
	RET
; .FEND
_strcat:
; .FSTART _strcat
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strcat0:
    ld   r22,x+
    tst  r22
    brne strcat0
    sbiw r26,1
strcat1:
    ld   r22,z+
    st   x+,r22
    tst  r22
    brne strcat1
    movw r30,r24
    ret
; .FEND
_strcatf:
; .FSTART _strcatf
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strcatf0:
    ld   r22,x+
    tst  r22
    brne strcatf0
    sbiw r26,1
strcatf1:
	lpm  r0,z+
    st   x+,r0
    tst  r0
    brne strcatf1
    movw r30,r24
    ret
; .FEND
_strcpyf:
; .FSTART _strcpyf
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strcpyf0:
	lpm  r0,z+
    st   x+,r0
    tst  r0
    brne strcpyf0
    movw r30,r24
    ret
; .FEND
_strlen:
; .FSTART _strlen
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strlen0:
    ld   r22,x+
    tst  r22
    breq strlen1
    adiw r30,1
    rjmp strlen0
strlen1:
    ret
; .FEND
_strlenf:
; .FSTART _strlenf
    clr  r26
    clr  r27
    ld   r30,y+
    ld   r31,y+
strlenf0:
	lpm  r0,z+
    tst  r0
    breq strlenf1
    adiw r26,1
    rjmp strlenf0
strlenf1:
    movw r30,r26
    ret
; .FEND
_strncmpf:
; .FSTART _strncmpf
    clr  r0
    clr  r1
    ld   r22,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
strncmpf0:
    tst  r22
    breq strncmpf1
    dec  r22
    ld   r1,x+
	lpm  r0,z+
    cp   r0,r1
    brne strncmpf1
    tst  r0
    brne strncmpf0
strncmpf3:
    clr  r30
    ret
strncmpf1:
    sub  r1,r0
    breq strncmpf3
    ldi  r30,1
    brcc strncmpf2
    subi r30,2
strncmpf2:
    ret
; .FEND
_strncpy:
; .FSTART _strncpy
    ld   r23,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strncpy0:
    tst  r23
    breq strncpy1
    dec  r23
    ld   r22,z+
    st   x+,r22
    tst  r22
    brne strncpy0
strncpy2:
    tst  r23
    breq strncpy1
    dec  r23
    st   x+,r22
    rjmp strncpy2
strncpy1:
    movw r30,r24
    ret
; .FEND
_strpos:
; .FSTART _strpos
    ld   r22,y+
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strpos0:
    ld   r23,x+
    cp   r22,r23
    breq strpos1
    adiw r30,1
    tst  r23
    brne strpos0
    ldi  r30,0xff
    ldi  r31,0xff
strpos1:
    ret
; .FEND
_strstrf:
; .FSTART _strstrf
    ldd  r26,y+2
    ldd  r27,y+3
    movw r24,r26
strstrf0:
    ld   r30,y
    ldd  r31,y+1
strstrf1:
	lpm  r0,z+
    tst  r0
    brne strstrf2
    movw r30,r24
    rjmp strstrf3
strstrf2:
    ld   r22,x+
    cp   r22,r0
    breq strstrf1
    adiw r24,1
    movw r26,r24
    tst  r22
    brne strstrf0
    clr  r30
    clr  r31
strstrf3:
	ADIW R28,4
	RET
; .FEND

	.CSEG
_isdigit:
; .FSTART _isdigit
    ldi  r30,1
    ld   r31,y+
    cpi  r31,'0'
    brlo isdigit0
    cpi  r31,'9'+1
    brlo isdigit1
isdigit0:
    clr  r30
isdigit1:
    ret
; .FEND
_isspace:
; .FSTART _isspace
    ldi  r30,1
    ld   r31,y+
    cpi  r31,' '
    breq isspace1
    cpi  r31,9
    brlo isspace0
    cpi  r31,13+1
    brlo isspace1
isspace0:
    clr  r30
isspace1:
    ret
; .FEND

	.CSEG

	.DSEG
_g_txBuf:
	.BYTE 0x80
_g_txRD:
	.BYTE 0x1
_g_txWR:
	.BYTE 0x1
_g_Addr:
	.BYTE 0x2
_g_BlockSize:
	.BYTE 0x4
_g_Operation:
	.BYTE 0x1
_g_BlockMode:
	.BYTE 0x1
_g_DeviceType:
	.BYTE 0x1
_g_DevicePollCode:
	.BYTE 0x1
_tmpbytes:
	.BYTE 0x20
_value:
	.BYTE 0x2
_StandaloneMode:
	.BYTE 0x1
_debug:
	.BYTE 0x1
_dirnum:
	.BYTE 0x1

	.ESEG

	.ORG 0x5
_SaveDirNum:
	.BYTE 0x1

	.ORG 0x0

	.ORG 0x6
_SaveLockState:
	.BYTE 0x1

	.ORG 0x0

	.DSEG
_tmpimage:
	.BYTE 0x5E
_g_UpSkip:
	.BYTE 0x1
_g_DownSkip:
	.BYTE 0x1
_g_MaxFolders:
	.BYTE 0x1
_fs:
	.BYTE 0x2C
_buffer:
	.BYTE 0x200
_nbytes:
	.BYTE 0x2
_nbytesCounter:
	.BYTE 0x2
_CounterLed:
	.BYTE 0x1
_tx_counter:
	.BYTE 0x1
_lcdnum:
	.BYTE 0x10
_CanTestButtons:
	.BYTE 0x1
_rx_buffer:
	.BYTE 0x8
_tx_buffer:
	.BYTE 0x80
_adc_data:
	.BYTE 0x1
_ADC_DONE:
	.BYTE 0x1
_g_WordCount:
	.BYTE 0x1
_g_Command:
	.BYTE 0x1
_g_NeedParams:
	.BYTE 0x1
_g_FIFO:
	.BYTE 0x10
_g_wrI:
	.BYTE 0x1
_g_rdI:
	.BYTE 0x1
_g_FIFODataSize:
	.BYTE 0x1
_pageaddr:
	.BYTE 0x4
_pageBuffer:
	.BYTE 0x100
_OffsetX16:
	.BYTE 0x4
_Save_i:
	.BYTE 0x1
_Save_cksum:
	.BYTE 0x1
_Save_len:
	.BYTE 0x1
_temptext:
	.BYTE 0x1E

	.ESEG

	.ORG 0xA
_myimage:
	.BYTE 0x1F4

	.ORG 0x0

	.DSEG
_res:
	.BYTE 0x1
_path:
	.BYTE 0x13
_CardType_G004:
	.BYTE 0x1
_wc_S0040007000:
	.BYTE 0x2
_FatFs_G005:
	.BYTE 0x2
__base_y_G100:
	.BYTE 0x4
__lcd_x:
	.BYTE 0x1
__lcd_y:
	.BYTE 0x1
__lcd_maxx:
	.BYTE 0x1
__seed_G101:
	.BYTE 0x4

	.CSEG
;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x0:
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_dirnum
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	LDI  R24,4
	CALL _printf
	ADIW R28,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x1:
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x2:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _lcd_putsf

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x3:
	LDI  R30,LOW(2000)
	LDI  R31,HIGH(2000)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4:
	LDI  R26,LOW(_SaveDirNum)
	LDI  R27,HIGH(_SaveDirNum)
	CALL __EEPROMRDB
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5:
	LDI  R26,LOW(_SaveLockState)
	LDI  R27,HIGH(_SaveLockState)
	CALL __EEPROMRDB
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6:
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _lcd_GetProgName

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x7:
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _TestButton
	STS  _CanTestButtons,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x8:
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x9:
	LDS  R26,_CounterLed
	SUBI R26,-LOW(1)
	STS  _CounterLed,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0xA:
	LDS  R30,_dirnum
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_lcdnum)
	LDI  R31,HIGH(_lcdnum)
	ST   -Y,R31
	ST   -Y,R30
	CALL _itoa
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(_lcdnum)
	LDI  R31,HIGH(_lcdnum)
	ST   -Y,R31
	ST   -Y,R30
	CALL _lcd_puts_row
	__POINTW1FN _0x0,52
	RJMP SUBOPT_0x2

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB:
	__POINTW1MN _tmpimage,16
	ST   -Y,R31
	ST   -Y,R30
	JMP  _lcd_puts

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0xC:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _lcd_putsf_row

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD:
	ST   -Y,R17
	LDS  R26,_StandaloneMode
	CPI  R26,LOW(0x0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0xE:
	LDI  R30,LOW(3)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _Beeps

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xF:
	LDI  R30,LOW(1)
	ST   -Y,R30
	__POINTW1FN _0x0,65
	RJMP SUBOPT_0xC

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x10:
	LDI  R30,LOW(50)
	LDI  R31,HIGH(50)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x11:
	ST   -Y,R30
	CALL _TestButton
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x12:
	LDI  R30,LOW(1)
	ST   -Y,R30
	ST   -Y,R30
	JMP  _Beeps

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x13:
	LDI  R30,LOW(4)
	STS  _StandaloneMode,R30
	LDI  R30,LOW(2)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _Beeps

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x14:
	STS  _StandaloneMode,R30
	SBI  0x5,1
	SBI  0x5,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x15:
	LDS  R30,_dirnum
	LDI  R26,LOW(_SaveDirNum)
	LDI  R27,HIGH(_SaveDirNum)
	CALL __EEPROMWRB
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x16:
	CALL __EEPROMWRB
	LDI  R30,LOW(2)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _Beeps

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x17:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x18:
	LDI  R30,LOW(2)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _Beeps

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x19:
	LDS  R30,_dirnum
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,8
	ST   -Y,R31
	ST   -Y,R30
	JMP  _itoa

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x1A:
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	JMP  _lcd_puts

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x1B:
	__GETW1MN _tmpimage,70
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x1C:
	__GETW1MN _tmpimage,72
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1D:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _lcd_puts

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x1E:
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDD  R30,Y+3
	ST   -Y,R30
	JMP  _lcd_gotoxy

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x1F:
	STS  124,R30
	__DELAY_USB 80
	LDS  R30,122
	ORI  R30,0x40
	STS  122,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x20:
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x21:
	ST   -Y,R17
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _CheckCommParams
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 35 TIMES, CODE SIZE REDUCTION:133 WORDS
SUBOPT_0x22:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _printf
	ADIW R28,2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x23:
	LDD  R30,Y+2
	ST   -Y,R30
	CALL _ExSPI
	LDD  R30,Y+1
	ST   -Y,R30
	CALL _ExSPI
	LD   R30,Y
	ST   -Y,R30
	JMP  _ExSPI

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x24:
	LDI  R30,LOW(172)
	ST   -Y,R30
	LDI  R30,LOW(83)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _Write123

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x25:
	LDI  R30,LOW(20)
	LDI  R31,HIGH(20)
	RJMP SUBOPT_0x17

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:37 WORDS
SUBOPT_0x26:
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _CheckCommParams
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x27:
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _CheckCommParams
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x28:
	CBI  0x5,1
	CBI  0x5,1
	CALL _GetOneChar
	MOV  R17,R30
	CALL _GetOneChar
	MOV  R16,R30
	CALL _GetOneChar
	MOV  R19,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x29:
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _Write1234

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x2A:
	ST   -Y,R30
	CALL _PutOneChar
	LDI  R30,LOW(13)
	ST   -Y,R30
	CALL _PutOneChar
	RJMP SUBOPT_0x8

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x2B:
	LDI  R30,LOW(4)
	ST   -Y,R30
	CALL _CheckCommParams
	LDS  R30,_g_NeedParams
	CPI  R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x2C:
	CBI  0x5,1
	CALL _GetOneChar
	MOV  R17,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:36 WORDS
SUBOPT_0x2D:
	LDS  R30,_g_Addr+1
	ANDI R31,HIGH(0x0)
	LSL  R30
	LSL  R30
	LSL  R30
	MOV  R26,R30
	LDS  R30,_g_Addr+1
	LDI  R31,0
	LDI  R31,0
	CALL __ASRW3
	ANDI R30,LOW(0x4)
	OR   R30,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x2E:
	ST   -Y,R30
	LDS  R30,_g_Addr
	ST   -Y,R30
	ST   -Y,R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x2F:
	ST   -Y,R30
	LDS  R30,_g_Addr+1
	ANDI R31,HIGH(0x0)
	RJMP SUBOPT_0x2E

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x30:
	LDI  R26,LOW(_g_Addr)
	LDI  R27,HIGH(_g_Addr)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x31:
	ORI  R30,1
	ST   -Y,R30
	LDS  R30,_g_Addr
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _Write123

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x32:
	ST   -Y,R30
	LDS  R30,_g_Addr+1
	ANDI R31,HIGH(0x0)
	ST   -Y,R30
	LDS  R30,_g_Addr
	ST   -Y,R30
	RJMP SUBOPT_0x29

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x33:
	ST   -Y,R30
	LDS  R30,_g_Addr
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _Write123

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x34:
	CBI  0x5,1
	LDI  R30,LOW(1)
	MOV  R10,R30
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x35:
	ST   -Y,R17
	ST   -Y,R16
	RJMP SUBOPT_0x26

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x36:
	CBI  0x5,1
	LDI  R30,LOW(1)
	MOV  R10,R30
	LDI  R17,LOW(13)
	CALL _GetOneChar
	MOV  R16,R30
	LDS  R26,_g_DeviceType
	CPI  R26,LOW(0x2)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x37:
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R16
	JMP  _Write1234

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x38:
	ST   -Y,R17
	CALL _PutOneChar
	SBI  0x5,1
	CLR  R10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x39:
	CALL _GetOneChar
	MOV  R17,R30
	CALL _GetOneChar
	MOV  R16,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x3A:
	STS  _g_BlockSize,R30
	STS  _g_BlockSize+1,R31
	STS  _g_BlockSize+2,R22
	STS  _g_BlockSize+3,R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x3B:
	LDS  R30,_g_BlockSize
	LDS  R31,_g_BlockSize+1
	LDS  R22,_g_BlockSize+2
	LDS  R23,_g_BlockSize+3
	CALL __LSRD1
	RJMP SUBOPT_0x3A

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x3C:
	LDI  R26,LOW(_g_BlockSize)
	LDI  R27,HIGH(_g_BlockSize)
	CALL __GETD1P_INC
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL __PUTDP1_DEC
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3D:
	CLR  R22
	CLR  R23
	CALL __ORD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x3E:
	LDI  R26,LOW(_g_BlockSize)
	LDI  R27,HIGH(_g_BlockSize)
	CALL __GETD1P_INC
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL __PUTDP1_DEC
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 50 TIMES, CODE SIZE REDUCTION:144 WORDS
SUBOPT_0x3F:
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x40:
	LDI  R24,12
	CALL _printf
	ADIW R28,14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 48 TIMES, CODE SIZE REDUCTION:91 WORDS
SUBOPT_0x41:
	LDI  R24,4
	CALL _printf
	ADIW R28,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x42:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _error

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x43:
	CALL __CBD1
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 18 TIMES, CODE SIZE REDUCTION:65 WORDS
SUBOPT_0x44:
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RJMP SUBOPT_0x41

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x45:
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _tmpimage,75
	RJMP SUBOPT_0x44

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x46:
	LDI  R24,16
	CALL _printf
	ADIW R28,18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x47:
	__GETD1MN _tmpimage,64
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x48:
	CALL __PUTPARD1
	RJMP SUBOPT_0x41

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x49:
	ST   -Y,R31
	ST   -Y,R30
	__GETW1MN _tmpimage,68
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x4A:
	LDS  R30,_dirnum
	LDI  R26,LOW(5)
	MUL  R30,R26
	MOVW R30,R0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x4B:
	SUBI R30,LOW(-_myimage)
	SBCI R31,HIGH(-_myimage)
	MOVW R26,R30
	CALL __EEPROMRDD
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x4C:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _AVR910_Standalone

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x4D:
	ST   -Y,R31
	ST   -Y,R30
	CALL _GetConfigValue
	STS  _value,R30
	STS  _value+1,R31
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x4E:
	LDS  R30,_value
	LDS  R31,_value+1
	ST   -Y,R31
	ST   -Y,R30
	JMP  _atoi

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4F:
	__ADDW1MN _myimage,4
	MOVW R26,R30
	CALL __EEPROMRDB
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x50:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_buffer)
	LDI  R31,HIGH(_buffer)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:53 WORDS
SUBOPT_0x51:
	ST   -Y,R31
	ST   -Y,R30
	CALL _GetValue
	STS  _value,R30
	STS  _value+1,R31
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x52:
	SUBI R30,LOW(-_myimage)
	SBCI R31,HIGH(-_myimage)
	MOVW R26,R30
	__GETD1N 0x0
	CALL __EEPROMWRD
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x53:
	SUBI R30,LOW(-_myimage)
	SBCI R31,HIGH(-_myimage)
	MOVW R26,R30
	CALL __EEPROMRDW
	__PUTW1MN _tmpimage,70
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x54:
	LDS  R30,_value
	LDS  R31,_value+1
	ST   -Y,R31
	ST   -Y,R30
	JMP  _atol

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x55:
	LDS  R30,_value
	LDS  R31,_value+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x56:
	__POINTW1MN _tmpimage,60
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x57:
	LDI  R30,LOW(4)
	ST   -Y,R30
	JMP  _hextobytes

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x58:
	__POINTW1MN _tmpimage,56
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x59:
	__POINTW1MN _tmpimage,52
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x5A:
	ST   -Y,R31
	ST   -Y,R30
	CALL _GetValue
	STS  _value,R30
	STS  _value+1,R31
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5B:
	__GETB1MN _g_txBuf,1
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5C:
	LDS  R30,_g_txBuf
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x5D:
	ST   -Y,R30
	CALL _FIFO_Write
	JMP  _AVR910_Command

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x5E:
	LDS  R26,_pageaddr
	LDS  R27,_pageaddr+1
	LDS  R24,_pageaddr+2
	LDS  R25,_pageaddr+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x5F:
	__GETW1MN _tmpimage,68
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x60:
	CLR  R22
	CLR  R23
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x61:
	CLR  R24
	CLR  R25
	CALL __CPD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x62:
	CALL __PUTPARD1
	LDI  R24,8
	CALL _printf
	ADIW R28,10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x63:
	__SUBD1N -1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 56 TIMES, CODE SIZE REDUCTION:162 WORDS
SUBOPT_0x64:
	CALL _hextext_read_byte
	ST   -Y,R30
	JMP  _hexton

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x65:
	MOV  R21,R30
	SWAP R30
	ANDI R30,0xF0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x66:
	ADD  R30,R26
	MOV  R21,R30
	ADD  R20,R21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x67:
	__PUTD1S 7
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x68:
	__GETD2S 7
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x69:
	CALL __CWD1
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6A:
	LDS  R30,_OffsetX16
	LDS  R31,_OffsetX16+1
	LDS  R22,_OffsetX16+2
	LDS  R23,_OffsetX16+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x6B:
	LDI  R31,0
	CALL __CWD1
	MOVW R26,R30
	MOVW R24,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x6C:
	LDI  R30,LOW(12)
	CALL __LSLD12
	STS  _OffsetX16,R30
	STS  _OffsetX16+1,R31
	STS  _OffsetX16+2,R22
	STS  _OffsetX16+3,R23
	RJMP SUBOPT_0x64

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0x6D:
	LDI  R30,LOW(4)
	CALL __LSLD12
	LDS  R26,_OffsetX16
	LDS  R27,_OffsetX16+1
	LDS  R24,_OffsetX16+2
	LDS  R25,_OffsetX16+3
	CALL __ORD12
	STS  _OffsetX16,R30
	STS  _OffsetX16+1,R31
	STS  _OffsetX16+2,R22
	STS  _OffsetX16+3,R23
	RJMP SUBOPT_0x64

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6E:
	ADD  R30,R26
	MOV  R21,R30
	ADD  R20,R21
	CPI  R20,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x6F:
	__POINTW1FN _0x40000,1567
	RJMP SUBOPT_0x42

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x70:
	__POINTW1FN _0x40000,1582
	RJMP SUBOPT_0x42

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x71:
	ADD  R30,R26
	MOV  R21,R30
	ADD  R20,R21
	RJMP SUBOPT_0x64

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x72:
	MOV  R16,R30
	SWAP R30
	ANDI R30,0xF0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x73:
	ADD  R30,R26
	MOV  R16,R30
	ADD  R19,R16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x74:
	__PUTD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x75:
	__GETD2S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x76:
	ADD  R30,R26
	MOV  R16,R30
	ADD  R19,R16
	CPI  R19,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x77:
	ADD  R30,R26
	MOV  R16,R30
	ADD  R19,R16
	RJMP SUBOPT_0x64

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x78:
	__GETD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x79:
	__POINTW1FN _0x40000,1623
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 6
	RJMP SUBOPT_0x48

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x7A:
	__POINTW1FN _0x40000,1658
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R16
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x7B:
	ADIW R30,1
	ST   -Y,R31
	ST   -Y,R30
	JMP  _pgm_read_byte

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x7C:
	OR   R30,R26
	MOV  R17,R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0x7D:
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R17
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x7E:
	ST   -Y,R30
	CALL _FIFO_Write
	ST   -Y,R17
	CALL _FIFO_Write
	CALL _AVR910_Command
	JMP  _AVR910_ResetTXData

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x7F:
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	JMP  _pgm_read_byte

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x80:
	ADIW R30,3
	ST   -Y,R31
	ST   -Y,R30
	JMP  _pgm_read_byte

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x81:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _pgm_read_byte

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x82:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	RJMP SUBOPT_0x7B

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x83:
	COM  R30
	OR   R16,R30
	LDS  R30,_debug
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x84:
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R16
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x85:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	RJMP SUBOPT_0x7F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x86:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	RJMP SUBOPT_0x80

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x87:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	RJMP SUBOPT_0x81

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x88:
	LDI  R30,LOW(255)
	STS  133,R30
	LDI  R30,LOW(139)
	STS  132,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x89:
	LDI  R26,LOW(_error_msg*2)
	LDI  R27,HIGH(_error_msg*2)
	LDI  R31,0
	LSL  R30
	ROL  R31
	ADD  R30,R26
	ADC  R31,R27
	CALL __GETW1PF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x8A:
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x62

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x8B:
	LDS  R30,_res
	ST   -Y,R30
	JMP  _RESerror

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x8C:
	LDS  R30,_nbytes
	LDS  R31,_nbytes+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x8D:
	SUBI R30,LOW(-_buffer)
	SBCI R31,HIGH(-_buffer)
	LDI  R26,LOW(0)
	STD  Z+0,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x8E:
	__GETB1MN _tmpimage,92
	LDI  R31,0
	ADIW R30,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x8F:
	LDI  R30,LOW(_buffer)
	LDI  R31,HIGH(_buffer)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
SUBOPT_0x90:
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_nbytes)
	LDI  R31,HIGH(_nbytes)
	ST   -Y,R31
	ST   -Y,R30
	CALL _pf_read
	STS  _res,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x91:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x92:
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0x60000,418
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x93:
	__POINTW1FN _0x60000,418
	ST   -Y,R31
	ST   -Y,R30
	JMP  _strlenf

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x94:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R20
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	LDI  R26,LOW(_tmpbytes)
	LDI  R27,HIGH(_tmpbytes)
	ADD  R26,R20
	ADC  R27,R21
	LD   R30,X
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x95:
	LDI  R26,LOW(_buffer)
	LDI  R27,HIGH(_buffer)
	ADD  R26,R20
	ADC  R27,R21
	LD   R30,X
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x96:
	LDI  R26,LOW(_tmpbytes)
	LDI  R27,HIGH(_tmpbytes)
	ADD  R26,R20
	ADC  R27,R21
	LD   R30,X
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x97:
	ROL  R30
	LDI  R30,0
	ROL  R30
	OR   R30,R0
	MOVW R26,R22
	ST   X,R30
	MOVW R30,R20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x98:
	SUBI R30,LOW(-_buffer)
	SBCI R31,HIGH(-_buffer)
	MOVW R22,R30
	LD   R0,Z
	__GETB1MN _tmpimage,92
	LDI  R31,0
	LDI  R26,LOW(63)
	LDI  R27,HIGH(63)
	CALL __MANDW12
	SUBI R30,LOW(-_roll*2)
	SBCI R31,HIGH(-_roll*2)
	LPM  R30,Z
	EOR  R30,R0
	MOVW R26,R22
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x99:
	ST   -Y,R31
	ST   -Y,R30
	CALL _strstrf
	MOVW R18,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:28 WORDS
SUBOPT_0x9A:
	ST   -Y,R31
	ST   -Y,R30
	CALL _strlenf
	ADIW R30,1
	ADD  R30,R18
	ADC  R31,R19
	MOVW R16,R30
	LDI  R30,LOW(_tmpbytes)
	LDI  R31,HIGH(_tmpbytes)
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL _strncpy
	__POINTWRM 16,17,_tmpbytes
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(13)
	ST   -Y,R30
	CALL _strpos
	ADD  R30,R16
	ADC  R31,R17
	LDI  R26,LOW(0)
	STD  Z+0,R26
	LDS  R30,_debug
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9B:
	CALL __SAVELOCR4
	__GETWRN 16,17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x9C:
	__POINTW1FN _0x60000,519
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	RJMP SUBOPT_0x44

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x9D:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	MOVW R30,R16
	RJMP SUBOPT_0x8A

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x9E:
	LDI  R30,LOW(_path)
	LDI  R31,HIGH(_path)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9F:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _strcpyf

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA0:
	LDI  R30,LOW(_tmpbytes)
	LDI  R31,HIGH(_tmpbytes)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA1:
	CALL _pf_open
	STS  _res,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xA2:
	__POINTW1FN _0x60000,565
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_path)
	LDI  R31,HIGH(_path)
	RJMP SUBOPT_0x44

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0xA3:
	__GETD1N 0x0
	CALL __PUTPARD1
	CALL _pf_lseek
	STS  _res,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA4:
	__POINTW1FN _0x60000,588
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_path)
	LDI  R31,HIGH(_path)
	RJMP SUBOPT_0x44

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0xA5:
	LDI  R30,LOW(511)
	LDI  R31,HIGH(511)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_nbytes)
	LDI  R31,HIGH(_nbytes)
	ST   -Y,R31
	ST   -Y,R30
	CALL _pf_read
	STS  _res,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xA6:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA7:
	CALL _strlenf
	ADIW R30,1
	ADD  R30,R18
	ADC  R31,R19
	MOVW R16,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xA8:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_nbytes)
	LDI  R31,HIGH(_nbytes)
	ST   -Y,R31
	ST   -Y,R30
	CALL _pf_write
	STS  _res,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xA9:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0xAA:
	ST   -Y,R30
	__GETD1N 0x0
	CALL __PUTPARD1
	JMP  _send_cmd_G004

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xAB:
	ST   -Y,R30
	CALL _xmit_spi
	__GETD2S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0xAC:
	__GETD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xAD:
	__GETD1N 0x0
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xAE:
	CALL __PUTPARD1
	JMP  _send_cmd_G004

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAF:
	MOV  R30,R17
	LDI  R31,0
	MOVW R26,R28
	ADIW R26,6
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB0:
	__GETD1N 0x200
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xB1:
	__GETD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB2:
	__GETD2N 0x200
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0xB3:
	__PUTD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB4:
	__GETD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB5:
	LDS  R30,_FatFs_G005
	LDS  R31,_FatFs_G005+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB6:
	__GETD2S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xB7:
	__CPD2N 0x2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB8:
	MOVW R30,R28
	ADIW R30,8
	RJMP SUBOPT_0x91

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xB9:
	__GETD2Z 12
	MOVW R30,R18
	RJMP SUBOPT_0x60

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xBA:
	LDI  R30,LOW(2)
	LDI  R31,HIGH(2)
	ST   -Y,R31
	ST   -Y,R30
	CALL _disk_readp
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xBB:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	ST   -Y,R31
	ST   -Y,R30
	CALL _disk_readp
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xBC:
	__GETD2Z 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xBD:
	__GETD2S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xBE:
	CALL __ADDD12
	CALL __PUTPARD1
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xBF:
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0xBA

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xC0:
	ST   -Y,R31
	ST   -Y,R30
	CALL _disk_readp
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xC1:
	ST   -Y,R17
	ST   -Y,R16
	__GETWRMN 16,17,0,_FatFs_G005
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xC2:
	__PUTD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xC3:
	__GETD2S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xC4:
	__GETD1N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xC5:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC6:
	CALL __GETD1P
	RJMP SUBOPT_0xC2

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xC7:
	RCALL SUBOPT_0xC3
	__CPD2N 0x1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC8:
	RCALL SUBOPT_0xAC
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xC9:
	RCALL SUBOPT_0xAC
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCA:
	CALL __SAVELOCR4
	__GETWRMN 18,19,0,_FatFs_G005
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCB:
	CALL __PUTPARD2
	JMP  _get_fat_G005

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xCC:
	LDS  R26,_FatFs_G005
	LDS  R27,_FatFs_G005+1
	ADIW R26,6
	LD   R18,X+
	LD   R19,X
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCD:
	CALL __GETW1P
	STD  Y+6,R30
	STD  Y+6+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xCE:
	MOV  R30,R18
	SUBI R18,-1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R31,0
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xCF:
	MOV  R30,R21
	SUBI R21,-1
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD0:
	RCALL SUBOPT_0xC4
	CALL __PUTDP1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xD1:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xD2:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,2
	CALL __GETW1P
	LDD  R30,Z+11
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD3:
	CALL __GETW1P
	CLR  R22
	CLR  R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD4:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0xD5:
	MOVW R30,R28
	ADIW R30,17
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 15
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD6:
	__PUTD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD7:
	MOVW R30,R28
	ADIW R30,31
	SBIW R30,13
	MOVW R26,R30
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xD8:
	LDD  R30,Y+53
	LDD  R31,Y+53+1
	LDD  R26,Z+4
	LDD  R27,Z+5
	MOVW R30,R26
	CALL __LSRW4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD9:
	LDD  R30,Z+1
	LDI  R31,0
	CALL __CWD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xDA:
	LDD  R30,Y+53
	LDD  R31,Y+53+1
	RCALL SUBOPT_0xBC
	RCALL SUBOPT_0xB4
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xDB:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__GETD2Z 24
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xDC:
	RCALL SUBOPT_0xB0
	CALL __DIVD21U
	MOVW R26,R30
	MOVW R24,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xDD:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__GETD2Z 36
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xDE:
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xDF:
	ADIW R26,3
	LD   R30,X
	SUBI R30,-LOW(1)
	ST   X,R30
	SUBI R30,LOW(1)
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE0:
	LDD  R26,Z+24
	LDD  R27,Z+25
	MOVW R30,R26
	ANDI R31,HIGH(0x1FF)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE1:
	__GETD2Z 40
	CALL __PUTPARD2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xE2:
	ADIW R30,24
	MOVW R0,R30
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE3:
	ADIW R26,2
	LDI  R30,LOW(0)
	ST   X,R30
	LDI  R30,LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE4:
	MOVW R30,R20
	__GETD2Z 24
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE5:
	__PUTD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE6:
	__PUTD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xE7:
	__GETD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xE8:
	__GETD1S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE9:
	__GETD2S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xEA:
	CALL __GETD1P
	__GETD2S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xEB:
	__GETD2S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xEC:
	__GETD1S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xED:
	__SUBD1N 1
	MOVW R26,R30
	MOVW R24,R22
	RCALL SUBOPT_0xE8
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xEE:
	RCALL SUBOPT_0xE7
	__PUTD1RNS 16,36
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xEF:
	ST   -Y,R30
	CALL __lcd_write_data
	LDI  R30,LOW(3)
	LDI  R31,HIGH(3)
	RJMP SUBOPT_0x17

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xF0:
	LDI  R30,LOW(48)
	ST   -Y,R30
	CALL __lcd_write_nibble_G100
	__DELAY_USW 300
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF1:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,1
	STD  Y+6,R26
	STD  Y+6+1,R27
	SBIW R26,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF2:
	RCALL SUBOPT_0xAC
	__GETD2S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0xF3:
	ST   -Y,R18
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0xF4:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	SBIW R30,4
	STD  Y+21,R30
	STD  Y+21+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xF5:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ICALL
	RET


	.CSEG
_delay_ms:
	ld   r30,y+
	ld   r31,y+
	adiw r30,0
	breq __delay_ms1
__delay_ms0:
	__DELAY_USW 0xBB8
	wdr
	sbiw r30,1
	brne __delay_ms0
__delay_ms1:
	ret

__ADDW2R15:
	CLR  R0
	ADD  R26,R15
	ADC  R27,R0
	RET

__ADDD12:
	ADD  R30,R26
	ADC  R31,R27
	ADC  R22,R24
	ADC  R23,R25
	RET

__ADDD21:
	ADD  R26,R30
	ADC  R27,R31
	ADC  R24,R22
	ADC  R25,R23
	RET

__SUBD12:
	SUB  R30,R26
	SBC  R31,R27
	SBC  R22,R24
	SBC  R23,R25
	RET

__SUBD21:
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R25,R23
	RET

__ANDD12:
	AND  R30,R26
	AND  R31,R27
	AND  R22,R24
	AND  R23,R25
	RET

__ORD12:
	OR   R30,R26
	OR   R31,R27
	OR   R22,R24
	OR   R23,R25
	RET

__ANEGW1:
	NEG  R31
	NEG  R30
	SBCI R31,0
	RET

__ANEGD1:
	COM  R31
	COM  R22
	COM  R23
	NEG  R30
	SBCI R31,-1
	SBCI R22,-1
	SBCI R23,-1
	RET

__LSLB12:
	TST  R30
	MOV  R0,R30
	MOV  R30,R26
	BREQ __LSLB12R
__LSLB12L:
	LSL  R30
	DEC  R0
	BRNE __LSLB12L
__LSLB12R:
	RET

__LSLW12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	BREQ __LSLW12R
__LSLW12L:
	LSL  R30
	ROL  R31
	DEC  R0
	BRNE __LSLW12L
__LSLW12R:
	RET

__LSLD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSLD12R
__LSLD12L:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R0
	BRNE __LSLD12L
__LSLD12R:
	RET

__LSRD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSRD12R
__LSRD12L:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R0
	BRNE __LSRD12L
__LSRD12R:
	RET

__LSLW4:
	LSL  R30
	ROL  R31
__LSLW3:
	LSL  R30
	ROL  R31
__LSLW2:
	LSL  R30
	ROL  R31
	LSL  R30
	ROL  R31
	RET

__ASRW3:
	ASR  R31
	ROR  R30
__ASRW2:
	ASR  R31
	ROR  R30
	ASR  R31
	ROR  R30
	RET

__LSRW4:
	LSR  R31
	ROR  R30
__LSRW3:
	LSR  R31
	ROR  R30
__LSRW2:
	LSR  R31
	ROR  R30
	LSR  R31
	ROR  R30
	RET

__LSRD1:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	RET

__LSRD16:
	MOV  R30,R22
	MOV  R31,R23
	LDI  R22,0
	LDI  R23,0
	RET

__LSLD16:
	MOV  R22,R30
	MOV  R23,R31
	LDI  R30,0
	LDI  R31,0
	RET

__CBD1:
	MOV  R31,R30
	ADD  R31,R31
	SBC  R31,R31
	MOV  R22,R31
	MOV  R23,R31
	RET

__CWD1:
	MOV  R22,R31
	ADD  R22,R22
	SBC  R22,R22
	MOV  R23,R22
	RET

__COMD1:
	COM  R30
	COM  R31
	COM  R22
	COM  R23
	RET

__MULD12U:
	MUL  R23,R26
	MOV  R23,R0
	MUL  R22,R27
	ADD  R23,R0
	MUL  R31,R24
	ADD  R23,R0
	MUL  R30,R25
	ADD  R23,R0
	MUL  R22,R26
	MOV  R22,R0
	ADD  R23,R1
	MUL  R31,R27
	ADD  R22,R0
	ADC  R23,R1
	MUL  R30,R24
	ADD  R22,R0
	ADC  R23,R1
	CLR  R24
	MUL  R31,R26
	MOV  R31,R0
	ADD  R22,R1
	ADC  R23,R24
	MUL  R30,R27
	ADD  R31,R0
	ADC  R22,R1
	ADC  R23,R24
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	ADC  R22,R24
	ADC  R23,R24
	RET

__DIVW21U:
	CLR  R0
	CLR  R1
	LDI  R25,16
__DIVW21U1:
	LSL  R26
	ROL  R27
	ROL  R0
	ROL  R1
	SUB  R0,R30
	SBC  R1,R31
	BRCC __DIVW21U2
	ADD  R0,R30
	ADC  R1,R31
	RJMP __DIVW21U3
__DIVW21U2:
	SBR  R26,1
__DIVW21U3:
	DEC  R25
	BRNE __DIVW21U1
	MOVW R30,R26
	MOVW R26,R0
	RET

__DIVD21U:
	PUSH R19
	PUSH R20
	PUSH R21
	CLR  R0
	CLR  R1
	CLR  R20
	CLR  R21
	LDI  R19,32
__DIVD21U1:
	LSL  R26
	ROL  R27
	ROL  R24
	ROL  R25
	ROL  R0
	ROL  R1
	ROL  R20
	ROL  R21
	SUB  R0,R30
	SBC  R1,R31
	SBC  R20,R22
	SBC  R21,R23
	BRCC __DIVD21U2
	ADD  R0,R30
	ADC  R1,R31
	ADC  R20,R22
	ADC  R21,R23
	RJMP __DIVD21U3
__DIVD21U2:
	SBR  R26,1
__DIVD21U3:
	DEC  R19
	BRNE __DIVD21U1
	MOVW R30,R26
	MOVW R22,R24
	MOVW R26,R0
	MOVW R24,R20
	POP  R21
	POP  R20
	POP  R19
	RET

__MANDW12:
	CLT
	SBRS R31,7
	RJMP __MANDW121
	RCALL __ANEGW1
	SET
__MANDW121:
	AND  R30,R26
	AND  R31,R27
	BRTC __MANDW122
	RCALL __ANEGW1
__MANDW122:
	RET

__MODD21U:
	RCALL __DIVD21U
	MOVW R30,R26
	MOVW R22,R24
	RET

__GETW1P:
	LD   R30,X+
	LD   R31,X
	SBIW R26,1
	RET

__GETD1P:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X
	SBIW R26,3
	RET

__GETD1P_INC:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X+
	RET

__PUTDP1:
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	RET

__PUTDP1_DEC:
	ST   -X,R23
	ST   -X,R22
	ST   -X,R31
	ST   -X,R30
	RET

__GETW1PF:
	LPM  R0,Z+
	LPM  R31,Z
	MOV  R30,R0
	RET

__PUTPARD1:
	ST   -Y,R23
	ST   -Y,R22
	ST   -Y,R31
	ST   -Y,R30
	RET

__PUTPARD2:
	ST   -Y,R25
	ST   -Y,R24
	ST   -Y,R27
	ST   -Y,R26
	RET

__SWAPD12:
	MOV  R1,R24
	MOV  R24,R22
	MOV  R22,R1
	MOV  R1,R25
	MOV  R25,R23
	MOV  R23,R1

__SWAPW12:
	MOV  R1,R27
	MOV  R27,R31
	MOV  R31,R1

__SWAPB12:
	MOV  R1,R26
	MOV  R26,R30
	MOV  R30,R1
	RET

__EEPROMRDD:
	ADIW R26,2
	RCALL __EEPROMRDW
	MOVW R22,R30
	SBIW R26,2

__EEPROMRDW:
	ADIW R26,1
	RCALL __EEPROMRDB
	MOV  R31,R30
	SBIW R26,1

__EEPROMRDB:
	SBIC EECR,EEWE
	RJMP __EEPROMRDB
	PUSH R31
	IN   R31,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R30,EEDR
	OUT  SREG,R31
	POP  R31
	RET

__EEPROMWRD:
	RCALL __EEPROMWRW
	ADIW R26,2
	MOVW R0,R30
	MOVW R30,R22
	RCALL __EEPROMWRW
	MOVW R30,R0
	SBIW R26,2
	RET

__EEPROMWRW:
	RCALL __EEPROMWRB
	ADIW R26,1
	PUSH R30
	MOV  R30,R31
	RCALL __EEPROMWRB
	POP  R30
	SBIW R26,1
	RET

__EEPROMWRB:
	SBIS EECR,EEWE
	RJMP __EEPROMWRB1
	WDR
	RJMP __EEPROMWRB
__EEPROMWRB1:
	IN   R25,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R24,EEDR
	CP   R30,R24
	BREQ __EEPROMWRB0
	OUT  EEDR,R30
	SBI  EECR,EEMWE
	SBI  EECR,EEWE
__EEPROMWRB0:
	OUT  SREG,R25
	RET

__CPD10:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	RET

__CPD02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	CPC  R0,R24
	CPC  R0,R25
	RET

__CPD12:
	CP   R30,R26
	CPC  R31,R27
	CPC  R22,R24
	CPC  R23,R25
	RET

__CPD21:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R25,R23
	RET

__SAVELOCR6:
	ST   -Y,R21
__SAVELOCR5:
	ST   -Y,R20
__SAVELOCR4:
	ST   -Y,R19
__SAVELOCR3:
	ST   -Y,R18
__SAVELOCR2:
	ST   -Y,R17
	ST   -Y,R16
	RET

__LOADLOCR6:
	LDD  R21,Y+5
__LOADLOCR5:
	LDD  R20,Y+4
__LOADLOCR4:
	LDD  R19,Y+3
__LOADLOCR3:
	LDD  R18,Y+2
__LOADLOCR2:
	LDD  R17,Y+1
	LD   R16,Y
	RET

;END OF CODE MARKER
__END_OF_CODE:
